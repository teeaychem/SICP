#+STARTUP: Overview
#+PROPERTY: header-args :noweb eval :results output :tangle tangle.rkt :prologue "#lang sicp"
#+TITLE: SICP Exercises

* Some notes

** Racket and org

To get Racket working inside org-mode I'm using [[https://github.com/hasu/emacs-ob-racket][emacs-ob-racket by hasu]] and [[https://racket-mode.com][racket-mode]].

The relevant part of my emacs config looks like:

: (add-to-list 'load-path "~/path/to/emacs-ob-racket")
: (add-to-list 'org-src-lang-modes '("racket" . racket))
:    (org-babel-do-load-languages
:  'org-babel-load-languages
:  '((racket . t)))

You can run procedures through org mode, or by copying selections from code blocks to a .rkt file.

** code-block syntax

Code blocks are as follows:

: #+NAME:
: #+BEGIN_SRC racket
: wwwww
: #+END_SRC

name is optional etc.

At the start of this file I have:

: #+PROPERTY: header-args :prologue "#lang sicp" :noweb yes :results output

Using :lang scip also works, but the tangled result is the same as prologue

: #+PROPERTY: header-args :lang sicp :noweb yes :results output

** Referenced code-blocks

Exercises in SICP often use code from earlier exercises.

In order to avoid repeat code there are two options:

1. Keep a large file of all previous code.
2. Isolate previous code, but make a call to evaluate it when required.

This document takes the latter option.
However, this introcudes some small issues.

First, we need to name and reference blocks of code.

A nanmed block of code begins with: #+NAME:
To help clarify what's being referenced, a few common prefixes are used:

| def:    | definitions                   |
| sc:     | selectors and/or constructors |
| consts: | constants                     |

A block of code is referenced by <<name>>

The main issue is that a block of code may be evaluated twice if references are made naively, and #lang sicp isn't friendly to redefinition.

So, to avoid this issue, references are inlined when possible.

This is inefficient, and a little messy.

But, I think it's an okay trade-off.




* Chapter 1

** 1.1

#+BEGIN_SRC racket
  10 ;; 10

  (+ 5 3 4) ;; 12

  (- 9 1) ;; 8

  (/ 6 2) ;; 3

  (+ (* 2 4) (- 4 6)) ;; 6

  (define a 3)
  (define b (+ a 1))

  (+ a b (* a b)) ;; 6

  (= a b) ;; #f

  (if (and (> b a) (< b (* a b))) b a) ;; b, as 4 > 3, 4 < 12

  (cond ((= a 4) 6) ;; #f
	((= b 4) (+ 6 7 a)) ;; #t
	(else 25))

  (+ 2 (if (> b a) b a))

  (* (cond ((> a b) a)
	   ((< a b) b)  ;; #t
	   (else -1))
     (+ a 1) ;; 4
     ) ;; (* 4 4) = 16
#+END_SRC

** 1.2

#+BEGIN_SRC racket
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
#+END_SRC

** 1.3

Sum of squares function.
First, compare a and b.
If a >= b fix a, else b.
If a, then compare b and c.
If b, then compare a and c.

#+NAME: def:square
#+BEGIN_SRC racket
      (define (square x) (* x x))
#+END_SRC

#+BEGIN_SRC racket
  (define (sumSquare a b)
    <<def:square>>
    (+ (square a) (square b)))

  (define (twoBig a b c)
    (if
     (>= a b)
     (if (>= b c) (sumSquare a b) (sumSquare a c)) ;: Keeping a
     (if (>= a c) (sumSquare b a) (sumSquare b c)) ;: Keeping b
     ))

  ;; Test possible combinations
  (twoBig 1 2 3)
  (twoBig 2 3 1)
  (twoBig 3 1 3)
#+END_SRC

** 1.4

#+BEGIN_SRC racket
  (define (a-plus-abs-b a b) ;; Define procedure with two arguments
    ((if (> b 0) ;; Operator position is a procedure, so begin by evaluating this.
	 +       ;; Returns + procedure if b > 0, else the - procedure.
	 -) a b))

  (a-plus-abs-b 4 4)   ;; b > 0, so 4 + 4
  (a-plus-abs-b -4 4)  ;; b > 0, so -4 + 4
  (a-plus-abs-b 4 -4)  ;; b < 0, so (4 - -4) = (4 + 4)
  (a-plus-abs-b -4 -4) ;; b < 0, so (-4 - -4) = (-4 + 4) = 0
#+END_SRC

** 1.5

#+BEGIN_SRC racket
  (define (p) (p))

  (define (test x y)
    (if (= x 0)
	0
	y))
#+END_SRC

With applicative-order, start by evaluating test.
test is an if statement, so the predicate is evaluated.
The predicate contains x, so x is evaluated.
0 = 0, so test returns 0.
y / (p) is not evaluated.

With normal-order evluation, start by evaluating test, 0, and (p)
Here, when working through test (p) is substituted in for y.
And, as (p) is a process, it's evaluated.
So, with normal-order, this procedure should fail to terminate.

Key point here is procedure is evaluated first.
In turn, whatever procedure is obtained from this determines which arguments to evaluate.

So, here, first checking whether x or y are 0 would lead to a different result, e.g.

#+BEGIN_SRC racket
  (define (test2 x y)
  (if (or (x = 0) (y = 0)) 0
      (if (= x 0)
          0
          y)))
#+END_SRC

Nothing really changes on good values. If 0 is 0, 0 is returned, else, if 0 is not 0 y is returned, but y is already known to be 0.
Still, in contrast to test we've not got to evaluate y on the first test.
** 1.6

#+BEGIN_SRC racket
  (define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
#+END_SRC

the else-clause evaluated?
For, AOE could be read as saying arguments are only evaluated when applied, and with new-if
it's not clear else-clause is ever *applied*, it's only returned.
And, this should be the case, right.
For, in some cases you can return a procedure, and this wouldn't be possible if you need to
evaluate before returning.

Consider:

#+BEGIN_SRC racket
  (define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))
#+END_SRC

Here, + and - aren't evaluated after the predicate.

But, is it the case that any procedure is automatically evaluated?
I mean, you don't need to call eval explicitly at the top level.

I think this is it.
Any procedure is automatically evaluated.
However, as sqrt-iter is recursive, a new instance of sqrt-iter
is made before any evaluation takes place.
Can see this with rTest

#+BEGIN_SRC racket
(define (rTest x)
	(new-if (> 1 x) 0 (rTest (- x 1))))
(rTest 2)
#+END_SRC

This should terminate fast, but it doesn't.

By contrast, with a call to if, the two options are explicitly
evaluated. So, in a recursive case, as long as the function calls
a conditional which triggers a base case, there's the possibility of
stopping the recursion before it's triggered again.

If this is right, it seems a little subtle for the sixth question...

** 1.7

=good-enough?= checks to see whether =abs(guess^2 - target) < 0.001=.

In the case of small numbers, this not very effective and for large number inadequate.
As good-enough? compares two squared numbers, for small values there won't be much of a difference, while for large number there will be a significant difference.

Observe, squares increaes quickly with magnitude.

#+BEGIN_SRC racket
  <<def:square>>
  (- (square 0.5) (square 0.25))
  (- (square 5) (square 2.5))
  (- (square 50) (square 25))
#+END_SRC

So, with very small numbers, it's harder to get a difference less than 0.001, while for very large numbers it's fairly easy.
This means, more precision is needed to get below the threshold in the
small case, where the resulting difference isn't going to be noticable.
And, less precision is needed in the large case.

#+BEGIN_SRC racket
(define (sqrt2 x) (sqrtItr2 1.0 0.0 x))
#+END_SRC

#+BEGIN_SRC racket
  (define (sqrtItr2 guess previousGuess x)
    (if (goodEnough2? guess previousGuess)
	guess
	(sqrtItr2 (improve guess x) guess x)))
#+END_SRC

Mostly the same but for goodEnough2.

#+BEGIN_SRC racket
(define (goodEnough2? guess previousGuess)
  (< (abs (- guess previousGuess)) 0.001))
#+END_SRC

This, then, works as a limit on the number of significant digits we care about.
Alternatively, can apply to (square guess) (square previousGuess), etc.
Then, it's significant digits of the squared number, rather than root.

#+BEGIN_SRC racket
  (define (improve guess x) (average guess (/ x guess)))
#+END_SRC

#+NAME: def:average
#+BEGIN_SRC racket
  (define (average x y) (/ (+ x y) 2))
#+END_SRC

Things are now reversed.
For small numbers, things are less accurate, as the sqrt of a small number is going to be small, and we'll make smaller and smaller changes by taking the average.

** 1.8

Only thing that changes here is the improve function, where formula for better approximation is given.
goodCubeGuess? could also be adjusted, as with previous exercise.

#+NAME: def:cube
#+BEGIN_SRC racket
(define (cube x) (* x x x))
#+END_SRC

#+NAME: def:cubeRt
#+BEGIN_SRC racket
  (define (cubeRt x)
    (define (cubeInt guess) ; Using block structure and lexical scoping
      <<def:cube>>
      (define (goodCubeGuess? guess) (< (abs (- (cube guess) x)) 0.001)) ; Note x from cubeRt.
      (define (cubeImprove guess) (/ (+ (/ x (* guess guess)) (* 2 guess)) 3)) ; And again
      (if (goodCubeGuess? guess)
	  guess
	  (cubeInt (cubeImprove guess))))
    (cubeInt 1.0))
#+END_SRC

#+BEGIN_SRC racket
  <<def:cubeRt>>
  (cube 3)
  (cubeRt 27)
  (cube 2)
  (cubeRt 8)
#+END_SRC

** 1.9

#+BEGIN_SRC racket
  (define (+ a b)
    (if (= a 0)
	b
	(inc (+ (dec a) b))))
#+END_SRC

#+BEGIN_SRC racket :tangle no
(+ 4 5)
(inc (+ (dec a) b))
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc + 0 5))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+END_SRC

Recursive prodecure and recursive process.

#+BEGIN_SRC racket
  (define (+ a b)
    (if (= a 0)
	b
	(+ (dec a) (inc b))))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (+ 4 5)
  (+ (dec 4) (inc 5))
  (+ 3 6)
  (+ 2 7)
  (+ 1 8)
  (+ 0 9)
  9
#+END_SRC

Recursve procedure but iterative process

** 1.10

#+BEGIN_SRC racket :tangle no
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024
#+END_SRC

#+BEGIN_SRC racket :tangle no
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 (A 1 (A 1 1)))))
(A 1 (A 1 (A 1 (A 1 2))))
(A 1 (A 1 (A 1 (A 0 (A 1 1)))))
(A 1 (A 1 (A 1 (A 0 2))))
(A 1 (A 1 (A 1 4)))
(A 1 (A 1 (A 0 (A 1 3))))
(A 1 (A 1 (A 0 (A 0 (A 1 2)))))
(A 1 (A 1 (A 0 (A 0 (A 0 (A 1 1))))))
(A 1 (A 1 (A 0 (A 0 (A 0 2)))))
(A 1 (A 1 (A 0 (A 0 4))))
(A 1 (A 1 (A 0 8)))
(A 1 (A 1 16))
(A 1 (A 0 (A 1 15)))
#+END_SRC

Okay, this grows in a cool way.


#+NAME: def:A
#+BEGIN_SRC racket :results none
(define (A x y)
  (cond
    ((= y 0) 0)
    ((= x 0) (* 2 y))
    ((= y 1) 2)
    (else (A (- x 1) (A x (- y 1))))))
#+END_SRC


#+BEGIN_SRC racket
  <<def:A>>
  (A 1 10)
  (A 2 4)
  (A 3 3)
  (A 2 3)
#+END_SRC

- (A 0 n) is 2n
- (A 1 n) is 2^n
- (A 2 n) is 2^^(n - 1) i.e. if n = 3, 2^2^2, if n = 4 2^2^2^2

** 1.11

#+BEGIN_SRC racket
  (define (fR n)
    (if (< n 3)
	n
	(+ (fR (- n 1))
	   (* 2 (fR (- n 2)))
	   (* 3 (fR (- n 3))))))

  (define (fI n)
    (if (< n 3)
	n
	(fIHelp n 2 1 0)))

  (define (fIHelp current backOne backTwo backThree)
    (if (= 3 current)
	(+ backOne (* 2 backTwo) (* 3 backThree))
	(fIHelp (- current 1) (+ backOne (* 2 backTwo) (* 3 backThree)) backOne backTwo)))

  (define (testfRI n)
    (= (fR n) (fI n)))

  (testfRI 1)
  (testfRI 3)
  (testfRI 12)
  (testfRI 24)
#+END_SRC

** 1.12

Top left is (1,1) then count down and right.
So, first instance of 2 should be (2 3) and 6 should be (3 5)

Basically, define anything negative as 0.
With this anything positive is filled with, (x, y) = ((x - 1, y - 1) + (x, y - 1)).
I.e. look up left and up above – imagine triangle aligned left.
And, the triangle is generated by fixing (1, 1) as 1.

Very ineffective.

#+BEGIN_SRC racket
  (define (pascal x y)
    (cond
      ((or (< x 1) (< y 1)) 0)
      ((and (= x 1) (= y 1)) 1)
      (else (+ (pascal (- x 1) (- y 1)) (pascal x (- y 1))))))

  (pascal 1 1)
  (pascal 2 2)
  (pascal 3 2)
  (pascal 2 3)
  (pascal 3 5)
  (pascal 3 1)
#+END_SRC

** 1.13

It's clear the goal is to show
(phi^n - psi^n)/sqrt(5) = (phi^(n-1) - psi^(n-1))/sqrt(5) + (phi^(n-2) - psi^(n-2))/sqrt(5)
And, it's easy to go the case of 0 and 1 by hand for regular induction.
But, the induction case... no good idea.

Looking things up, I was going to be lost for a while...
Still, I should remember golden ratio is only positive solution to x + 1 = x^2.
And, phi as given is the golden ratio.
So, phi^(n-2) + phi^(n-1) = phi^(n-2)(phi + 1) = phi^(n-2)phi^2 = phi^n.
This hint might have been enough, as after noticing this with phi, it would be natural to to see
if a similar thing holds for psi.
If only I'd looked back to see that the equation was highlighted...

** 1.14

Steps: Theta(2^n)
Space: Theta(n)

count-change works in a very similar way to tree-recursive fibonacci.
For each call of the alogorithm, at most two calls are made.
One call reduces the amount by at least one.
The other changes the coin of interest.
So, we're asked about a function of the amount, but we can view this as a function of
amount + coins, as coins is constant.
Each call reduces amounts + coins by at least one.
So, after one call we have at most n - 1 calls remaining.
Each of these takes a constant number of steps.
We're doing some tests and then performing summation on the results of the two calls.

For space, I'm following the reasoning on p. 38--9.
We only need to keep track of where to return to.
The algorithm is set to brach n times.
So, the depth of the tree is n.
After each call, the number of leaves doubles.
That is, leaves is given by 2(n-1).
Hence, in total the leaves count to 4(n-1).

To be honest, I think this question is asking the reader to recall p. 39.
The number of steps required by a tree-recursive process will be proportional to the number
of nodes in the tree, while the space required will be proportional to the maximum depth.

For space, important thing to keep in mind is this is max space at any given point in time.
We only need to store a reference to the originial call when starting a new call.
So, in general this will use as much space as calls.
But, at any given time only a certain number of nodes will be in play.
In particular, the height of the tree.
For, there's no need (nor way) to explore multiple nodes at the same time.

** 1.15

*** a.

How many times is p applied?
sine is recursive, and evaluated on every call to sine, but need the result of the recursive call
to be applied.
So, we need to check how many times the recursive call is made before the base case is hit.
12.5/3^5 < 0.1.
So, after 5 additional calls the if condition is true.
p is not applied on the sixth call, but is applied on the 5 other calls.

*** b.

Theta(n) for both steps and space.

Steps, as we've got a test and then possible single recursive call.
There's no way to bound this call, and the other steps take constant(ish) time.
So, n.

Space, as the recursive call returns, need to keep track of the original call.
This is some constant(ish) space for each maximum call depth, which is roughly n.

Right, this is a linear recursive process.

** 1.16

Helper function to test for even

#+NAME: def:even?
#+BEGIN_SRC racket
  (define (even? n)
    (= (remainder n 2) 0))
#+END_SRC

Main fuction, following the hint

#+NAME: def:try
#+BEGIN_SRC racket
  (define (try a b n) ; a is current value, n is number of exponents remaining
     <<def:even?>>
     (cond
       ((= n 0) a)
       ((even? n)  (try a (* b b) (/ n 2))) ; So long as n is even, reduce remaing by half by squaring current.
       ; This is b^n = (b^2)^(n/2)
       ; As input, do a^n
       ; As output, a = a^2, still need a^(n/2)
       (else (try (* a b) b (- n 1)))))
#+END_SRC

#+NAME: def:expItr
#+BEGIN_SRC racket
  (define (expItr b n)
    <<def:try>>
    (try 1 b n)) ; Hide a as a helper variable.
#+END_SRC

#+BEGIN_SRC racket
  <<def:expItr>>
  (expItr 2 4)
  (expItr 6 5) ; Expect 7776
  (expItr 7 1) ; Expect 7
  (expItr 15 3) ; Expect 3375
  (expItr 15 0) ; Expect 1
#+END_SRC

** 1.17

Using =(* 2 x)= for =(double x)= and =(/ x 2)= for =(half x)=.

dhMultH, only works for positive integers.
So, dhMult ensures positive numbers are passed through, and adjusts the result appropriately.

#+NAME: def:multPositiveTranslate
#+BEGIN_SRC racket
(define (multPositiveTranslate func a b)
  ((if (> 0 b) + -) 0 ((if (> 0 a) + -) 0 (func (abs a) (abs b)))))
#+END_SRC

#+NAME: def:dhMult
#+BEGIN_SRC racket
  (define (dhMultH a b)
    (cond
      ((> 0 b) (- 0 (dhMultH a (- 0 b))))
      ((= b 0) 0) ; 0 base case, return 0.
      ((= b 1) a) ; positive base case, return a.
      ((even? b) (* 2 (dhMultH a (/ b 2)))) ; Double whatever I get from halving multiplication to do.
      (else (+ a (dhMultH a (- b 1)))) ; Add b to whatever I get from reducing multiplication by one.
      ))

  (define (dhMult a b)
    <<def:multPositiveTranslate>>
    (multPositiveTranslate dhMultH a b))
#+END_SRC


#+BEGIN_SRC racket
  <<def:dhMult>>
  ;(dhMult 1 4)
  ;(dhMult 5 5)
  (dhMult 5 -8)
  (dhMult 5 8)
  (dhMult 5 -7)
  (dhMult 5 7)
  (dhMult 5 0)
  (dhMult -6 6)
  (dhMult -5 -5)
#+END_SRC

** 1.18


Calculate m * n.
Do this iteratively by doubling m and havling n.
When n is odd, copy the value of m to a store variable, added at the end.
Always go to n = 1, so add m to store variable.

#+NAME: def:dhMultIter
#+BEGIN_SRC racket
  (define (dhMultIterHelp a m n)
      (cond
	((= n 0) a)
	((even? n) (dhMultIterHelp a (* m 2) (/ n 2))) ;
	(else (dhMultIterHelp (+ a m) m (- n 1)))))

    (define (dhMultIterPos m n)
      (dhMultIterHelp 0 m n))

    (define (dhMultIter m n)
      <<def:multPositiveTranslate>>
      (multPositiveTranslate dhMultIterPos m n))
#+END_SRC

Some tests

#+BEGIN_SRC racket
  <<def:dhMultIter>>
  (dhMultIter 2 6)
  (dhMultIter 3 5)
  (dhMultIter 3 0)
  (dhMultIter 0 5)
  (dhMultIter 3 14)
#+END_SRC

** 1.19

Two applications of T_pq reduce to a single application of
a <- b(2pq + q^2) + (2pq + q^2) + a(p^2 + q^2)
b <- b(p^2) + a(2pq + q^2)

So, applied twice we have something of the same form, where:
new_q = (2pq + q^2)
new_p = (p^2)

With this in mind, finishing the function is simple, to double the values of
p and q, apply this transformation to itself.

#+NAME: def:fibI
#+BEGIN_SRC racket
  (define (fibI n)
    (fib-iter 1 0 0 1 n))

  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
	  ((even? count)
	   (fib-iter a
		     b
		     (+ (* p p) (* q q))
		     (+ (* p q) (* q q) (* q p))
		     (/ count 2)))
	  (else (fib-iter (+ (* b q) (* a q) (* a p))
			  (+ (* b p) (* a q))
			  p
			  q
			  (- count 1)))))
#+END_SRC

Testing

#+BEGIN_SRC racket
  <<def:fibI>>
  (fibI 0)
  (fibI 1)
  (fibI 2)
  (fibI 3)
  (fibI 4)
#+END_SRC

** 1.20

#+NAME: def:gcd
#+BEGIN_SRC racket
  (define (gcd a b)
    (if (= b 0)
	a
	(gcd b (remainder a b))))
#+END_SRC


(206 40)
(40 6)
(6 4)
(4 2)
(2 0)

The main operator of gcd is a conditional, and as described the condition of a conditional is
evaluated before either result is evaluated.
So, the remainder operations actually performed equal the number of times gcd is called, minus one.
For, on the last call (= b 0), which goes to a.

Or I'm missing something, but it seems the conditional must work in this way.
Normal order reduces everything to a primitive form.
But, with a recursive function like gcd a 'synthetic' primative form is needed.
For, otherwise, and additional call to gcd is always possible.

With all this in mind, given the flow is determined by a conditional, normal and evaluative order should be the same here.

** 1.21


A little before.
If d is a divisor of n, then so is n/d.
Proof for this seems easy by contradicition.
To show d divides n, just need an int such that d * a = n.
Consider n/d.
As d is a divisor of n, so n/d is an int, and clearly d * n/d = n.

#+NAME: def:divides?
#+BEGIN_SRC racket
  (define (divides? a b)
    (= (remainder b a) 0))
#+END_SRC

#+NAME: def:smallest-divisor
#+BEGIN_SRC racket
  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    <<def:divides?>>
    <<def:square>>
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (+ test-divisor 1)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:smallest-divisor>>
  (smallest-divisor 199)
  (smallest-divisor 1999)
  (smallest-divisor 19999)
#+END_SRC

? ? ? What is the purpose of this?

** 1.22

#+NAME: def:prime?
#+BEGIN_SRC racket
  (define (prime? n)
    <<def:smallest-divisor>>
    (= n (smallest-divisor n)))
#+END_SRC


#+NAME: def:search-for-primes
#+BEGIN_SRC racket
  (define (timed-prime-test n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    <<def:prime?>>
    (if (prime? n)
	(report-prime n (- (runtime) start-time))))

  (define (report-prime n elapsed-time)
    (newline)
    (display n)
    (display " *** ")
    (display elapsed-time))

  (define (prime-test-range-k-step n m k)
    (cond ((> n m)
	   (display " finished "))
	  (else
	   (timed-prime-test n)
	   (prime-test-range-k-step (+ n k) m k))))

  (define (search-for-primes n m)
    (prime-test-range-k-step (if (even? n) (+ n 1) n) (if (even? m) (- m 1) m) 2))
#+END_SRC

#+BEGIN_SRC racket
  <<def:search-for-primes>>
  (search-for-primes 1 100000)
#+END_SRC

Well, it takes a little longer, but things happen too fast to really test sqrt(n).
And, any significant deviation from average is probs. a scheduling thing.

** 1.23

#+BEGIN_SRC racket
(define (next n)
  (if (= n 2) 3 (+ n 2)))
#+END_SRC

#+BEGIN_SRC racket
(define (find-divisor-next n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor-next n (next test-divisor)))))
#+END_SRC

#+BEGIN_SRC racket
(define (smallest-divisor-next n)
  (find-divisor-next n 2))
#+END_SRC

#+BEGIN_SRC racket
(search-for-primes 1 100000)
#+END_SRC

The speed-up going to 100000 is significant.
Around 2~3 times as fast at the end tail.

** 1.24

#+BEGIN_SRC racket
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m)) m))
        (else
         (remainder (* base (expmod base (- exp 1) m)) m))))
#+END_SRC

#+BEGIN_SRC racket
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n ) a))
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC

#+BEGIN_SRC racket
(define (fast-prime? n times)
(cond ((= times 0) true)
      ((fermat-test n) (fast-prime? n (- times 1)))
      (else false)))
#+END_SRC

Again, timing isn't particularly easy here.
I'd expect 1,000,000 to not take too much more time than 1000, as we have Theta(long n) growth.

** 1.25

With expmod we have a way of figuring out the exponential of a number modulo another number (with Theta(log n) growth).
So, roughly remainder(base^exp / m).
The way this works is to figure out base^exp and then task the remainder at each call.
Difference is where remainder is called.
As given, we take remainder before squaring resut, in the even case.
So, this should make a differnece, at least in principle.
As, both remainder and square take time, and depending on the way things go, could lead to m long n growth.
But, presumably as the argument is kept small, this growth is 'hidden' behind the growth of the exponent.

As footnote 46 points out, the position of remainder ensures the numbers dealt with are not much larger than m.

By contrast, for the proposed expmod, we for sure need to consider the growth of remainder.
If it's n, then we have n + long n = n.

Though, I can't find much about the cost of remainder in the text.

** 1.26

With explicit multiplication, there are now two calls to expmod on each recursive call.
So, we've effectively doubled the amount of work. (log n)^2 = n.

With square, by contrast, the result of expmod is evaluated and then passed to the fuction.
The evaluated value is used twice, but the evaluation only happens once.

** 1.27

#+NAME: def:carmichael-fool
#+BEGIN_SRC racket
  (define (carmichael-fool n)
    (hidden-fool (- n 1) n))

  (define (hidden-fool b n)
    <<def:expItr>>
    (cond ((= b 0) (display " fooled "))
	  ((= (remainder (expItr b n) n) (remainder b n)) (hidden-fool (- b 1) n))
	  (else (display " found "))))
#+END_SRC


#+BEGIN_SRC racket
  <<def:carmichael-fool>>
  (carmichael-fool 561)
  (carmichael-fool 1105)
  (carmichael-fool 1729)
  (carmichael-fool 2465)
  (carmichael-fool 2821)
  (carmichael-fool 6601)
  (carmichael-fool 6600)
  (carmichael-fool 6602)
#+END_SRC

** 1.28

Modifying expmod to signal whether it discovers a non-trivial square root of 1.

An important detail was a little buried.
For, the test is only guaranteed for odd numbers.
So, when working through half of the numbers, we need to already be sure the number is odd.

Added some formatting, though ofc I should have a single call for n/prime display.

#+BEGIN_SRC racket
  (define (MR-expmod base exp m) ; base = a, exp = n
    <<def:square>>
    (cond ((= exp 0) 1)
	  ((even? exp)
	   (remainder (square (MR-check-sqaure (MR-expmod base (/ exp 2) m) m)) m))
	  (else (remainder (* base (MR-expmod base (- exp 1) m)) m))))

  (define (MR-check-sqaure a m)
    <<def:square>>
    (cond
      ((or (= a 1) (= a (- m 1))) a) ; In this case, a is trivial, so continue
      ((= (remainder (square a) m) 1) 0) ; We know a != 1 nor (m - 1), so check a % n = 1. Not prime if satisfied.
      (else a))) ; Otherwise, continue

  (define (MR-seq-test n a)
    (cond
      ((> a (/ n 2)) (display "Prime!\n"))
      ((= (MR-expmod a (- n 1) n) 0) (display "Not prime…\n"))
      (else (MR-seq-test n (+ a 1)))))


  (define (MR-prime? n)
    (display "Checking: ")
    (display n)
      (display "\n")
    (cond
      ((= n 2) (display "Prime!\n"))
      ((even? n) (display "Not prime…\n"))
      (else (MR-seq-test n 1))))

  (MR-prime? 2)
  (MR-prime? 3)
  (MR-prime? 4)
  (MR-prime? 7)
  (MR-prime? 9)
  (MR-prime? 10)
  (MR-prime? 11)
  (MR-prime? 12)
#+END_SRC

** 1.29

#+NAME: def:sum
#+BEGIN_SRC racket
  (define (sum term a next b)
    (if (> a b)
	0
	(+ (term a)
	   (sum term (next a) next b))))
#+END_SRC

#+NAME: def:inc
#+BEGIN_SRC racket
  (define (inc n) (+ n 1))
#+END_SRC

#+BEGIN_SRC racket
  (define (simpson f a b n)
    <<def:sum>>
    <<def:inc>>
    (define (sM k x)
      (cond
	((or (= k 0) (= k n)) x)
	((even? k) (* 2 x))
	(else (* 4 x))
	))
    (define (h) (/ (- b a) n))
    (define (fakh k) (sM k (f (+ a (* k (h))))))
    (* (/ (h) 3) (sum fakh 0 inc n)))

  <<def:cube>>

  (simpson cube 0 1 1000.0)
  (simpson cube 0 1 10000.0)
#+END_SRC

Well, the results are closer to 1/4…

** 1.30

#+NAME: def:sum-iter
#+BEGIN_SRC racket
  (define (sum-iter term a next b)
    (define (iter a result)
      (if (> a b)
	  result
	  (iter (next a) (+ (term a) result))))
    (iter a 0))
#+END_SRC

#+BEGIN_SRC racket
  <<def:sum-iter>>
  <<def:cube>>
  (sum-iter cube 0 inc 10)
#+END_SRC

** 1.31

*** a.

#+NAME: def:product
#+BEGIN_SRC racket
(define (product term a next b)
  (if (> a b)
      1
      (* (term a)
         (product term (next a) next b))))
#+END_SRC


This is just substituting * for +…
And factorial works with identiy and inc.

#+BEGIN_SRC racket
  (define (factorial n)
    <<def:product>>
    (product identity 1 inc n))
#+END_SRC


#+BEGIN_SRC racket
  (define (piHelpB d)
    <<def:square>>
    (/ (* (- d 1) (+ d 1)) (square d)))

  (define (incTwo n) (+ n 2))

  (define (piClose n)
    <<def:product>>
    (* 4.0 (product piHelpB 3 incTwo (+ n 3))))

  (piClose 500)
#+END_SRC

Use the numerator as the index, and work through pairs of denominators.

Either I've done something wrong, on this takes a lot to get close to pi.

*** b.

#+NAME: def:product-iter
#+BEGIN_SRC racket
(define (product-iter term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))
#+END_SRC

** 1.32



Made both versions, then read part b…

#+NAME: def:accumulate-first
#+BEGIN_SRC racket
(define (accumulate-first combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
         (accumulate-first combiner null-value term (next a) next b))))
#+END_SRC

#+NAME: def:accumulate-first-iter
#+BEGIN_SRC racket
  (define (accumulate-first-iter combiner null-value term a next b)
    (define (iter a result)
      (if (> a b)
	  result
	  (iter (next a) (combiner (term a) result))))
    (iter a null-value))
#+END_SRC


E.g.…

#+BEGIN_SRC racket
  (define (sum-accumulate-first term a next b)
    <<def:accumulate-first>>
    (accumulate-first + 0 term a next b))
#+END_SRC

To test, adapt previous use of sum/product.
Replace accumalate with accumalate-iter to vary recu/iter.

#+BEGIN_SRC racket
;; (sum-iter cube 0 inc 10)
;; (sum-accumulate-first cube 0 inc 10)
#+END_SRC

** 1.33

#+NAME: def:filtered-accumulate-first
#+BEGIN_SRC racket

(define (filtered-accumulate-first filter combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (if (filter a) (term a) null-value)
                (filtered-accumulate-first filter combiner null-value term (next a) next b))
      ))
#+END_SRC

If the filter is satisfied, then combine (term a), otherwise combine via the null-value.

*** a.

#+BEGIN_SRC racket
  (define (sum-square-prime a b)
    <<def:filtered-accumulate-first>>
    <<def:prime?>>
    (filtered-accumulate-first prime? + 0 square a inc b))

  (sum-square-prime 1 10)
#+END_SRC

*** b.

#+BEGIN_SRC racket
  (define (sum-relatively-prime n)
    <<def:filtered-accumulate-first>>
    (define (predicate? a)
      (= (gcd a n) 1))
    (filtered-accumulate-first predicate? * 0 identity 0 inc n))

  (sum-relatively-prime 20)
#+END_SRC

No test values for this, but at least here I have a nice example of blocking the predicate.

** 1.34

#+BEGIN_SRC racket
  (define (f g) (g 2))

  (f square)
  (f (lambda (z) (* z (+ z 1))))
#+END_SRC

We apply 2 to 2.
With f labelled
(f1 f2) - > (f2 2) -> (2 2)
But, 2 isn't a procedure.

** 1.35


From p. 38 we have the golden ratio is (1 + sqrt(5))/2.
Let φ = (1 + sqrt(5))/2.
And, we know φ^2 = φ + 1.

To figure out how to express φ as a fixed point of x, we'll work through x = φ until we have a non-trivial transformation of x on the rhs.
So:

#+BEGIN_SRC racket
  x = φ
  x^2 = φ^2 \ Algebra
  x^2 = φ + 1 \ Given
  x^2 = x + 1 \ Initial equality.
  x = (x + 1)/x \ Algebra
  x = (x/x + 1/x) \ Algebra
  x = (1 + 1/x) \ Algebra
#+END_SRC

#+NAME: def:fixed-point
#+BEGIN_SRC racket
  (define (fixed-point f first-guess tolerance)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
    (try first-guess))
#+END_SRC

#+BEGIN_SRC racket
  <<def:fixed-point>>
  (display "φ is roughly: ")
  (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0 0.0000001)
#+END_SRC

** 1.36

#+BEGIN_SRC racket
(define (fixed-point-display f first-guess tolerance)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess guess-number)
    (let ((next (f guess)))
      (display "Guess: ")
      (display guess-number)
      (display " is: ")
      (display guess)
      (newline)
      (if (close-enough? guess next)
          next
          (try next (+ guess-number 1)))))
  (try first-guess 1))

(fixed-point-display (lambda (x) (/ (log 1000) (log x))) 20 0.0001)
#+END_SRC

** 1.37

*** a.

#+NAME: def:cont-frac
#+BEGIN_SRC racket
  (define (cont-frac n d k)
    (define (cont-frac-i n d k step)
      (if (= step k)
	  (/ (n step) (d step))
	  (/ (n step) (+ (d step) (cont-frac-i n d k (+ step 1))))))
    (cont-frac-i n d k 1))
#+END_SRC

#+BEGIN_SRC racket
  <<def:cont-frac>>
  (cont-frac (lambda (i) 1.0)
	     (lambda (i) 1.0)
	     11)
#+END_SRC

Looks as though k = 11 works for 4 decimal places.
1/φ = 0.6180339887498948482045868343656381177203091798057628621354486227…

*** b.

cont-frac is recursive, so for an iterative version…
Start the other way.
Do N_k/D_k and then work backwards.

#+BEGIN_SRC racket
(define (cont-frac-iter n d k)
  (define (cont-frac-i n d k so-far)
    (if (= k 0)
        so-far
        (cont-frac-i n d (- k 1) (/ (n k) (+ (d k) so-far)))))
  (cont-frac-i n d k 0))

(cont-frac-iter (lambda (i) 1.0)
                (lambda (i) 1.0)
                11)
#+END_SRC

** 1.38

There's nothing here other than figuring out a way to generate the desired sequence for Dk.
So, here's something excessive.

#+BEGIN_SRC racket
  <<def:cont-frac>>
  (define (dk i)
    (let ((x (- i (/ i 3))))
      (if (= (- x (floor x)) (/ 1 3))
	  (ceiling x)
	  1)))

  (+ 2 (cont-frac (lambda (x) 1.0) dk 200))
#+END_SRC

e = 2.7182818284590452353602874713526624977572470936999595749669676277…

** 1.39


Modify cont-frac.
n is constant x^2.
d is number variable, given as argument.
And, offset things a little.

At start, calculate x^2 to save some resources.
Then, work through offset cont-frac k times.

#+BEGIN_SRC racket
  (define (tan-cf x k)
    <<def:square>>
    (define (cont-frac-i x2 d k step)
      (if (= step k)
	  (/ x2 d)
	  (/ x2 (- d (cont-frac-i x2 (+ d 2) k (+ step 1))))))
      (let ((x2 (square x)))
	(/ x (- 1 (cont-frac-i x2 3 k 1)))))

    (tan-cf 1.0 10.0)
#+END_SRC

** 1.40

#+NAME: def:deriv
#+BEGIN_SRC racket
(define (deriv g)
  (let ((dx 0.00001))
    (lambda (x)
           (/ (- (g (+ x dx)) (g x))
              dx))))
#+END_SRC

#+NAME: def:newton-transform
#+BEGIN_SRC racket
  (define (newton-transform g)
    <<def:deriv>>
    (lambda (x) (- x (/ (g x) ((deriv g) x)))))
#+END_SRC

#+BEGIN_SRC racket
  (define (newtons-method g guess)
    <<def:newton-transform>>
    <<def:fixed-point>>
    (fixed-point (newton-transform g) guess 0.0000001))
#+END_SRC

#+BEGIN_SRC racket
  (define (cubic a b c)
    (define (cubic-all x a b c)
      <<def:square>>
      <<def:cube>>
      (+ (cube x) (* a (square x)) (* b x) c))
    (lambda (x) (cubic-all x a b c)))
  ;; (lambda (x)
  ;;   (+ (cube x) (* a (square x)) (* b x) c)
  ;;   ))
#+END_SRC

Here, just constructing a function.
There's two options.
First (as taken), define the general function, and then obtain a particular instance.
Second, directly define a particular instance (as commented).

** 1.41

#+BEGIN_SRC racket
(define (double f) (lambda (x) (f (f x))))

((double inc) 2)
(((double (double double)) inc) 5)
#+END_SRC

** 1.42

#+BEGIN_SRC racket
(define (compose f g) (lambda (x) (f (g x))))

((compose square inc) 6)
#+END_SRC

** 1.43

#+BEGIN_SRC racket
(define (repeated f times)
    (if (= times 1)
        f
        (compose f (repeated f (- times 1)))))

((repeated square 2) 5)
#+END_SRC

This is a little surprising.
For, the most natural base case is f x.
With this, completing recursive calls gets f^n x.
And, as a last step take λ x f^n x, or just leave the procedure as it is.

But, this isn't okay, as x dones't evaluate to anything.

So, instead, the base case is f.
The argument is not made explicit, so there's no issue of evaluting it.
We just return the procedure.

So, mabye it's not *that* strange.
With f x we are working with some arbitrary value, and as this is arbitrary, what we're doing is transformed into a procedure.
And, with f we are working with a procedure directly.

Hm.

** 1.44

#+BEGIN_SRC racket
(define (smoothed f dx)
  (lambda (x)
    (/ (+ (f x) (f (+ x dx)) (f (- x dx))) 3)))


(define (smooth-fold f dx n)
  ((repeated (lambda (x) (smoothed x dx)) n) f))
#+END_SRC


Nothing too exciting here.
We repeat the smoothing, and then apply this to the function.
(Repeating smoothing applied to the function would involve repeating the function.)
lambda lets us do this easily, though I guess it would also be easy if dx was fixed as a constant somewhere.

** 1.45

Average-damp(f(x)) = (x + f(x))/2

e.g. Average-damp(10^2) = 55 = (10 + 100)/2

In general, fixed point fails without dampening as y -> x/y -> x/(x/y) -> y
Then, y -> (x + x/y)/2.

In any case, this exercise seems rough.
We're asked to experiment to find out how many average damps are required to compute nth roots as a fixed-point search.
The problem is failure to converge, though.
Of course, things are a little better.
For, the general form of the problem is re-obtaining the initial value, or at least a prior value.
So, it's in principle possible to store every value computed and then check to see if any of these are repeated.
Still, it's not very interesting.

The final function isn't too interesting either.
Once the required number of times to average damp is figured out, the next task is to repeatedly average damp the function, and then apply the fixed point solver to this.

** 1.46

In outline, a conditional:

if (good? guess) guess (improve guess)

So, here, the only issue is obtaining the guess.
But, this is two lambda terms.
lambda f lambda x (f x)

#+NAME: def:iterative-improve
#+BEGIN_SRC racket
(define (iterative-improve good? improve)
  (lambda (guess) (if (good? guess)
      guess
      ((iterative-improve good? improve) (improve guess)))))
#+END_SRC

To help make things clear, a couple of let statements to define the relevant procedures.
Then, call iterative-improve.
Here, 1 could be anything – it's just a first guess.

#+NAME: def:iiSqrt
#+BEGIN_SRC racket
  (define (iiSqrt x)
    <<def:square>>
    <<def:average>>
    <<def:iterative-improve>>
    (let (
	  (good? (lambda (guess) (< (abs (- (square guess) x)) 0.001)))
	  (improve (lambda (guess) (average guess (/ x guess)))))
      ((iterative-improve good? improve) 1)))
#+END_SRC

Some tests

#+BEGIN_SRC racket
  <<def:iiSqrt>>
  (iiSqrt 4.0)
  (iiSqrt 16.0)
  (iiSqrt 125.0)
#+END_SRC

#+NAME: def:iiFixed-Point
#+BEGIN_SRC racket
  (define (iiFixed-Point f)
    <<def:iterative-improve>>
    (let ((good? (lambda (guess) (< (abs (- (f guess) guess)) 0.00001)))
	  (improve (lambda (guess) (f guess))))
      ((iterative-improve good? improve) 1)))
#+END_SRC

A couple of funcs from 1.3.3 (p. 69) for testing

#+BEGIN_SRC racket
  <<def:iiFixed-Point>>
  (iiFixed-Point cos)
  (iiFixed-Point (lambda (y) (+ (sin y) (cos y))))
#+END_SRC


* Chapter 2

** 2.1

#+NAME: def:numer
#+BEGIN_SRC racket
    (define (numer x) (car x))
#+END_SRC

#+NAME: def:demon
#+BEGIN_SRC racket
  (define (demon x) (cdr x))
#+END_SRC

Not particularly elegant.
Though, cheeky λ to avoid calculating (* n d) twice.
Note, doing (define (mult) (* n d)) wouldn't be any help, as this would just call the multiplcation.

#+NAME: def:make-rat-basic
#+BEGIN_SRC racket
  (define (make-rat-basic n d)
    (let ((sign  ((lambda (x) (/ x (abs x))) (* n d))))
      (cons (* sign (abs n)) (abs d))))
#+END_SRC

It's not possible to always reference a let constant from another let constant.
This kind of makes sense to me.
At some point, need to make the reference happen.
This way, reference isn't assumed to be sequential, nor does one need to track dependencies.


#+BEGIN_SRC racket
(define (make-rat-basic-x n d)
  (let ((mult (* n d))
        (sign (/ mult (abs mult))))
    (cons (* sign (abs n)) (abs d))))
#+END_SRC

make-rat as defined in the book already does this.
But, it's due to a bug in gcd.
For, gcd(2, -3) = 1.
Yet, (gcd 2 -3) = -1.
And, in general, given (gcd a b), if a is positive and b is negative, then the result is negative.
Otherwise, the result has the sign of a.

#+NAME: def:make-rat
#+BEGIN_SRC racket
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
#+END_SRC

In the book, newline is first, but newline last fits with previous displays.

#+NAME: def:print-rat
#+BEGIN_SRC racket
  (define (print-rat x)
    <<def:numer>>
    <<def:demon>>
    (display (numer x))
    (display "/")
    (display (demon x))
    (newline))
#+END_SRC

#+BEGIN_SRC racket
  <<def:print-rat>>
  <<def:make-rat-basic>>
  <<def:make-rat>>

  (print-rat (make-rat-basic -2 -3))
  (print-rat (make-rat-basic -2 3))
  (print-rat (make-rat-basic 2 3))
  (print-rat (make-rat-basic -2 3))

  (print-rat (make-rat -2 -3))
  (print-rat (make-rat 2 -3))
  (print-rat (make-rat 2 3))
  (print-rat (make-rat -2 3))
#+END_SRC

** 2.2

#+NAME: sc:point
#+BEGIN_SRC racket
  (define (make-point x y) (cons x y))

  (define (x-point point) (car point))

  (define (y-point point) (cdr point))
#+END_SRC

#+BEGIN_SRC racket
  <<sc:point>>
  (x-point (make-point 1 2))
  (y-point (make-point 1 2))
#+END_SRC

#+NAME: sc:segment
#+BEGIN_SRC racket
  <<sc:point>>
  (define (make-segment start-point end-point) (cons start-point end-point))

  (define (start-segment segment) (car segment))

  (define (end-segment segment) (cdr segment))

  (define (midpoint-segment segment)
    (make-segment
     (/ (+ (x-point (start-segment segment)) (x-point (end-segment segment))) 2)
     (/ (+ (y-point (start-segment segment)) (y-point (end-segment segment))) 2)))
#+END_SRC

#+BEGIN_SRC racket
  <<sc:segment>>
  (midpoint-segment (make-segment (make-point 2 2) (make-point 4 4)))
  (midpoint-segment (make-segment (make-point -4 -8) (make-point 4 4)))
#+END_SRC

Though, I think this should be a little more general.
With a coordinate space, there's no limit on the dimension.
So, rather than having distinct x and y selectors, there should be a general selection which takes the dimension as an argument.
Then, it's easy to expand everything, given some way to test wether the dimension is stored.
Though, at this point in the book the problem is lists.
We only have pairs.

** 2.3

For a rectangle, there's a few ways to do this.
Though, point for origin and rationals for legnth and width seems most straightforward.

A rectange is stored as ((origin-x origin-y) (width height))

#+NAME: sc:rectangle
#+BEGIN_SRC racket
(define (make-rectangle origin width height)
  (cons origin (cons width height)))

(define (rectangle-origin rectangle)
  (car rectangle))

(define (rectangle-width rectangle)
  (car (cdr rectangle)))

(define (rectangle-height rectangle)
  (cdr (cdr rectangle)))
#+END_SRC


Not sure what is meant by perimeter here.
Length of the perimeter is… not very interesting.
Points to construct the perimeter is a little better.
So, that's what the following procedure does.
Points are enumerated clockwise starting with 1 as top-left going to 3 as bottom-left.

#+NAME: def-rectangle-perimeter
#+BEGIN_SRC racket
  (define (rectangle-perimeter rectangle point)
    <<sc:rectangle>>
    <<sc:point>>
    (if (= point 0)
	(rectangle-origin rectangle)
	(let ((xPoint (x-point (rectangle-origin rectangle)))
	      (yPoint (y-point (rectangle-origin rectangle))))
	  (cond
	    ((= point 1) (make-point (+ xPoint (rectangle-width rectangle)) yPoint))
	    ((= point 2) (make-point (+ xPoint (rectangle-width rectangle)) (+ yPoint (rectangle-height rectangle))))
	    ((= point 3) (make-point xPoint (+ yPoint (rectangle-height rectangle))))))))
#+END_SRC

#+BEGIN_SRC racket
  (define (rectangle-area rectangle)
    <<sc:rectangle>>
    (* (rectangle-width rectangle) (rectangle-height rectangle)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:rectangle-perimeter>>
  (define test-rect (make-rectangle (make-point 5 10) 15 10))
  (rectangle-origin test-rect)
  (rectangle-width test-rect)
  (rectangle-height test-rect)
  (rectangle-perimeter test-rect 2)
#+END_SRC

The representation of the rectangle doesn't matter, so long as there's selectors for origin, width, and height.

And, I can't think of an interesting alterantive representation.
Could take the center point.
The only thing here is origin is given by center.x - width/2, etc.

Could also take two points.
Say, top left and bottom right.
Then, origin is top left, and width is obtained from top right.x - bottom left.x in the positive case.

** 2.4

(car (cons x y)) = λm (m x y) (λ (p q) p)
                 = (λ (p q) p) x y
                 = x

for cdr

(define (cdr z)
(z (lambda (p q) q)))

So:

(cdr (cons x y)) = λm (m x y) (λ (p q) p)
                 = (λ (p q) q) x y
                 = y

** 2.5

To pair the numbers use any exponentiation procedure which takes base and exponent arguments.

To break apart the number, keep dividing by either 2 or 3 until no further integer division is possible.

I'd guess there's some trick with log here, but I don't see it quickly.

#+BEGIN_SRC racket
  (define (break-down pair n)
    (define (break-down-i pair n m)
      (if (not (= 0 (remainder pair n)))
	  m
	  (break-down-i (/ pair n) n (+ m 1))))
    (break-down-i pair n 0))

  (define (pair-numbers a b)
    <<def:expItr>>
    (* (expItr 2 a) (expItr 3 b)))

  (define (pair-number-a pair) (break-down pair 2))
  (define (pair-number-b pair) (break-down pair 3))

  ; Basic test
  (pair-number-a (pair-numbers 32 94))
  (pair-number-b (pair-numbers 32 94))

  ; Some edge cases.
  (pair-number-a (pair-numbers 1 1))
  (pair-number-b (pair-numbers 1 0))
#+END_SRC

Note, only asked to do with for non-negative integers.

** 2.6

So…

0 = λf λx x
1 = λf λx f x
2 = λf λx ff x

(define one (lambda (f) (lambda (x) (f (x)))))
(define two (lambda (f) (lambda (x) (f (f (x))))))

Okay, not allowed to apply repeat to add-1.

Still, this is just a variation on add-1.

(define (add n m)
(lambda (f) (lambda (x) (f (n f) ((m f) x)))))

Instead of x, we have ((m f) x).
m is of the form λf λx f^m x.
So, ((m f) x) is of the form f^m x.
n is of the form λf λx f^n x
So, (n f) is of the form λx f^m x.
Hence, (f (n f) ((m f) x)) reduces to f^n (f^m x).
And, this is what we want. f applied n + m times.

** 2.1.4 Extended exercise

Why not do intervals by a precise quantity tolerance pair?
At least in the case of resistors, where things are specified this way?

Though, I can see in general specifying lower and upper bounds is easier.
Unless, upper + lower / 2.
This gets 'precise quantity'.
Then, upper - mid.
This gets half width.
So, either way seems fine.

*** 2.7

#+NAME: sc-interval
#+BEGIN_SRC racket
(define (make-interval a b) (cons a b))
(define (lower-bound i) (car i))
(define (upper-bound i) (cdr i))
#+END_SRC

So, this is as specified, but why rely on the user to fix the correct upper and lower bounds?

*** 2.8

So, add-interval reduces to addition on the upper and lower bounds.
In this way, sub-interval will do the same.
Though, add a check to ensure upper is upper and lower is lower.

#+NAME: def-add-interval
#+BEGIN_SRC racket
  (define (add-interval x y)
    <<sc:interval>>
    (make-interval (+ (lower-bound x) (lower-bound y))
		   (+ (upper-bound x) (upper-bound y))))
#+END_SRC

#+NAME: def:sub-interval
#+BEGIN_SRC racket
  (define (sub-interval x y)
    <<sc:interval>>
    (let (
	  (lIS (- (lower-bound x) (lower-bound y)))
	  (hIS (- (upper-bound x) (upper-bound y))))
      (if (> hIS lIS)
	  (make-interval hIS lIS)
	  (make-interval lIS hIS))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:add-interval>>
  <<def:sub-interval>>
  (add-interval (make-interval 0 1) (make-interval 9 10))
  (sub-interval (make-interval 0 2) (make-interval 9 10))
#+END_SRC

In the same way adding increases margin, subtancting decreases margin.
I feel this isn't quite right.
Instead, go with proposal above and take an procedure for combining two tolerances.

*** 2.9

#+BEGIN_SRC racket
  (define (interval-width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))
#+END_SRC

In the case of addition.
x.w + y.w = (x.u - x.l)/2 + (y.u - y.l)/2
          = ((x.u - x.l) + (y.u - y.l))/2
          = ((x.u + y.u) + (x.l - y.l))/2
          = (x + y).w

The reasoning is the same for subtraction.

For multiplication, consider some intervals using 0 and 1.
(1 0) * (1 0) = (0 0)
And, we have (1 0).w = 0.5, while (0 0).w = 0.
In contrast:
(1 1) * (1 1) = (1 1)
And, we have (1 1).w = 0.5

Division is… defined in terms of multiplication as the main operator.
This isn't a proof, but suggests similar problems.

*** 2.10

'spans 0' means 'has width 0'?
I mean, and interval crossing over 0 should be no problem.
Anyway, mul-interval written so variant of div-interval doesn't prevent anything else running.

#+BEGIN_SRC racket
  (define (mul-interval x y)
    (let (
	  (p1 (* (lower-bound x) (lower-bound y)))
	  (p2 (* (lower-bound x) (upper-bound y)))
	  (p3 (* (upper-bound x) (lower-bound y)))
	  (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
		     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (if (= 0 (interval-width y))
	(error)
	(mul-interval x
		      (make-interval (/ 1.0 (upper-bound y))
				     (/ 1.0 (lower-bound y))))))
#+END_SRC

*** 2.11

I'm not quite seeing the point of this exercise.
In any case, we can write out a table of all the possible positive/negative combinations.
Then, we can work out whether there's a guaranteed value for the upper and lower bounds.
With perhaps some errors, I have this:

| u_x | u_y | l_x | l_y | ub | lb |
| +   | +   | +   | +   | P4 | P1 |
| +   | +   | +   | -   | P4 | P3 |
| +   | +   | -   | +   | P4 | P2 |
| +   | +   | -   | -   |    |    |
| +   | -   | +   | +   | P3 | P4 |
| +   | -   | +   | -   | P2 | P3 |
| +   | -   | -   | +   |    |    |
| +   | -   | -   | -   | P1 | P3 |
| -   | +   | +   | +   | P2 | P3 |
| -   | +   | +   | -   |    |    |
| -   | +   | -   | +   | P1 | P4 |
| -   | +   | -   | -   | P1 | P2 |
| -   | -   | +   | +   |    |    |
| -   | -   | +   | -   | P3 | P1 |
| -   | -   | -   | +   | P4 | P1 |
| -   | -   | -   | -   | P1 | P4 |

Where:

| P1 | l_x | l_y |
| P2 | l_x | u_y |
| P3 | u_x | l_y |
| P4 | u_x | u_y |

Here, then, there's the 'else' case, which covers the four instances where we need to calculate more than two combinations.
In all the other cases, we need to calculate the listed two cases.

But, I guess I've got this a little wrong.
For, we can break this down into sets of calculations.
I.e. { P1, P4 } covers both the last and the first case.
Then, for the upper and lower bound we only need to figure out which is larger than the other.
This is still only two instances of multiplications.

But, on my count there are six distinct sets.
So, this means we only need to consider seven cases.

I guess I'm missing something here…

Ah, I guess I'm this potential user, huh.

*** 2.12

#+BEGIN_SRC racket
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))

  (define (make-center-percent c p)
    (let ((nudge (* (abs c) p)))
      (make-interval (- c nudge) (+ c nudge))))

  (define (i-center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
#+END_SRC

This isn't super precise with small percentages.
But, there's no way around this without changing the bound constructor.
As, imprecision has already entered by multiplying the center by the percentage to get the bounds.

#+BEGIN_SRC racket
(define (i-percent i)
  (- (/ (upper-bound i) (i-center i)) 1))
#+END_SRC

#+BEGIN_SRC racket
(i-center (make-center-percent 10 0.001))
(i-percent (make-center-percent 10 1.01))
#+END_SRC

*** 2.13

Assuming small percentage tolerances and all numbers are positive.

Formula for the approximate percentage tolerance of the product of two intervals
in terms of the tolerances of the factors.

So, for the product we take min/max of different upper/lower x/y combinations.
In general, then, product is of the form:

(x ± t_x) * (y ± t_y) = (xy ± yt_x ± xt_y ± t_xt_y)

Hm, well, to find the tolerance pertentage, divide upper by center then subtract 1.
Ignoring the part where we substract one, we have:
u / ((u + l) / 2) = 2u/(u * l)

If assuming everything is positive, then upper and lower bounds are direct.

So, we have

2(ux + tx)(uy + ty) / ((ux + tx)(uy + ty) + (lx + tx)(ly + ty))

Where tx is really uxtx, etc.
That is, ux + tx = ux(1 + tx).

Different way of looking at things.
If we start by keeping tolerance in play, then the upper bound for x, with tolerance is u_x(1 * tx).
So, then, the upper bound for product, with tolerance is
u_x * u_y * (1 * tx) * (1 * ty)
So, then, (1 * tx) * (1 * ty) = 1 + tx + ty + txty.
In this case, then, why not take the tolerance as tx + ty + txty?
This seems sufficiently simple, but gives the exactl tolerance…
Of course, tx + ty should get quite close when tx and ty are very small, as txty is going to be very very small.

#+BEGIN_SRC racket
(define (quick-mul-tolerance i1 i2) (+ (i-percent i1) (i-percent i2)))
#+END_SRC

This looks good to me…

#+BEGIN_SRC racket
(quick-mul-tolerance (make-center-percent 10 0.001) (make-center-percent 10 0.006))
(i-percent (mul-interval (make-center-percent 10 0.001) (make-center-percent 10 0.006)))
#+END_SRC

*** 2.14

#+BEGIN_SRC racket
  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
		  (add-interval r1 r2)))

  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval one
		    (add-interval (div-interval one r1)
				  (div-interval one r2)))))

  (define ti1 (make-center-width 2 0.01))
  (define ti2 (make-center-width 2 0.001))
  (define ti3 (make-center-width 4 0.001))

  ;; Two intervals are equal just in case they have the same upper and lower bounds.
  (define (i-equal i1 i2)
    (and (= (upper-bound i1) (upper-bound i2)) (= (lower-bound i1) (lower-bound i2))))

  (par1 ti1 ti2)
  (par2 ti1 ti2)
  (i-equal (par1 ti1 ti2) (par2 ti1 ti2))

  (i-percent (par1 ti1 ti2))
  (i-percent (par2 ti1 ti2))
#+END_SRC

*** 2.15

So, as intervals are just upper and lower bounds, the tolerance percentage is implicit.

When adding, everything should be preserved.
For, we sum the lower and upper bounds.
So, the center point of the new point is just the sum of the center points of the initial points.

Similar for subtraction.

In this sense, Eva Lu Ator isn't quite right.
The operations performed are important, not just the way the interval is written.

Things are different in the case of product and division, though.
Here we multiply bounds, and hence multiply tolerance.
As seen earlier, we get (1 * tx) * (1 * ty) = 1 + tx + ty + txty.

par2 has one less instance of multiplication than par1.
And, as x * y > x + y, at least when everything is positive, at least some of the additional tolerance from product is going to be preserved.

Going to need to define "better", tho.
It's not clear tolerance as given really reflects anything under these transformations.

*** 2.16

Well, par1 and par2 are the same when i1 and i2 are rational numbers, at least.
So, when addition, multiplication, etc. satisfy certain properties.
It's not clear these same properties are satisfied when working with intervals.

The answer here really depends on what is allowed with the package.
If mul and div are fixed, there's no way out.
Equivalent expressions using rationals won't translate to intervals.
Assuming, that is, something is different.

But really, the issue is this.
Resistor values are only know up to some tolerance.
These formulas are defined with respect to resistor values without accounting for tolerance.
It's a mistake to think operations on fixed values apply equally to intervals or whatever.

** 2.17

#+BEGIN_SRC racket
(define (last-pair l)
  (define (last-pear l e)
    (if (null? l)
        e
        (last-pear (cdr l) (car l))))
      (last-pear l nil))

(last-pair (list 23 72 149 34))
(last-pair (list 23 72 149))
(last-pair (list ))
#+END_SRC

** 2.18

See reverse as a special case of appending in reverse.
Then, reverse is just this with an empty list.

#+NAME: def-reverse
#+BEGIN_SRC racket
  (define (reverse l)
    (define (mirror-onto l1 l2)
      (if (null? l1)
	  l2
	  (mirror-onto (cdr l1) (cons (car l1) l2))))
    (mirror-onto l nil))
#+END_SRC

#+BEGIN_SRC racket
<<def:reverse>>
(reverse (list 23 72 149 34))
#+END_SRC

With lists like this, there's a tradeoff between easy read and easy write.
And, as set up, it's easy read.
For, it's easy to go from the right element to the last.
It's not easy write, though, as you need to traverse through every element until you get to the end.

Though, you'd expect this to be the case in general.
We need to keep track of things, and the easy-write probably changes more than the easy to read thing.

** 2.19

#+NAME: coin-lists
#+BEGIN_SRC racket
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))
#+END_SRC

#+NAME: def-cc-list
#+BEGIN_SRC racket
  (define (first-denomination coin-list) (car coin-list))
  (define (except-first-denomination coin-list) (cdr coin-list))
  (define (no-more? coin-list) (null? coin-list))

  (define (cc-list amount coin-values)
    (cond ((= amount 0) 1)
	  ((or (< amount 0) (no-more? coin-values)) 0)
	  (else
	   (+ (cc-list amount
		       (except-first-denomination coin-values))
	      (cc-list (- amount
			  (first-denomination coin-values)) coin-values)))))
#+END_SRC


#+BEGIN_SRC racket
  <<coin-lists>>
  <<def:cc-list>>
  (cc-list 100 us-coins)
  (cc-list 100 (reverse us-coins))
#+END_SRC

The order of the coin list doesn't matter.
For, we always try to make the value using with and without the current 'first' coin.
So, if, say, 50 is up first, the first call will split into using 50 and ignoring 50.
While, if 50 is up somewhere in the middle, this split will happen multiple times, according to the splits that have already happened.

** 2.20

#+NAME: def-same-parity
#+BEGIN_SRC racket
(define (same-parity e . l)
  (define (parity-list ie il)
    (if (null? il)
        nil
        (let ((eParity (remainder ie 2))
              (newElem (car il)))
          (if (= (remainder newElem 2) eParity)
            (cons newElem (parity-list ie (cdr il)))
            (parity-list ie (cdr il))))))
  (cons e (parity-list e l)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:same-parity>>
  (same-parity 1 2 3 4 5 6 7)
  (same-parity 2 3 4 5 6 7)
  (same-parity -2 3 4 5 -6 7)
#+END_SRC

I understand this way of writing procedures is useful.
Still, the application here seems strange.
same-parity feels like a regular procedure, which  takes some int and a list as an argument and returns a list.
Though, maybe I could think about this from a difference perspective.
At issue is the list is not explicit, but the same is true of +.
And in some sense the list is explicit, it's just that the first element is a procedure to apply.
And, kind of everything is a list in this way.
So, there's no need to make a list which contains a procedure and a list when we can just extend the list we'd be adding with the procedure.
Ok.

** 2.21

#+NAME: def:my-map
#+BEGIN_SRC racket
  (define (my-map proc items)
    (if (null? items)
	nil
	(cons (proc (car items))
	      (my-map proc (cdr items)))))
#+END_SRC

#+NAME: def:square-list-full
#+BEGIN_SRC racket
  (define (square-list-full items)
    (if (null? items)
	nil
	(cons (* (car items) (car items)) (square-list-full (cdr items)))))
#+END_SRC

#+NAME: def:square-list-my-map
#+BEGIN_SRC racket
  (define (square-list-my-map items)
    <<def:my-map>>
    (my-map (lambda (x) (* x x)) items))
#+END_SRC

#+BEGIN_SRC racket
  (define testSqList (list 1 2 3 4))

  <<def:square-list-full>>
  <<def:square-list-my-map>>

  (square-list-full testSqList)
  (square-list-my-map testSqList)
#+END_SRC

Yes, could have used (square x) in both, and yes in full this makes a difference as (car items) is only done once.

** 2.22

So, we've got an inner iterative function.
Takes as argument a in-list and out-list
Idea is to transfer in-list to out-list.
But, lists  work in a specific order.
We have (element rest of list)
So, we read from a list top to bottom.
But, built a list bottom to top.
In this respect, Louis' 'top' element from in-list is added as the 'bottom' element of out-list.

In the second case we're not building a list.

** 2.23

#+NAME: def-for-each
#+BEGIN_SRC racket
(define (for-each proc l)
  (cond ((null? (cdr l)) (proc (car l)))
        (else
         (proc (car l)) (for-each proc (cdr l)))))
#+END_SRC

Ideally I'd use a pass procedure on the null? test here.
Then, we could check if the argument is nil, rather than looking a step ahead.

#+BEGIN_SRC racket
  <<def:for-each>>
  (for-each (lambda (x) (display x) (newline))(list 57 321 88))
#+END_SRC

Switched (newline) to second, to keep display style.

As an aside, search seems difficult with lists.
Efficient search, that is.
For, it's easy to work through a list and check for equality.
But, it's hard to do a standard recurse onto sub-lists, as there's no quick way to make a sub-list.
That is, with this abstraction.
Though, moving to pointers things are very easy, especially if the length of the list is stored.

** 2.24

#+BEGIN_SRC racket
(list 1 (list 2 (list 3 4)))
#+END_SRC

This is basically a tree which immediately terminates when branching to the left.

** 2.25

#+BEGIN_SRC racket
(car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9))))))
(car (car (list (list 7))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))))
#+END_SRC

This last one is interesting.
(1 (2 …))
If do cdr then get (2 …).
Now, this is not simply a list with 2 as the first element.
For, then the initial argument would be (1 2 …)
So, we have a list with (2 …) as the first element.

** 2.26

#+NAME: def-append
#+BEGIN_SRC racket
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:append>>
  (define lx (list 1 2 3))
  (define ly (list 4 5 6))

  (append lx ly) ; A list of 1 2 3 4 5 6
  (cons lx ly) ; A list of (list of 1 2 3) 4 5 6
  (list lx ly) ; A list of (list of 1 2 3) (list of 4 5 6)
#+END_SRC

** 2.27

#+BEGIN_SRC racket
  (define (reverse l)
    (define (mirror-onto l1 l2)
      (if (null? l1)
	  l2
	  (mirror-onto (cdr l1) (cons (car l1) l2))))
    (mirror-onto l nil))

  (reverse (list 23 72 149 34))
#+END_SRC

#+BEGIN_SRC racket
(define (deep-reverse l)
  (define (mirror-onto l1 l2)
    (if (null? l1)
        l2
        (mirror-onto (cdr l1) (cons (deep-reverse (car l1)) l2))))
  (if (pair? l)
      (mirror-onto l nil)
      l))

(define lx2 (list (list 1 2) (list 3 4)))
(define lx22 (list 2 (list (list 1 2) (list 3 4)) (list (list 1 2) (list 3 4 5))))
lx2

(deep-reverse 3)
(deep-reverse (list 1 2))
(deep-reverse lx2)
(deep-reverse lx22)
#+END_SRC

** 2.28

#+NAME: def-fringe
#+BEGIN_SRC racket
  (define (fringe tree)
    (cond ((and (not (pair? tree)) (not (null? tree))) (list tree))
	  ((not (pair? tree)) nil)
	  (else
	   (append (fringe (car tree)) (fringe (cdr tree))))))
#+END_SRC

#+BEGIN_SRC racket
  (define (fringe tree)
    (cond ((null? tree) nil)
	  ((not (pair? tree)) (list tree))
	  (else
	   (append (fringe (car tree)) (fringe (cdr tree))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:fringe>>
  (define tx (list (list 1 2) (list 3 4)))
  (define tx2 (list (list (list 1 2) (list 4)) (list (list 1 2) (list 3 4))))
  (define tx3 (list (list 3 (list 1 2) (list 4)) (list (list 1 2) (list 3 4))))
  (fringe tx3)
  (fringe (list tx tx))
#+END_SRC

It's simply to test to see if we have a leaf.
Though, there's an issue of nil, which always ends a list, so is always an implicit leaf, so to speak.
So, we traverse left and then right.
There are two base cases.
First, not pair and a non-nil.
In this case, a leaf.
Second, as the first condition failed, it's either an branch or nil.
If not branch, then for sure nil.

Building up, we append lists.

As an aside, append here is key to ensure we flatter everything, rather than repeating the strcture of the tree.
Setting aside scaling, this is the only difference between scale-tree and fringe, along with making sure the base case returns a list so append always works.

Un-named version is a rewrite with hindsignt.
Base case conditions are in line with scale-tree

** 2.29

#+NAME: sc:mobile
#+BEGIN_SRC racket
  (define (make-mobile left right) (list left right))

  (define (make-branch length structure) (list length structure))

  (define (left-branch mobile) (car mobile))

  (define (right-branch mobile) (car (cdr mobile)))

  (define (branch-length branch) (car branch))

  (define (branch-structure branch) (car (cdr branch)))
#+END_SRC

I guess there's a better way of doing this.
As, sum-up here is just +, but applied to a list.
(cons + list) doesn't work, though.

#+NAME: def:sum-up
#+BEGIN_SRC racket
  (define (sum-up list)
    (if (null? list)
	0
	(+ (car list) (sum-up (cdr list)))))
#+END_SRC

To test whether we're going to a mobile from another mobile,
we look at the right element.
If this is a pair, then we've got another mobile.
Else, it's an int representing some weight.

#+NAME: sc:mobile-more
#+BEGIN_SRC racket
  <<sc:mobile>>
  (define (to-mobile? branch)
    (pair? (branch-structure branch)))

  (define (get-weight branch)
    (branch-structure branch))

  (define (total-weight mobile)
    (let ((twL (if (to-mobile? (left-branch mobile)) (total-weight (branch-structure (left-branch mobile))) (get-weight (left-branch mobile))))
	  (twR (if (to-mobile? (right-branch mobile)) (total-weight (branch-structure (right-branch mobile))) (get-weight (right-branch mobile)))))
      (+ twL twR)))
#+END_SRC

#+NAME: consts:m1-m2
#+BEGIN_SRC racket
  <<sc:mobile-more>>
  (define lb1 (make-branch 1 10))
  (define rb1 (make-branch 1 10))
  (define m1 (make-mobile lb1 rb1))
  (define rb2 (make-branch 1 m1))
  (define m2 (make-mobile lb1 rb2))
  (define lb2 (make-branch 1 m1))
  (define m3 (make-mobile lb2 rb2))
#+END_SRC

#+BEGIN_SRC racket
  <<consts:m1-m2>>
  (total-weight m1)
  (total-weight m2)
#+END_SRC

A 'relaxed' version of total-weight, which may be applied to mobiles or weights.

#+NAME: def:total-weight-relaxed
#+BEGIN_SRC racket
  (define (total-weight-relaxed weight-or-mobile)
    <<sc:mobile-more>>
    (if (pair? weight-or-mobile)
	(total-weight weight-or-mobile)
	weight-or-mobile))
#+END_SRC

#+BEGIN_SRC racket
  <<def:total-weight-relaxed>>
  <<consts:m1-m2>>
  (total-weight-relaxed 10)
  (total-weight-relaxed m2)
#+END_SRC

#+NAME: def:hang-weight
#+BEGIN_SRC racket
  (define (hang-weight branch)
    <<sc:mobile>>
    <<def:total-weight-relaxed>>
    (* (branch-length branch) (total-weight-relaxed (branch-structure branch))))
#+END_SRC

#+NAME: def:isBalanced?
#+BEGIN_SRC racket
  (define (isBalanced? mobile)
    <<sc:mobile-more>>
    <<def:hang-weight>>
    (display mobile)
    (newline)
    (and
     (= (hang-weight (left-branch mobile)) (hang-weight (right-branch mobile)))
     (if (to-mobile? (left-branch mobile)) (isBalanced? (branch-structure (left-branch mobile))) #t)
     (if (to-mobile? (right-branch mobile)) (isBalanced? (branch-structure (right-branch mobile))) #t)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:isBalanced?>>
  <<consts:m1-m2>>
  (isBalanced? m3)
#+END_SRC

In short, we need a conjunction of balanced applied to main and all sub-mobiles.
So, we check weight * length for each branch of the mobile.
Then, we get to work on sub-mobiles.
There's no guarantee of sub-mobules, so we only check when sure.
And, otherwise return #t does the value of the conjunction is determined by all the other components.
The only thing to note with the recusrive case is that we need to move to the structure of the branch, rather than the branch itself.

I'd need to change right-branch and brach-structure procedures.
For, these assume we're working with a list.
With a list, the right element is always either a list or nil.
So, some extra work is needed to get any value.
In particular, we're always working with a pair.
So, to get the right hand value, we need to cdr then car.
But, if cons is used, then we're just working with two values.
Hence, we'd car and be done.

** 2.30

#+BEGIN_SRC racket
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))

(scale-tree (list 1 (list 2 (list 3 4 5))) 4)
#+END_SRC

Cons works fine here, as we're breaking a list down into it's basic elements, then building back up.
Things would be different if flattening the list, etc.

#+BEGIN_SRC racket
  (define (square-tree-basic tree)
    (cond ((null? tree) nil)
	  ((not (pair? tree)) (* tree tree))
	  (else (cons (square-tree-basic (car tree))
		      (square-tree-basic (cdr tree))))))

  (square-tree-basic (list 1 (list 2 (list 3 4) 5) (list 6 7)))

  (define (square-tree-map tree)
    <<def-my-map>>
    (my-map (lambda (sub-tree)
	      (if (pair? sub-tree)
		  (square-tree-map sub-tree)
		  (* sub-tree sub-tree)))
    tree))

  (square-tree-map (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+END_SRC

Right, map here just goes through each element in the list and applies the procedure.
So, what this does is abstracts from the way the list works, as emphasised in the book.
It's important to keep in mind this is the limit of what's happening.
The code should look mostly the same, given that little is being done to reconstruct the tree via lists.

** 2.31

#+NAME: def:tree-map
#+BEGIN_SRC racket
  (define (tree-map proc tree)
    <<def:my-map>>
    (my-map (lambda (sub-tree)
	      (if (pair? sub-tree)
		  (tree-map proc sub-tree)
		  (proc sub-tree)))
    tree))
#+END_SRC

#+BEGIN_SRC racket
  (define (square-tree-again tree)
    <<def:tree-map>>
    <<def:square>>
    (tree-map square tree))

  (square-tree-again (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+END_SRC

** 2.32

#+NAME: def-subsets
#+BEGIN_SRC racket
  (define (subsets s)
    <<def:my-map>>
    (if (null? s)
	(list nil)
	(let ((rest (subsets (cdr s))))
	  (append rest (my-map (lambda (x) (cons (car s) x)) rest)))))
#+END_SRC

#+BEGIN_SRC racket
<<def:subsets>>
(subsets (list 1 2 3))
#+END_SRC

So, we're splitting on the first element of the list.
Then, applying subsets to all other elements of the list.
We then keep a copy of every subset from the other elements of the list.
So, the only thing to do is ensure we also have a copy of the those subsets with the element we excluded.
This is what the lambda expresion does.

So, for example, (a b)
rest is just b.
subsets applied to b goes once more, to the value b and nil.
Now, on the way back, we have nil turned into an empty list, and b joined with the empty list.
So, we have (() (b)).
Now, we store a copy of this, and also consider a included.
So, this is ((a) (a b)).
Combined, we have (() (b) (a) (a b)).

** 2.33

#+NAME: def:accumulate
#+BEGIN_SRC racket
  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(op (car sequence)
	    (accumulate op initial (cdr sequence)))))
#+END_SRC

#+BEGIN_SRC racket
  (define (map-again p sequence)
    <<def:accumulate>>
      (accumulate (lambda (x y) (cons (p x) y))  nil sequence))

  <<def:square>>
  (map-again square (list 1 2 3 4 5))
#+END_SRC

Okay.
The point here is op is a two place argument.
The first argument to op is the current element of the sequence, and accumulate works through these one-by-one.
Then second argument to op is the result of accumulating.
So, for example, rather than cons, we could have summed.

E.g., map-sum maps the procedure and then sums the list.


#+BEGIN_SRC racket
  (define (map-sum p sequence)
    <<def:accumulate>>
    (accumulate (lambda (x y) (+ (p x) y)) 0 sequence))

  <<def:square>>
  (map-sum square (list 1 2 3 4 5))
#+END_SRC

#+BEGIN_SRC racket
  (define (append-again seq1 seq2)
    <<def:accumulate>>
    (accumulate cons seq2 seq1))

  (append-again (list 1 2) (list 3 4))
#+END_SRC

We're going through every element in list1 and cons to list2.
Here, though, you need some idea of the way lists and accumulate work.
For, if we worked through the list on call rather than close, this would reverse list1.
I like abstraction, but here I'm not sure what the point is, given we need the details to understand why the abstraction works.

#+NAME: def:length
#+BEGIN_SRC racket
  (define (length sequence)
    <<def:accumulate>>
    (accumulate (lambda (x y) (+ (if (null? x) 0 1) y)) 0 sequence))
#+END_SRC

#+BEGIN_SRC racket
  <<def:length>>
  (length (list 1 2 3))
  (length (list ))
#+END_SRC

** 2.34

#+NAME: def-horner-eval
#+BEGIN_SRC racket
  (define (horner-eval x coefficient-sequence)
    <<def:accumulate>>
    (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* higher-terms x)))
		0
		coefficient-sequence))
#+END_SRC

#+BEGIN_SRC racket
  <<def:horner-eval>>
  (horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

Right, I figured out the goal was to modify addition.
But, the choice of a and b was guess work.
I originially had (+ (* a x) b).
Thinking that a would be a_n at first.
But, it's not really higher-terms, it's higher-terms already done, right?

It's, what's already been done with the higher-terms, or something like this.

Right, this is clear when looking at the definition of accumulate.
We have op applied to the current first thing in the sequence and the rest.
So, by higher-terms this is the op-defined as applied to all the higher-terms from the current term.

#+BEGIN_SRC racket
  (define (horner-test x coefficient-sequence)
    <<def:accumulate>>
    (accumulate (lambda (this-coeff higher-terms) (display higher-terms) (newline) this-coeff higher-terms)
		0
		coefficient-sequence))

  (horner-test 2 (list 1 3 0 5 0 1))
#+END_SRC

This 'test' is kind of useless, as higher-terms is the result of evaluating higher terms, not the other terms to evaluate.

At this point in the book we're not only learning about the way abstractions are useful.
But, we're also learning about the way remembering what the abstractions really do is also useful.

** 2.35

#+NAME: def-
#+BEGIN_SRC racket
  (define (count-leaves-acc tree)
    <<def:accumulate>>
    <<def:fringe>>
    (accumulate + 0 (map (lambda (x) 1) (fringe tree))))

  <<consts:m1-m2>>
  (count-leaves-acc m2)
#+END_SRC

As I missing something here?
With an accumulator we need a list.
So, somehow we need to collapse the tree into a list.
fringe does this.
Then, somehow accumulate the elements of the list to get the number of leaves.
Well, here then just set every leaf value to 1.

** 2.36

Here, a way to make a list of the first elements of the lists.
Then, the rest of the lists.

#+BEGIN_SRC racket
(list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 1 1 12))
#+END_SRC

#+NAME: def-accumulate-n
#+BEGIN_SRC racket
  (define (accumulate-n op init seqs)
    <<def:accumulate>>
    <<def:my-map>>
    (if (null? (car seqs))
	nil
	(cons (accumulate op init (my-map car seqs))
			  (accumulate-n op init (my-map cdr seqs)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:accumulate-n>>
    (accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
#+END_SRC

Alright, this exercise was really cool!

** 2.37

#+NAME: consts:test-matrix
#+BEGIN_SRC racket
  (define test-matrix (list (list 1 2 3 4) (list 4 5 6 6) (list 6 7 8 9)))
#+END_SRC

#+NAME: def-dot-product
#+BEGIN_SRC racket
  (define (dot-product v w)
    <<def:accumulate>>
    (accumulate + 0 (map * v w)))
#+END_SRC

Hold on, we defined map to take a proc and a list.
Yet, here, map takes a proc and two lists.
So, here we're using the base map mentioned in Footnote 12.
This takes a procedure of n arguments and n lists.
Then, applies the procedure to the ith element in each of the lists.

Oh, right, *this* is in footnote 17.

#+NAME: def:matrix-*-vector
#+BEGIN_SRC racket
  (define (matrix-*-vector m v)
    <<def:dot-product>>
    (map (lambda (row) (dot-product row v)) m))
#+END_SRC

#+NAME: def:transpose
#+BEGIN_SRC racket
  (define (transpose m)
    <<def:accumulate-n>>
    (accumulate-n cons nil m))
#+END_SRC

#+BEGIN_SRC racket
  <<def:transpose>>
  (transpose (list (list 1 2) (list 3 4) (list 5 6)))
#+END_SRC

#+NAME: def:matrix-*-matrix
#+BEGIN_SRC racket
  (define (matrix-*-matrix m n)
    <<def:transpose>>
    <<def:matrix-*-vector>>
    (let ((cols (transpose n)))
      (map (lambda (x) (matrix-*-vector cols x)) m)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:matrix-*-matrix>>
  (matrix-*-matrix (list (list 2 3 4)
			 (list 1 0 0))
		   (list (list 0 1000)
			 (list 1 100)
			 (list 0 10)))
#+END_SRC

** 2.38

#+NAME: def-fold-left
#+BEGIN_SRC racket
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
#+END_SRC

#+BEGIN_SRC racket
  <<def:accumulate>>
  <<def:fold-left>>

  (accumulate / 1 (list 1 2 3)) ;  1 / (2 / 3)
  (fold-left / 1 (list 1 2 3))  ; (1 / 2) / 3
  (accumulate list nil (list 1 2 3)) ; With cons, the same list.
				     ; With list, (list … (list nil))
				     ; So, (1 (2 (3 ())))
  (fold-left list nil (list 1 2 3)) ; With cons, (((nil 1) 2) 3)
				    ; With list, (list (list nil 1) 2)
#+END_SRC

I mean, op should be such that (op x y) = (op y x)
Right, commutative.

Hence, +, *, etc should work fine

#+BEGIN_SRC racket
  <<def:accumulate>>
  <<def:fold-left>>
  (= (accumulate * 1 (list 1 2 3)) (fold-left * 1 (list 1 2 3)))
  (= (accumulate + 0 (list 2 3 5 9)) (fold-left + 0 (list 2 3 5 9)))
#+END_SRC

Things like list fail as (list 2 3) = (2 3) != (3 2) = (list 3 2).
Same for /, ^, etc.

** 2.39

#+NAME: def:filter
#+BEGIN_SRC racket
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
        (cons (car sequence)
              (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
#+END_SRC

TODO

reverse-fr isn't it.
But, I'm drawing blanks.

The issue is, append-elem is a 'worse' version of append.
In that, with appened-elem we make all the same recursive calls, and all but the last are kind of pointless.
While, in the case of append these can be used for other elements.

I'm really drwawing blanks on a way to do this without refering to the procedure by name.

#+BEGIN_SRC racket
  (define (append-elem e list)
    (if (null? list)
	(cons e nil)
	(cons (car list) (append-elem e (cdr list)))))

  (define (reverse-fr sequence)
    <<def:accumulate>>
    <<def:append-elem>>
    (accumulate (lambda (x y) (append-elem x y)) nil sequence))

  (reverse-fr (list 1 2 3))
#+END_SRC

#+BEGIN_SRC racket
  (define (reverse-fl sequence)
    <<def:fold-left>>
    (fold-left (lambda (x y) (cons y x)) nil sequence))

  (reverse-fl (list 1 2 3))
#+END_SRC

#+NAME: def:flatmap
#+BEGIN_SRC racket
  (define (flatmap proc seq)
    <<def:accumulate>>
    (accumulate append nil (map proc seq)))
#+END_SRC

#+NAME: def:enumerate-interval
#+BEGIN_SRC racket
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
#+END_SRC

#+NAME: def:prime-sum?
#+BEGIN_SRC racket
  (define (prime-sum? pair)
    <<def:prime?>>
    (prime? (+ (car pair) (cadr pair))))
#+END_SRC

#+NAME: def:make-pair-sum
#+BEGIN_SRC racket
  (define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
#+END_SRC

#+NAME: def:prime-sum-pairs
#+BEGIN_SRC racket
  (define (prime-sum-pairs n)
    <<def:filter>>
    <<def:enumerate-interval>>
    <<def:flatmap>>
    <<def:make-pair-sum>>
    <<def:prime-sum?>>
    (map make-pair-sum
	 (filter prime-sum?
		 (flatmap
		  (lambda (i)
		    (map (lambda (j) (list i j))
			 (enumerate-interval 1 (- i 1))))
		  (enumerate-interval 1 n)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:enumerate-interval>>
  <<def:flatmap>>
  <<def:prime-sum-pairs>>

  (prime-sum-pairs 10)
  (enumerate-interval 1 10)
  (flatmap
   (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 10))
  (flatmap (lambda (x) (list x x)) (enumerate-interval 1 10))
#+END_SRC

flatmap

We take a procedure and a list.
The list can be of plain elements.
However, the procedure must return pairs.
So, in this case, after applying the procedure with map, we have a list of lists.
Or, at least, each elemnt mapped over is replaced by a list.
Flatmap then flattens this, so the original list is expanded with additional elements, but these aren't themselves inside a list.

** 2.40

#+NAME: def-unique-pairs
#+BEGIN_SRC racket
  (define (unique-pairs n)
    <<def:flatmap>>
    <<def:enumerate-interval>>
    (flatmap (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1)))) (enumerate-interval 1 n)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:unique-pairs>>
  (unique-pairs 10)


  (define (prime-sum-pairs-up n)
    <<def:make-pair-sum>>
    <<def:filter>>
    <<def:prime-sum?>>
    (map make-pair-sum
	 (filter prime-sum?
		 (unique-pairs n))))

  (prime-sum-pairs-up 10)
#+END_SRC

But, this was just cutting apart the definition of prime-sum-pairs…

Or was this the point?

** 2.41

#+BEGIN_SRC racket
  (define (unique-triples n)
    <<def-flatmap>>
    <<def:unique-pairs>>
    <<def:enumerate-interval>>

    (flatmap (lambda (i) (map (lambda (j) (cons i j)) (unique-pairs (- i 1)))) (enumerate-interval 1 n)))
  

  (define (unique-triples-to-n-sum-to-s n sum)
    <<def:filter>>
    <<def:accumulate>>
    (filter (lambda (x) (= sum (accumulate + 0 x))) (unique-triples n)))

  (unique-triples-to-n-sum-to-s 10 10)
#+END_SRC

** 2.42 (Queens)

Function which takes an index and a list.
Returns a ist where the first element is what was at the index, and the second elemnt is the list without the element at the index.

That is, the list with the ith element now the 0th element.

Originally this was thought of as the ith element removed and the rest of the list, but shifting to front is a more natural perspective.

Index starts at 0.

#+NAME: def-shift-to-front
#+BEGIN_SRC racket
  (define (shift-to-front i list)
    (define (shift-list-i old new i n)
      (if (= i n)
	  (cons (car old) (cons (cdr old) new))
	  (shift-list-i (cons (car new) old) (cdr new) i (+ n 1))))
    (define (recombine old new)
      (if (null? old)
	  new
	  (recombine (cdr old) (cons (car old) new))))
    (let ((split (shift-list-i nil list i -1)))
      (cons (car split) (recombine (car (cdr split)) (cdr (cdr split))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:shift-to-front>>
  (cdr (shift-to-front 3 (list 1 2 3 4 5 6)))
#+END_SRC

A variant of map.
Instead of applying each item to proc, we apply a number corresponding to the instance of map and the item.
So, for example, (map-i proc (a b)) does (proc 0 a) and then (proc 1 b).

#+NAME: def:map-i-to-n
#+BEGIN_SRC racket
(define (map-i-to-n proc items n)
  (define (map-apply-index proc i items n)
    (if (or (null? items) (= i n))
        nil
        (cons (proc i (car items))
              (map-apply-index proc (+ i 1) (cdr items) n))))
  (map-apply-index proc 0 items n))
#+END_SRC

So, now it's easy to apply shift-to-front diagonally

E.g. (map-i shift-to-front grid) or to be explicit (map-i (lambda (i x) (shift-to-front i x)) grid)
The latter form is kind of helpful, as it's easy to discard i and only apply x.

Getting all the diagonals of a grid is a little difficult.
We use map-i-to-n to dynamically shift and limit the mapping.

The problem is whenever we do this, the grid is sure to become a rectangle.
And, while it's easy to make a function which works with a grid or wide rectange, extending this to a tall rectange isn't easy.

(Basically, (map-i-to-n shift-to-front tallGrid (length tallGrid)) only considers a grid.)

So, we avoid this issue by tranpsoing the grid if needed, to ensure it's always a grid or a wide rectangle.
It's easy to see diagonals are preserved under this.

The only issue is that this procedure is that it includes the empty list.
So, filter this out.

#+NAME: def:get-diags-lr
#+BEGIN_SRC racket
  (define (get-diags-lr grid)

  <<def:filter>>

    (define (collect-diag-to diagList grid)

      <<def:shift-to-front>>
      <<def:transpose>>
      <<def:map-i-to-n>>

      (if (null? grid)
	  diagList
	  (let ((tallGrid (cond ((null? grid) grid)
				((< (length (car grid)) (length grid)) (transpose grid))
				(else grid))))
	    (let ((shifted-list (map-i-to-n shift-to-front tallGrid (length tallGrid))))
	      (collect-diag-to (append diagList (cons (map car shifted-list) nil)) (map cdr shifted-list))))))
    (filter (lambda (x) (not (null? x))) (collect-diag-to nil grid)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:get-diags-lr>>
  (get-diags-lr (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
#+END_SRC

get-diags-lr only gets diags going left to right.
But, given the representation of a grid here, there's an easy fix.
Apply reverse.
This gives us a mirror.
Hence, lr becomes rl.

#+NAME: def:get-diags-rl
#+BEGIN_SRC racket
  (define (get-diags-rl grid)
  <<def:get-diags-lr>>
    (get-diags-lr (reverse grid)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:enumerate-interval>>
  (map (lambda (x) (if (= 2 x) 0 x)) (enumerate-interval 1 10))
#+END_SRC

We'll represent queens as 0s.
To test whether a board is safe, we check to see there are no two queens in a row column or diagonial.
get-diags gets us diagonials, grid is built with columsn, and transpose gets us rows.

So, all that's needed is a  couple of functions to ensure each list in a list of lists has at most one instance of a nubmer.
That's all these two functions do.

#+NAME: def:count-ns-in-list
#+BEGIN_SRC racket
  (define (count-ns-in-list n l)
    <<def:filter>>
    (length (filter (lambda (x) (= x n)) l)))
#+END_SRC

#+NAME: def:unique-n?
#+BEGIN_SRC racket
  (define (unique-n? n listOfLists)
    <<def:count-ns-in-list>>
    (if (null? listOfLists)
	#t
	(and (< (count-ns-in-list n (car listOfLists)) 2) (unique-n? n (cdr listOfLists)))))
#+END_SRC

#+NAME: def:queens
#+BEGIN_SRC racket
  (define (queens board-size)

    (define empty-board nil)  ; empty-board is nil.
			      ; adjoin-position will add a row.

    (define (safe? k positions)
      <<def:unique-n?>>
      <<def:transpose>>
      <<def:get-diags-lr>>
      <<def:get-diags-rl>>
      (and (unique-n? 0 (transpose positions)) (unique-n? 0 (get-diags-lr positions)) (unique-n? 0 (get-diags-rl positions))))

    (define (adjoin-position new-row k rest-of-queens)
      <<def:enumerate-interval>>
      (cons (map (lambda (x) (if (= new-row x) 0 x)) (enumerate-interval 1 board-size)) rest-of-queens)
      ; Place the queen at the new-row position.
      )
    (define (queens-cols k)
      <<def:filter>>
      <<def:flatmap>>
      <<def:enumerate-interval>>
      (if (= k 0)
	  (list empty-board)
	  (filter
	   (lambda (positions) (safe? k positions))
	   (flatmap
	    (lambda (rest-of-queens)
	      (map (lambda (new-row)
		     (adjoin-position new-row k rest-of-queens))
		   (enumerate-interval 1 board-size)))
	    (queens-cols (- k 1))))))
    (queens-cols board-size))
#+END_SRC

#+BEGIN_SRC racket
  <<def:queens>>
  (queens 8)
#+END_SRC

** 2.43

So, there's (queens-cols (- k 1)) and the number of times it's evaluated.
All this does is generate everything for the k - 1 case.
All here is a big all.
In the original proc, this is only evaluated once.
So, we make a lot of recursive calls, for sure, but these all stem from evaluating a single instance of queens-cols and going from there.

When things are flipped around, the proc is evluated for every instance in new-row.

Hence, if a single run takes T, then this is going to be even more than T * board-size.
Does it get close to T! ?

In any case, this is mostly about the way scheme evaluates.
So, moving on…

** 2.44

Going by the suggestion, this should paint two copies side-by-side below the arg.

#+BEGIN_SRC racket
  (define (up-split painter n)
    (if (= n 0)
	painter
	(let ((smaller (up-split painter (- n 1))))
	  (below painter (beside smaller smaller)))))
#+END_SRC

** 2.45

For reference, here's right-split

#+BEGIN_SRC racket
  (define (right-split painter n)
    (if (= n 0)
	painter
	(let ((smaller (right-split painter (- n 1))))
	  (beside painter (below smaller small)))))
#+END_SRC

Goal is 'split' such that:

#+BEGIN_SRC racket
(define right-split (split beside below))
(define up-split (split below beside))
#+END_SRC

So, proc which takes painter and n as argument.
lambda makes this easy.

#+BEGIN_SRC racket
  (define (split firstProc secondProc)
    (lambda (painter n)
      (if (= n 0)
	  painter
	  (let ((smaller ((split firstProc secondProc) painter (- n 1))))
	    (firstProc painter (secondProc smaller small))))))
#+END_SRC

** 2.46

#+BEGIN_SRC racket
(define (make-vect x y)
  (cons x y))

(define (xcor-vect v)
  (car v))

(define (ycor-vect v)
  (cdr v))

(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1) (xcor-vect v2)) (+ (ycor-vect v1) (ycor-vect v2))))

(define (sub-vect v1 v2)
  (make-vect (- (xcor-vect v1) (xcor-vect v2)) (- (ycor-vect v1) (ycor-vect v2))))

(define (scale-vect s v1)
  (make-vect (* s (xcor-vect v1)) (* s (ycor-vect v1))))
#+END_SRC

** 2.47

#+BEGIN_SRC racket
(define (make-frameL origin edge1 edge2)
  (list origin edge1 edge2))

(define (frameL-origin frame)
  (car frame))

(define (frameL-edge1 frame)
  (cadr frame))

(define (frameL-edge2 frame)
  (caddr frame))

(define (make-frameC origin edge1 edge2)
  (cons origin (cons edge1 edge2)))

(define (frameC-origin frame)
  (car frame))

(define (frameC-edge1 frame)
  (cadr frame))

(define (frameC-edge2 frame)
  (cddr frame))
#+END_SRC

** 2.48

#+BEGIN_SRC racket
  (define (make-segment origin start end)
    (cons start end))

  (define (start-segment seg)
    (car seg))

  (define (end-segment seg)
    (cdr seg))
#+END_SRC

There's nothing else here, right?
vec running from ogirin to the start-point is just start-point coordinates.
Same for end.

Unless the suggestion is to add start to origin, but I don't see good motivation for this.

On the other hand, I'm not sure why so many excercises are just cons car cdr…

** 2.49

So, fix the relevant coordinates, and then pass a list of segments to segmemts->painter.

I'm not interested enough to do the rest.

wave seems… a lot of work for basically nothing.

#+BEGIN_SRC racket
  (define (paintFrame frame)
    (let ((bottomLeft (frame-origin frame))
	  (bottomRight (add-vec (frame-origin frame) (frame-edge1 frame)))
	  (topRight (add-vec bottomRight (frame-edge2 frame)))
	  (topLeft (add-vec (frame-origin frame) (frame-edge2 frame))))
      (segmemts->painter
       (list
	(make-segment bottomLeft bottomRight)
	(make-segment bottomRight topRight)
	(make-segment topRight topLeft)
	(make-segment topLeft bottomLeft)))
      frame))
#+END_SRC

** 2.50

#+BEGIN_SRC racket
  (define (flip-hori painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))
#+END_SRC


So, origin is now (0, 1).
New x points to (1, 1)
And, y points to (0, 0).
Basically, everything is now upside down.

#+BEGIN_SRC racket
  (define (rotate180 painter) (rotate90 (rotate90 painter)))
#+END_SRC

I mean, really.
270 works the same way.

The point here is to minimize where things can go wrong.
Applying a rotation twice is straightforward.
So, then, leave 90 as the only complex operation.

Or, create a general function that works with any degree.

** 2.51

So, one option is to squish and shift origin.
The other is to squish, rotate 270, and mirror along the y-axis.

** 2.52

I'm good, for now.

Maybe someday I'll come back to this and see if there's a way to get everything to display…

** 2.53

#+NAME: def-memq
#+BEGIN_SRC racket
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:memq>>

  (list 'a 'b 'c) ; (a b c)
  (list (list 'george)) ; ((george))
  (cdr '((x1 x2) (y1 y2))) ; ((y1 y2)) - we're getting the list, just without the first element.
  (cadr '((x1 x2) (y1 y2))) ; (y1 y2)
  (pair? (car '(a short list))) ; #f - just 'a. though… (pair? (cddr '(a short list))) is #t, as list.
  (memq 'red '((red shoes) (blue socks))) ; #f, as red isn't in the main list.
  (memq 'red '(red shoes blue socks)) ; the entire list, as red is the first thing.
#+END_SRC

** 2.54

#+NAME: def-my-equal?
#+BEGIN_SRC racket
  (define (my-equal? l1 l2)
    (if (or (null? l1) (null? l2))
	true
	(and (eq? (car l1) (car l2)) (my-equal? (cdr l1) (cdr l2)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:my-equal?>>
  (my-equal? '(a b) '(c d))
  (my-equal? '(a b) '(a b))
#+END_SRC

I think this is what's being requested.
This is similar to how I did valid? for 8-queens.
For a similar or implementation DeMorgan.
Base case is false, and build up with or.
Though, something iterative would be better, as you can skip everything after finding a matching pair.

** 2.55

#+BEGIN_SRC racket
(car ''abracadabra)
(cddr ''abracadabra)

;; (car 'abracadabra)
;; (cdr 'abracadabra)
#+END_SRC

I mean, I'm not sure we've been told enough here.
If we do car we get quote, and if we do cdr we get 'abracadabra.
But, ' doesn'6 make a list.
(car 'abracadabra) fails.

Well, idea is ' is just a procedure.
So, 'abc is really (' a b c) or something of the sort.
And, as the procedure is quoted and is just a list, then everything inside is quoted.

(cddr ''abracadabra) is just the empty list.

This is easay to test:

#+BEGIN_SRC racket
(quote abc)
#+END_SRC

Yeah, seems about right.

** 2.56

#+NAME: sc:def-my-deriv
#+BEGIN_SRC racket
      (define (variable? e)
	(symbol? e))


      (define (same-variable? v1 v2)
	(and (variable? v1) (variable? v2) (equal? v1 v2))) ; Huh, so this includes checks for variables.


    (define (sum? e)
      (and (pair? e) (eq? (car e) '+)))


  (define (augend e)
    (if (null? (cdddr e))
	(caddr e)
	(cons '+ (cddr e))))


  (define (addend e)
    (cadr e))


  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
	  ((=number? a2 0) a1)
	  ((and (number? a1) (number? a2)) (+ a1 a2))
	  (else (list '+ a1 a2))))


  (define (product? e)
    (and (pair? e) (eq? (car e) '*)))


  (define (multiplier e)
    (if (and (pair? e) (pair? (cdr e))) ; okay, these checks are skipped.
	(cadr e)                        ; in part I understand. As pair? is a predicate.
	(error "not really a mult")))   ; And, pair? is still nice so long as we evaluate as needed and and is defined to use this.


  (define (multiplicand e)
    (if (null? (cdddr e))
	(caddr e)
	(cons '* (cddr e))))


  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
	  ((=number? m1 1) m2)
	  ((=number? m2 1) m1)
	  ((and (number? m1) (number? m2)) (* m1 m2))
	  (else (list '* m1 m2))))


  (define (=number? exp num)
    (and (number? exp) (= exp num)))

  (define (exponentiation? e)
    (and (pair? e) (eq? (car e) '^)))


  (define (make-exponent b e)
    (cond ((=number? e 0) 1)
	  ((=number? e 1) b)
	  (else (list '^ b e))))

  (define (exponent e)
    (caddr e))

  (define (base e)
    (cadr e))


  (define (my-deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp)
	   (if (same-variable? exp var) 1 0))
	  ((sum? exp)
	   (make-sum (my-deriv (addend exp) var)
		     (my-deriv (augend exp) var)))
	  ((product? exp) (make-sum
			   (make-product (multiplier exp)
					 (my-deriv (multiplicand exp) var))
			   (make-product (my-deriv (multiplier exp) var)
					 (multiplicand exp))))
	  ((exponentiation? exp) (make-product
				  (make-product
				   (exponent exp)
				   (make-exponent var (- (exponent exp) 1)))
				  (my-deriv (base exp) var)))
	  (else
	   (error "unknown expression type -- DERIV" exp))))
#+END_SRC

#+BEGIN_SRC racket
  <<sc:def:my-deriv>>
  (my-deriv (make-product 0 'x) 'x)
  (my-deriv '(+ x 3 4) 'x)
  (my-deriv '(* x y z 5) 'x)
  (my-deriv '(^ x 2) 'x)
  (my-deriv '(^ x 3) 'x)
  (my-deriv '(+ 5 (^ x 3)) 'x)
  (my-deriv '(* x y (+ x 3)) 'x)
#+END_SRC

** 2.57

Modified above.

Though, I don't like this.
For, these expressions as written aren't using make-product, etc.
And, when using make-porduct, there's no way to 'officially' construct something of this kind.

Of course, we can extend.

#+BEGIN_SRC racket
(define (make-sum-wild a)
  (cond
    ; First condition, check if everything in the list is a number, if so sum
    ((accumulate (lambda (x y) (and (number? x) y)) true a) (accumulate + 0 a))
    (else
     ; Else, we have some symbols.
     ; So, sum what we can, and collect all the variables.
     (let ((sumNum (accumulate + 0 (filter number? a)))
           (sumSym (filter (lambda (x) (not (number? x))) a)))
       ; Then, make a list.
       ; As we know sumSym is non-empty and the rest are literals, easiest to cons
       ; But, check to see whether there's any sense making the list
       (cond ((and (= sumNum 0) (= 1 (length sumSym))) (car sumSym))
             ((= sumNum 0) (cons '+ sumSym))
             (else (cons '+ (cons sumNum sumSym))))))))
#+END_SRC

#+BEGIN_SRC racket
(define (make-product-wild m)
  (cond ((memq 0 m) 0)
        ((accumulate (lambda (x y) (and (number? x) y)) true m) (accumulate * 1 m))
        (else
         (let ((multNum (accumulate * 1 (filter number? m)))
               (multSym (filter (lambda (x) (not (number? x))) m)))
           (cond ((and (= multNum 1) (= 1 (length multSym))) multSym)
                 ((= 1 multNum) (cons '* multSym))
                 (else (cons '* (cons multNum multSym))))))))
#+END_SRC

These work kind of nice, at least outside of deriv.
The problem is, these reduce too effectively.
And, deriv expects at least something binary.

So, I could reverse a little.
These setters could be written to match up with deriv and the way it works internally.
But, ugh.
At this point we have to modify deriv.
As, there's no way to allow the user to give a list, and for deriv to provide two arguments.

** 2.58

With infix and explicit parentheses, this amounts to reverting the representation of sum and product to work with two arguments and then updating where the symbol is stored.

After the mess of the previous question, I have no interest in the second part of this.
The simplest approach would be to create a process which rewrites the expression with correct parentheses.
Then, only need to pass the argument through this proc.

Else, as seen above, deriv no longer works.

Oh, does this mean the question is done?

The answer is no.
For, there's no way to build a constructor that allows the user to write expressions of this form while preserving the internals of deriv.

Ah, though maybe there is.
For example, we could write a proc which takes a single argumnet.
Then, depending on the value, does something or takes another argument.
In this way, we could test for a list, and if not then take on the second argument.

** 2.59

#+NAME: def-element-of-set?
#+BEGIN_SRC racket
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
#+END_SRC

#+NAME: def:union-set
#+BEGIN_SRC racket
  (define (union-set set1 set2)
  <<def:element-of-set?>>
    (cond ((null? set1) set2)
	  ((element-of-set? (car set1) set2) (union-set (cdr set1) set2))
	  (else (union-set (cdr set1) (cons (car set1) set2)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:union-set>>
  (union-set (list 1 2 3) (list 3 4 5))
#+END_SRC

** 2.60

Nothing needs to change with element-of-set? and intersection-set.
element-of-set? works through a list and checks to see if x is equal to anything on the list.
Nothing changes if duplicates are allowed.
Likewise, intersection-set remains the same. Work through each element in set1 and check whether it's in set2.

union-set can remain the same, or can be simplified.
All we really need to do is (append set1 set2).
Though, avoiding this helps with efficiency.

Speaking of, if we're measuring runtimes by the size of the set, then any particular instance will be at least as slow.
Though, there's no substantial change.
In particular, intersection will keep the runtime down, and union too if the original is kept.

I can't think of an interesting application.
If writing is cheap and reading is expensive, and you're not transforming sets much, then repetitions works better.
But, I'm not sure when this is the case.

** 2.61

#+NAME: def-adjoin-set-o
#+BEGIN_SRC racket
  (define (adjoin-set-o e set)
    (cond ((null? set) (list e))
	  ((= e (car set)) set)
	  ((< e (car set)) (cons e set))
	  (else (cons (car set) (adjoin-set-o e (cdr set))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:adjoin-set-o>>
  (adjoin-set-o 4 (list 1 2 3 5 6 7))
  (adjoin-set-o 0 (list 1 2 3 5 6 7))
  (adjoin-set-o 8 (list 1 2 3 5 6 7))
  (adjoin-set-o 8 (list 1 9 3 5 6 7))
#+END_SRC

** 2.62

#+NAME: def-union-set-o
#+BEGIN_SRC racket
(define (union-set-o set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        ((= (car set1) (car set2)) (union-set-o (cdr set1) set2))
        ((< (car set1) (car set2)) (cons (car set1) (union-set-o (cdr set1) set2)))
        ((< (car set2) (car set1)) (cons (car set2) (union-set-o set1 (cdr set2))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:union-set-o>>
  (union-set-o (list 1 2 3) (list 4 5 6))
  (union-set-o (list 1 2 3) (list 1 2 3))
  (union-set-o (list 4 5 6) (list 1 2 3))
  (union-set-o (list 1 4) (list 2 3))
#+END_SRC

** 2.63

#+NAME: sc:tree
#+BEGIN_SRC racket
  (define (entry tree) (car tree))

  (define (left-branch-tree tree) (cadr tree))

  (define (right-branch-tree tree) (caddr tree))

  (define (make-tree entry left right)
    (list entry left right))
#+END_SRC

#+NAME: def-element-of-set?-tree
#+BEGIN_SRC racket
  (define (element-of-set?-tree x set)
    <<sc:tree>>
    (cond ((null? set) false)
	  ((= x (entry set)) true)
	  ((< x (entry set)) (element-of-set?-tree x (left-branch-tree set)))
	  (else (element-of-set?-tree x (right-branch-tree set)))))
#+END_SRC

#+NAME: def:adjoin-set
#+BEGIN_SRC racket
  (define (adjoin-set x set)
    <<sc:tree>>
    (cond ((null? set) (make-tree x nil nil))
	  ((= x (entry set)) set)
	  ((< x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch-tree set)) (right-branch-tree set)))
	  ((> x (entry set)) (make-tree (entry set) (left-branch-tree set) (adjoin-set x (right-branch-tree set))))))
#+END_SRC

#+NAME: def:tree->list-1
#+BEGIN_SRC racket
  (define (tree->list-1 tree)
    <<sc:tree>>
    (if (null? tree)
	'()
	(append (tree->list-1 (left-branch-tree tree))
		(cons (entry tree)
		      (tree->list-1 (right-branch-tree tree))))))
#+END_SRC

#+NAME: def:tree->list-2
#+BEGIN_SRC racket
  (define (tree->list-2 tree)
    <<sc:tree>>
    (define (copy-to-list tree result-list)
      (if (null? tree)
	  result-list
	  (copy-to-list (left-branch-tree tree)
			(cons (entry tree)
			      (copy-to-list (right-branch-tree tree) result-list)))))
    (copy-to-list tree '()))
#+END_SRC

#+NAME: consts:2.16
#+BEGIN_SRC racket
  <<sc:tree>>

  (define 2.16a (make-tree 7 (make-tree 3 (make-tree 1 nil nil) (make-tree 5 nil nil)) (make-tree 9 nil (make-tree 11 nil nil))))
  (define 2.16b (make-tree 3 (make-tree 1 nil nil) (make-tree 7 (make-tree 5 nil nil) (make-tree 9 nil (make-tree 11 nil nil)))))
  (define 2.16c (make-tree 5 (make-tree 3 (make-tree 1 nil nil) nil) (make-tree 9 (make-tree 7 nil nil) (make-tree 11 nil nil))))
#+END_SRC

#+BEGIN_SRC racket
  (tree->list-1 2.16a)
  (tree->list-1 2.16b)
  (tree->list-1 2.16c)

  (tree->list-2 2.16a)
  (tree->list-2 2.16b)
  (tree->list-2 2.16c)
#+END_SRC


I think it's clear these are equivalent by inspection.
Though, trees of Diag. 2.16 written up.

And, tree->list-2 is more efficient.
The key difference is the way recursion is structured.

tree->list-1 does recursion on both branches at the same time.
This leads to needing to combine two lists.
No problem with pointers, but here this means a lot of car and cdr.

tree->list-2 does recursion on the right braches and then on the left.
So, on the close of a recursion call the only task is to add whatever the current entry is.
Everything to the right is already reduced to a list.

** 2.64

partial-tree takes two arguments:

1. elts a list of elements
2. n an integer such that m ≤ (length elts)

The result is a balanced binary tree containing the first n elements of elts.
For exposition, we assume n = (length elts).

This is recursive.
And, the very short version is partial-tree splits elts into half, save for the middle element.
partial-tree is then applied to the left and right 'havles' and the result of partial-tree forms the left and right branches associated with the current element.
This recusrive application stops when there are no more elements in elts.

We can be sure this creates a balanced tree as by assumption elts is ordered.
If n is odd, there there's a unique middle element for the root.
And, if n is even then we can choose either (floor (/ n 2)) or (ceil (/ n 2)) as we can't do any better than a slightly lopsided tree.

Visually, the process is something like this, from left to right (where the last step incorporates a couple of recursive calls.)

                   3               3
                 /   \            / \
(1 2 3 4 5)   (1 2)  (4 5)       2   4
                                /     \
                               1       5

Growth should be n.
For, each recursive call is tasked with half the work, intuitively.
However, we still need to do the work on both halves.

** 2.65

For union, the easiest thing to do is adjoin.
The problem is, there's no guarantee this makes a balanced tree.
but, adjoin should be (log n), hence this would be (n log n).

I don't think anything quite so fancy is expected.

First, we can flatten both sets.
This can be done in Theta(n) using tree->list-2.
Then, as the lists are ordered, it's easy to combine these.
This is just union for the ordered list representation.
Finally, we rebuild the set.
This is then n.

#+BEGIN_SRC racket
  (define (union-set-b set1 set2)
    <<def-union-set-o>>
    <<def:tree->list-2>>
    (let ((unionOL (union-set-o (tree->list-2 set1) (tree->list-2 set2))))
      (partial-tree unionOL (length unionOL))))
#+END_SRC

Intersection is then analogous.

Note, creating a tree by adjoining each element wound't be as effective.
This would be n log n in the worst case, as the final adjoinment might need to go through the entire tree.
But, this isn't what we're doing.
When we have an ordered set, there's no need to search through a tree.

From a slightly broader perspective, then, we have a new structure which allows for some operations to be faster.
And, for some difficult operations with the new structure, we have a way to transform the new structure into an older structure where the operations are fairly simple.
And, this is done in a fairly effective way.

This does take some work, and Theta may be hiding some real-world overhead of transforming between structures.
But, this is very nice.
And, a great way to make an incremental improvement.
Indeed, it's easy to convert all of the old ordered list sets into binary tree sets.

** 2.66

#+NAME: def:lookup-b
#+BEGIN_SRC racket
  (define (lookup-b e set)
    <<sc:tree>>
    (cond ((null? set) false)
	  ((= (entry set) e) true)
	  (else (or (lookup-b e (left-branch-tree set)) (lookup-b e (right-branch-tree set))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:lookup-b>>
  <<consts:2.16>>
  (lookup-b 1 2.16a)
  (lookup-b 2 2.16b)
  (lookup-b 9 2.16c)
#+END_SRC

Straightfoward.
Can't do better than n as may need to check every node.

** Huffman prep


#+NAME: sc:hf
#+BEGIN_SRC racket
  (define (make-leaf symbol weight)
    (list 'leaf symbol weight))

  (define (leaf? object)
    (eq? (car object) 'leaf))

  (define (symbol-leaf x) (cadr x))

  (define (weight-leaf x) (caddr x))

  (define (left-branch-tree tree) (car tree))

  (define (right-branch-tree tree) (cadr tree))

  (define (symbols tree)
    (if (leaf? tree)
	(list (symbol-leaf tree)) ; leaf, so 2nd elem, but make into a list on one
	(caddr tree))) ; tree so 3rd elem

  (define (weight tree)
      (if (leaf? tree)
	  (weight-leaf tree)
	  (cadddr tree)))

  (define (make-code-tree left right)
    (list left
	  right
	  (append (symbols left) (symbols right))
	  (+ (weight left) (weight right))))
#+END_SRC

#+NAME: def:choose-branch-hf
#+BEGIN_SRC racket
  (define (choose-branch bit branch)
    <<sc:hf>>
    (cond ((= bit 0) (left-branch-tree branch))
	  ((= bit 1) (right-branch-tree branch))
	  (else (error "bad bit -- CHOOSE-BRANCH" bit))))
#+END_SRC

#+NAME: def:decode-hf
#+BEGIN_SRC racket
  (define (decode bits tree)
    (define (decode-1 bits current-branch)
      <<def:choose-branch-hf>>
      <<sc:hf>>
      (if (null? bits)
	  '()
	  (let ((next-branch
		 (choose-branch (car bits) current-branch)))
	    (if (leaf? next-branch)
		(cons (symbol-leaf next-branch)
		      (decode-1 (cdr bits) tree))
		(decode-1 (cdr bits) next-branch)))))
    (decode-1 bits tree))
#+END_SRC

#+NAME: def:adjoin-set-hf
#+BEGIN_SRC racket
  (define (adjoin-set e set)
    <<sc:hf>>
    (cond ((null? set) (list e))
	  ((< (weight e) (weight (car set))) (cons e set))
	  (else (cons (car set)
		      (adjoin-set e (cdr set))))))
#+END_SRC

#+NAME: def:make-leaf-set-hf
#+BEGIN_SRC racket
  (define (make-leaf-set pairs)
    <<def:adjoin-set-hf>>
    <<sc:hf>>
    (if (null? pairs)
	'()
	(let ((pair (car pairs)))
	  (adjoin-set (make-leaf (car pair)
				 (cadr pair))
				 (make-leaf-set (cdr pairs))))))
#+END_SRC

Here, we can see pair should be a list, rather than a pair.

With decode a bit is always removed as we've either finished decoding or used the bit to move further into the tree.

** 2.67

#+NAME: consts:2.67
#+BEGIN_SRC racket
  <<sc:hf>>

  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
		    (make-code-tree
		     (make-leaf 'B 2)
		     (make-code-tree (make-leaf 'D 1)
				     (make-leaf 'C 1)))))

  (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+END_SRC

#+BEGIN_SRC racket
  <<consts:2.67>>
  <<def:decode-hf>>

  (decode sample-message sample-tree)
#+END_SRC

** 2.68

encode-symbol has a helper function which does most of the work.

In short, work through the tree until you get to a leaf.
If the symbol of the leaf matches the symbol taken as argumnet, we want to return the path we took to get here.
Otherwise, we want to do nothing.

If returning path, we start with nil.
To ignore results, return false.

If we're not at a leaf, we explore both left and right branches – the symbol could be anywhere in the tree!

If either branch is not false, then add the option we took to get this result.
If both branches are false, return false – the sym hasn't been found.

At the end, we replace false with the desired error message.


#+NAME: def:encode-symbol
#+BEGIN_SRC racket
  (define (encode-symbol sym tree)
    (define (encode-symbol-f sym tree)
      <<sc:hf>>
      (cond ((leaf? tree)
	     (if (equal? (symbols tree) (list sym))
		 nil
		 #f))
	    (else
	     (let ((leftResult (encode-symbol-f sym (left-branch-tree tree)))
		   (rightResult (encode-symbol-f sym (right-branch-tree tree))))
	       (cond ((not (equal? leftResult #f)) (cons 0 leftResult))
		     ((not (equal? rightResult #f)) (cons 1 rightResult))
		     (else #f)
		     )))))
    (let ((encode (encode-symbol-f sym tree)))
      (if (equal? encode #f)
	  (error "symbol not in tree -- ENCODE-SYMBOL" sym)
	  encode
	  )))
#+END_SRC


#+BEGIN_SRC racket
  <<consts:2.67>>
  <<def:encode-symbol>>

  (encode-symbol 'A sample-tree)
  (encode-symbol 'B sample-tree)
  (encode-symbol 'X sample-tree)
#+END_SRC

#+NAME: def:encode-hf
#+BEGIN_SRC racket
  (define (encode message tree)
    <<def:append>>
    <<def:encode-symbol>>
    (if (null? message)
	'()
	(append (encode-symbol (car message) tree)
		(encode (cdr message) tree))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:encode-hf>>
  <<consts:2.67>>
  (encode '(A D A B B C A) sample-tree)
#+END_SRC

** 2.69

#+NAME: successive-merge-hf
#+BEGIN_SRC racket
  (define (successive-merge set)
    <<def:adjoin-set-hf>>
    <<sc:hf>>
    (cond
      ((= (length set) 0) '())
      ((= (length set) 1) (car set))
      (else (successive-merge (adjoin-set (make-code-tree (car set) (cadr set)) (cddr set))))))
#+END_SRC

Testing successive-merge

#+BEGIN_SRC racket
  (define sfp (list (list 'A 4) (list 'B 2) (list 'C 1) (list 'D 1)))

  <<def:make-leaf-set-hf>>
  <<successive-merge-hf>>
  <<def:encode-hf>>

  (successive-merge (make-leaf-set sfp))
  (successive-merge (make-leaf-set (list )))

  (encode '(A D A B B C A) (successive-merge (make-leaf-set sfp)))
#+END_SRC

#+NAME: def:generate-huffman-tree-hf
#+BEGIN_SRC racket
  (define (generate-huffman-tree pairs)
    <<def:make-leaf-set-hf>>
    <<successive-merge-hf>>
    (successive-merge (make-leaf-set pairs)))
#+END_SRC

** 2.70

#+NAME: consts:2.70
#+BEGIN_SRC racket
  (define 80alphUO (list (list 'A 2)
			 (list 'BOOM 1)
			 (list 'GET 2)
			 (list 'JOB 2)
			 (list 'NA 16)
			 (list 'SHA 3)
			 (list 'YIP 9)
			 (list 'WAH 1)))

  <<def:accumulate>>
  <<sc:hf>>
  <<def:adjoin-set-hf>>
  (define 80alphOL (accumulate
		    (lambda (e s) (adjoin-set (make-leaf (car e) (cadr e)) s))
		    (list )
		    80alphUO))
  (define 80alphO
    (accumulate (lambda (e s) (cons (list (cadr e) (caddr e)) s)) nil 80alphOL))
#+END_SRC

So, I got a little sidetracked trying to order the list by a direct call to adjoin-set.
The issue is, adjoin-set only works with leaves.
Hence, to make this work, need to transform elements to leaves.
Then, of course, it's easy to revert the elemnts back once in ordered state.

Still, much easier to define an instance of ordered insert on symbol frequency pairs.
Or, just, y'know, generate the tree from an unordered list.
As, make-leaf-set ensures everything is ordered.

#+BEGIN_SRC racket
  <<consts:2.70>>
  <<def:generate-huffman-tree-hf>>
  (generate-huffman-tree 80alphUO)

  (length (generate-huffman-tree 80alphUO))
#+END_SRC

We need 4 bits for each symbol (I think, as height of the tree should correspond to the number of choices that need to be made).
So, to encode the song we need number of symbols * 4 bits.
Though, spaces are an issue, unless it's assumed there is a space after every symbol…

With fixed-length coding we'd need 3 bits.

The issue here is the first symbol.
As this is 0 (or 1), we 'loose' the rest of the bits.
As, every other symbol needs to begin with 1.

** 2.71

I think n bits.
The issue here is that the combined weight of the previous two merges is always going to be less than the weight of the next sym-freq pair.
Hence, the tree is created one branch at a time.

Stated a little more intuitively, the idea of Huffman encoding is to trade any remaining bits used to store information so long as we do not expect to use those bits to access information more often that the information we're currently accessing.

And, this sequence is such that we always expect to use the current piece of information at least as much as any following piece of information.

So, we get a tree which has no balance.

** TODO 2.72

I'd like to consider the general case.

And, also, work through a few more basic problems first.

** 2.73

*** a.

For this rewrite of deriv we allow adding arbitrary operations by add and get.
However, get is defined to take an operator.
And, then get returns a procedure corresponding to the operator.

It is not possible to assimilate the predicates namer? and same-variable? in this way as these function as tests on whether the expression contains an operator.
Note, in particular, this test is implicit to same-variable?, which ensures the two expressions are varaiables, and then tests for equality.

Put slightly differently, an expression contains an operator if and only if it is neither a number nor a variable.
As the call to get requires an operator, we must perform some tests to ensure the expression is neither a number nor a variable before the call to get can do some work. This is what the two predicates do.



*** b.

Our original procedure for symbolic differentation looked like this:

#+BEGIN_SRC racket :tangle no
  (define (deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp) (if (same-variable? exp var) 1 0))
	  ((sum? exp)
	   (make-sum
	    (deriv (addend exp) var)
	    (deriv (augend exp) var)))
	  ((product? exp) (make-sum
			   (make-product (multiplier exp)
					 (deriv (multiplicand exp) var))
			   (make-product (deriv (multiplier exp) var) (multiplicand exp))))
	  ; (more rules can be added here)
	  (else (error " unknown expression type -- DERIV" exp))))
#+END_SRC

With data-directed programming, we have the option of making deriv addidative.

On way of approaching this rewrite is to write out functions for each type combination.
For example, make-sum starts to look something like this:

#+BEGIN_SRC racket :tangle no
  (define (make-sum-numbers exp1 exp2) (+ exp1 exp2))

  (define (make-sum-sym exp1 exp2) (list '+ exp1 exp2))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (put 'make-sum '(number number) make-sum-numbers)

  (put 'make-sum '(symbol symbol) (list '+ exp1 exp2))
#+END_SRC

Indeed, ='deriv= already does some basic type checking.
However, the approach taken is to use data-directed programming to obtain arbitrary operators relative to ='deriv=, without type-checking.

The base code given is:

#+BEGIN_SRC racket :tangle no
  (define (deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp) (if (same-variable? exp var) 1 0))
	  (else ((get 'deriv (operator exp)) (operands exp) var))))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))
#+END_SRC

So, the call to get takes ='deriv= and the operator.
Hence, the procedure we define does not work on typed objects.
So, =make-sum= is close to before.
Though, now we have a list of expressions and a variable, and maybe the need to call ='deriv=

#+BEGIN_SRC racket :tangle no
  (define (make-sum exps var)
    (let ((exp1 (car exps))
	  (exp2 (cadr exps)))
      (cond ((=number? exp1 0) exp2)
	    ((=number? exp2 0) exp1)
	    ((and (number? exp1) (number? exp2)) (+ exp1 exp2))
	    (else (list '+
			((get 'deriv (operator exp1)) (operands exp1) var)
			((get 'deriv (operator exp2)) (operands exp2) var))))))
#+END_SRC

Note, the =number?= cases function like base cases.
There's nothing more to be done.
And, the =else= case just breaks down the expression one step.


To make this available, we =put= a suitable name relative to ='deriv=.
For example:

#+BEGIN_SRC racket :tangle no
  (put 'deriv 'make-sum make-sum)
#+END_SRC

And perhaps:

#+BEGIN_SRC racket :tangle no
  (put 'deriv '+ make-sum)
#+END_SRC

Here, with the data-directed approach we have a lot of flexibility with the possible operator symbols.

=make-product= is transformed in an analogous way.

*** c.


I don't think this is sufficiently different from part b.

*** d.


We'd need to update each of the helper functions, as these may calls to =get=.
Aside from this, no significant changes are required.

However, things could get complex.
For, in addition to ='deriv=, the same operators may be associated with other procedures.
As things are originially, there's nothing too difficult.
Rather than ='deriv= we'd have a name for the new procedure, and specify operators relative to the procedure.

However, on the proposed change we'd need to ensure each existing operator was appropriately disambiguated.

Well, I'd guess.
We have a lookup table and ordered argumnets.
So, I would expect =get= searches by row then column or vice-versa.
If =get= doesn't work this way, then there's nothing too signficant.

** 2.74

I don't think there's need to write anything specific for this exercise.
So, high level answers follow.

In general, we follow data-directed dispatch.
Where dispatch follows the division.

Note, there should be a unique name for each division recgonised by central.

In this way, each division can set common functions relative to their division and only need to know:

1. Which common functions to write.
2. The name of their division.

*** a.

Personnel files are single files containing a set of records keyed to employee names, relative to each division.
So, get-record will use the division's procedure for opening their personnel file and searching through the set to find the employee name and record.

Ideally, central will specify a general form for the record to take.
If so, each division can transform however their record is stored into something of the same form as obtained from other divisions.

Depending on what else is going on, one may wish to implement a procedure for obtaining the raw record and also make any transformation procedures public.

With no further modifications, central would need to supply a division to dispatch on and an employee name.
Though, employee names could be tagged with the division to which they belong.
Though, if names are unique and requests for records are infrequent, it may make sense to search through each division.

*** b.

Ah, get-salary is a special case of the above.
We'd require each division to implement a salary option.
The way records are structured is up to each division.

*** c.

For find-employee-record we're given a name and all the files of a division.
The first, and only significant, task is to obtain the personnel records file.
As each division has one of these, it seems easiest to require each division to set to a generic return-records procedure.
Or, a generic find-employee-record.

A beneift of the former is a way for central to combine generic arguments.

Without central knowing the way each division stores their files, nothing more can be done.
E.g. one division may store their files as a list, while another may have a Huffman tree based on files access frequency.

*** d.

I'm not sure what 'the new personnel information' refers to.
This isn't new information about employees, and the only other information considered is old to each division.

Central needs to write generic functions, along with put and get procedures.
And, let each division know about all of this!

** 2.75

In mess-age passing style make-from-real-imag is as follows:

#+BEGIN_SRC racket
  (define (make-from-real-imag x y)
    (define (dispatch op)
      (cond ((eq? op 'real-part) x)
	    ((eq? op 'imag-part) y)
	    ((eq? op 'magnitude)
	     (sqrt (+ (square x) (square y))))
	    ((eq? op 'angle) (atan y x))
	    (else
	     (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
    dispatch)
#+END_SRC

make-from-real-imag takes two arguments, the real and imaginary part of the complex number, respectively.
In return, a procedure is given which takes the name of a procudeure and then performs the procedure on the arguments initially given.

Working with magnitudes and angles, we have a very similar procedure.
Though, here mangitudes and angles are stored, and real and imaginary parts are calculated.

#+BEGIN_SRC racket
  (define (make-from-mag-ang mag ang)
    (define (dispatch op)
      (cond ((eq? op 'real-part) (* mag (cos ang))
	    ((eq? op 'imag-part) (* mag (sin ang))
	    ((eq? op 'magnitude) mag)
	    ((eq? op 'angle) ang)
	    (else
	     (error "Unknown op -- MAKE-FROM-MAG-ANG" op))))
    dispatch)
#+END_SRC

** 2.76

**** Generic operations with explict dispatch

For generic operations with explicit dispatch, adding a new type amounts to tagging objects with the relevant type.
This is very much the same as data-directed style.
However, if we expect existing procedures to extend to the new type, we need to update the procedure definitions with conditions for the type.

And, any new operation needs to be defined.

**** Data-directed style

For a new type we should provide a way of tagging objects as the relevant type, define isolated procedures on the relevant objets and then =put= these procedures on the table.

As with generic operations with explict dispatch, we need to explictly extend existing procedures to the new types.
However, this doesn't necessarily involve writing anything new.
For, with =put= we can associate an existing procedure with the new type, so long as the procedure works as intended on the typed object.

Ideally, though, we would design a package with constructors, selectors, and all other procedures for the relevant type.

In contrast to message-passing style, we don't introduce 'new' objects.
However, we do introduce a way of disamguating the way we interact with familar lisp lists based on types.

**** Message-passing style

For a new type we need to specify a constructor, and internal to this we have the relevant selectors.

For new procedures, it depends.
Procedures like =make-from-real-imag= and =make-from-mag-ang= return an object, and for procedures on the object, we should specify messages to recieve.

For other procedures I'm not sure.
And, to be honest I'm not sure with the two procedures either.

For, from a general perspective, each operator can be seen as an object.
In this sense, something which takes two objects could recieve a message, such as =make-from-real-imag= or =+= and then work out what to do.
On the other hand, we're still building everything from the foundations of lisp, so you should decide whether the procedure is creating an object that should recieve messages.
And, if so write out ways to handle those messages.

** 2.77


The important thing to keep in mind win the data-directed style is that as soon as we remove types, everything is basic lisp.
So, as long as =real-part=, etc. work on complex numbers, there's no issue associating =real-part= with the =complex= type.

#+BEGIN_SRC racket :tangle no
  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (error
	     "No method for these types -- APPLY-GENERIC"
	     (list op type-tags))))))
#+END_SRC

The represenation of 3 + 4i in rectungular form in Figure 2.24, written in standard form is:

#+BEGIN_SRC racket  :tangle no
  ('complex ('rectangular (3 4)))
#+END_SRC

We have evaluated:

#+BEGIN_SRC racket  :tangle no
  (put 'magnitude '(complex) magnitude)
#+END_SRC

However, this means there's room for some ambiguity.
The expression we're asked to evaluate is =(magnitude z)=, but should this be read =('magnitude z)=?
This is resolved when recalling on p. 184 we have:

#+BEGIN_SRC racket  :tangle no
  (define (magnitude z) (apply-generic 'magnitude z))
#+END_SRC

Our task is to evaluate =(magnitude z)=.
In turn, this amounts to evaluating =(apply-generic 'magnitude z)=.
Putting in the value for =z=, we have:

#+BEGIN_SRC racket  :tangle no
  (apply-generic 'magnitude ('complex ('rectangular (3 4))))
#+END_SRC

Expanded:

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags (map type-tag ('complex ('rectangular (3 4))))))
    (let ((proc (get 'magnitude type-tags)))
	  (if proc
	      (apply proc (map contents ('complex ('rectangular (3 4)))))
	      (error
	       "No method for these types -- APPLY-GENERIC"
	       (list 'magnitude type-tags))))))
#+END_SRC

Recall, the definition of =type-tag= is:

#+BEGIN_SRC racket  :tangle no
  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error " Bad tagged datum -- TYPE-TAG" datum)))
#+END_SRC

So, applying the first =map= we obtain:

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags 'complex))
    (let ((proc (get 'magnitude 'complex)))
	  (if proc
	      (apply proc (map contents ('complex ('rectangular (3 4)))))
	      (error
	       "No method for these types -- APPLY-GENERIC"
	       (list 'magnitude 'complex))))))
#+END_SRC

At this point, Alyssa's procedure is used for the second =let=!

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags 'complex))
    (let ((proc magnitude))
	  (if proc
	      (apply proc (map contents ('complex ('rectangular (3 4)))))
	      (error
	       "No method for these types -- APPLY-GENERIC"
	       (list 'magnitude 'complex))))))
#+END_SRC

As we have a =proc=, we need =contents= for the second =map=.
Here it is:

#+BEGIN_SRC racket  :tangle no
  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error " Bad tagged datum -- TYPE-TAG" datum)))
#+END_SRC

So, we get:

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags 'complex))
    (let ((proc magnitude))
	  (if proc
	      (apply proc ('rectangular (3 4)))
	      (error
	       "No method for these types -- APPLY-GENERIC"
	       (list 'magnitude 'complex)))))
#+END_SRC

So, now our task is to evaluate =(apply proc ('rectangular (3 4)))=.
Where =proc= is =magnitude=.
It's the same problem as above, where evaluating =magnitude= makes results in a call to =apply-generic=.
Alyssa's procedure works because ='complex= is just a wrapper for ='rectangular= and ='polar=.
So, by making a second call to =magnitude= we're effectively ignoring the ='complex= type.
Though, this is only with respect to the version of =magnitude= installed by the complex package.

So, the process starts again!
This time, though, the type is ='rectangular=.
So, the version of =magnitiude= installed by the rectangular package is used.

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags ('rectangular)))
    (let ((proc magnitude))
      (if proc
	  (apply proc (3 4))
	  (error
	   "No method for these types -- APPLY-GENERIC"
	   (list 'magnitude type-tags)))))
#+END_SRC

So, we get to:

#+BEGIN_SRC racket  :tangle no
  (magnitude (3 4))
#+END_SRC

#+BEGIN_SRC racket  :tangle no
  (sqrt (+ (square (real-part (3 4)))
	   (square (imag-part (3 4)))))
#+END_SRC

Here, these functions are internal to the package.
So, we get:

#+BEGIN_SRC racket  :tangle no
  (sqrt (+ (square (car (3 4)))
	   (square (cdr (3 4)))))
#+END_SRC

I.e.

#+BEGIN_SRC racket  :tangle no
  (sqrt (+ (square 3)
	   (square 4)))
#+END_SRC

In total, then, we make two calls to =apply-generic=.

** 2.78

The initial definitions of =type-tag=, =contents=, and =attach-tag= are as follows:

#+BEGIN_SRC racket :tangle no
  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error " Bad tagged datum -- TYPE-TAG" datum)))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS " datum)))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (define (attach-tag type-tag contents)
    (cons type-tag contents))
#+END_SRC

To extend these so the generic system takes advantage of Scheme's interval type system using =symbol?= and =number?= we make use of some =cond= instances.

#+BEGIN_SRC racket :tangle no
  (define (type-tag datum)
    (cond ((pair? datum) (car datum))
	  ((number? datum) ('number))
	  ((symbol? datum) ('symbol))
	  (else error " Bad tagged datum -- TYPE-TAG" datum)))
#+END_SRC


#+BEGIN_SRC racket :tangle no
  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
	  ((number? datum) datum)
	  ((symbol? datum) datum)
	(error "Bad tagged datum -- CONTENTS " datum)))
#+END_SRC

=attach-tag= is a little puzzling.
As specified, =attach-tag= takes a tag argument and contents.
So, there's no room for making use of Scheme's internal type system.
A type must be given!

However, if we reverse the order of arguments, then we can make the type optional.

#+BEGIN_SRC racket :tangle no
  (define (attach-tag contents . type-tag)
    (cond ((number? contents) (cons 'number contents))
	  ((symbol? contents) (cons 'symbol contents))
	  (else (cons type-tag contents))))
#+END_SRC


** 2.79

Or, maybe…

#+BEGIN_SRC racket
  (define (equ? a b)
    (let ((type-a (type-tag a))
	  (type-b (type-tag b)))
      (get 'equ type-a type-b) a b)
#+END_SRC

I don't think this is too interesting.

- We already have a test for ordinary numbers.
- With rational numbers, we probably want to test the reduced form of both number, unless there's a guarantee these numbers have been provided by make-rational.
- Complex numbers will have two cases, depending on the representation.
  As the procedure works on typed objects directly, I'd suggest three procedures.
  On for rectangular, one for polar, and the final for either rectangular or polar.
  The latter, of course, reduces to one of the former, similar to =magnitude=, above.

So, the general structure would be:

#+BEGIN_SRC racket :tangle no
  (define (install-equ-package)
    (define (equ-number a b) (…))

    …

    (put 'equ '(number number) (equ-number))

    …
    )
#+END_SRC

In contrast to the other packages, there's no need to tag the result.
Unless, that is, we like =bool=.

** 2.80

In terms of installing the package, this is no different from the above.
Noting, of course, =zero?= takes a single argumnet.

So, I guess the only interesting thing here is writing the inidivudal functions?

I'll pass on this.

I get the feeling these are exercises designed so something which involves writing code can be assigned in a class.
Perhaps there's something interesting!
But, I think the cost of finding out is too high…


** 2.81

#+BEGIN_SRC racket :tangle no
  (define (apply-generic op . args)
    (let ((type-args (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (if (= (length args) 2)
		(let ((type1 (car type-tags))
		      (type2 (cadr type-tags))
		      (a1 (car args))
		      (a2 (cadr args)))
		  (let ((t1->t2 (get coercion type1 type2))
			(t2->t1 (get coercion type2 type1)))
		    (cond (t1->t2 (apply-generic op (t1->t2 a1) a2))
			  (t2->t1 (apply-generic op a1 (t2->t1 a2)))
			  (else
			   (error "No method for these types" (list op type-tags))))))
		(error "No method for these types" (list op type-tags)))))))
#+END_SRC

Louis observes =apply-generic= may try to coerce the arguemnts to each others type even if they already have the same type.

This certainly happens if there's no procedure for the types in question.
As, coercion is attempted without any further check.

And, as coercion is only attempted if no procedure is found, this is the only way it happens.

So, why not turn the =if= into a =cond= and first check to see whether all the types are the same?

Setting this aside!

*** a.

If we call =exp= with two complex numbers as arguments then we get an error.
=proc= will not be found, and coercion from complex to complex will be attempted.
But, =exp= only has an entry on scheme-numbers, and coercion is only attempted relative to the other argument (of a pair).

*** b.

I think =apply-generic= works as is.


*** c.

Ah, this is what I was thinking before.

Here's a helper function I think I may have written before to check whether every item in a list is the same as a given element.

#+NAME: def:list-of-elem
#+BEGIN_SRC racket
  (define (list-of-elem elm l)
    <<def:accumulate>>
    (accumulate (lambda (x y) (and (equal? x elm) y)) #t l))

  (list-of-elem 0 (list 0 0 0))
#+END_SRC

We use =list-of-elem= see whether all the types given are equal.
As =list-of-elem= takes an arbitrary list, this is done /before/ we limit ourselves to binary operators.

#+BEGIN_SRC racket :tangle no
  (define (apply-generic op . args)
    <<def:list-of-elem>>
    (let ((type-args (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (cond ((= (length args) 0)
		   (error "No arguments given to an operator of arity > 0"))
		  ((list-of-elem (car type-tags) type-tags)
		   (error "No method for this type (for all arguments)" (list op (car type-tags))))
		  ((= (length args) 2)
		   (let ((type1 (car type-tags))
			 (type2 (cadr type-tags))
			 (a1 (car args))
			 (a2 (cadr args)))
		     (let ((t1->t2 (get coercion type1 type2))
			   (t2->t1 (get coercion type2 type1)))
		       (cond (t1->t2 (apply-generic op (t1->t2 a1) a2))
			     (t2->t1 (apply-generic op a1 (t2->t1 a2)))
			     (else
			      (error "No method for these types" (list op type-tags)))))))
		  (else	(error "No method for these types" (list op type-tags))))))))
#+END_SRC


** 2.82

Attempting to coerce arguments to types given isn't ideal.
Sometimes, different type.

For example, scalar multiplication with a rational.

Though, this has it's own problems.
Should the result be a vector of scheme-numbers or of rationals?

Still, nothing here really relies on arguments other than two.

And, the same observation applies to predicates.
For example, =prime?= appplies to rational numbers, as natural numbers are a subset.
But, there's no possible additional argument to obtain the =scheme-number= type from.

So, is there something interesting which happens with more than two arguments?
I'm not sure.
For example, perhaps we have three arguments, and we'd like to coerce the second argumnet to the type of the first argumnet, but leave the type of the third argument as is.
This isn't possible on the current approach, but I can't think of a natural procedure which would have this form.

In any case, a naive approach is to modify the ~(= (length args) 2)~ case.
Instead of working with the two types explicitly, we consider the arity of the operation (e.g. by ~(length type-args)~) and all the types given.
Then, consider all possible permutations of those types which match the arity.

I.e. we'd have a way of getting all permutations.
Then, we'd have a sub-procedure which takes =tpye-args=, the permutation, and the arguments.
The sub-procedure then attempts coercion, and if coercion is possible, returns the result of applying the procedure after coercion.

At this point, there are two things we could do.

First, we could return the first successful coercion.
This makes sense if there's no possibility of coercing things in unexpected ways.

Second, we could collect all the successful coercions.
And, only return a result if all the coercions match.

On the first approach we may end up with either a scheme-number or rational, depending on which coercion was attempted first.
On the latter approach we'd end up with a scheme-number only if there was no coercion which resulted in a rational number.

So, this is all quite open-ended.
At the moment, here's some functions which build up to permuting a list up to some length.

First, a way to prepend an item to everything in a list.

#+NAME: def:prepend-to-all
#+BEGIN_SRC racket
  (define (prepend-to-all item list-of-lists)
    (map (lambda (x) (cons item x)) list-of-lists))
#+END_SRC

Second, an extension to a list of items.

#+NAME: def:prepend-items-to-lists
#+BEGIN_SRC racket
  (define (prepend-items-to-lists items list-of-lists)
    <<def:prepend-to-all>>
    <<def:flatmap>>
    (flatmap ((lambda (x) (lambda (y) (prepend-to-all y x))) list-of-lists) items))
#+END_SRC

#+NAME: def:permute-to-n
#+BEGIN_SRC racket
  (define (permute-to-n l n)
      (define (permute-items-to items list-of-list n)
	<<def:prepend-items-to-lists>>
	(if (= 1 n)
	    list-of-list
	    (permute-items-to l (prepend-items-to-lists items list-of-list) (- n 1))))

      (cond ((= n 0) '())
	    ((= n 1) (map (lambda (x) (list x)) l))
	    (else (permute-items-to l (map (lambda (x) (list x)) l) n))))
#+END_SRC

Quick test:

#+BEGIN_SRC racket
  <<def:permute-to-n>>
  (permute-to-n (list 'a 'b 'c 'd) 0)
  (permute-to-n (list 'a 'b 'c 'd) 1)
  (permute-to-n (list 'a 'b 'c 'd) 3)
#+END_SRC

This is a lot of checking.
Though, if we had direct access to a coercion table things could be improved.
As, we could gather the possible coercions for each argument in a list, and consider all permutations drawing from types in the respective list.
Though, this would require a modified function.

** 2.83

Here we have a simple tower of types:

#+BEGIN_SRC racket :tangle no
  integer => rational => real => complex
#+END_SRC

It's possible to raise a type, as there is always a unique super-type (expect in the case of =complex=).

So, the simplest way to implement a generic raise operation is to use =apply-generic=.
For, this will evaluate =(get 'raise type)=.
Hence, we have:

#+NAME: def:raise
#+BEGIN_SRC racket
  (define (raise exp) (apply-generic 'raise exp))
#+END_SRC

Now, we only need to =put= various procedures.
For example (as n = n/1):

#+BEGIN_SRC racket
  (define (integer-to-rational n) (make-rational n 1))
#+END_SRC

And then:

#+BEGIN_SRC racket
  (put 'raise '(integer) integer-to-rational)
#+END_SRC

This means the hierarchy is spread throughout the code.
So, an alternative method is to store the hierarchy as a list.
Then, given an expression, we use the list to find the relevant transform type.
However, this doesn't lend well to a generic =raise= procedure, as asked for.

** 2.84

It's fairly easy to implement a general method for finding the type of a raised expression.
For example, we can start with:

#+BEGIN_SRC racket
  (define (raised-type exp)
    <<def:raise>>
    (type-tag (raise exp)))
#+END_SRC

Then, substitute this for a generic version of raised-type.

With this, we could keep raising the type of an expression to create a list of the possible raises.
Then, we just need to search for the first match in the lists.

The issue is =raised-type= can't rely on or be generic here.
For, we'll need to figure out a way to see there's no possibility of raising a type any further.
To do this we'd need to observe =raised-type= does not return a type.
But, this will result in an error.

So, implementing =raised-type= via =raise= isn't a good first step.
However, implementing a generic =raised-type= is fine.

#+NAME: def:raised-type
#+BEGIN_SRC racket
  (define (raised-type exp) (apply-generic 'raised-type exp))
#+END_SRC

#+BEGIN_SRC racket
  (define (integer-to-rational-type n) '(rational))
#+END_SRC

We just have many simple procedures.
For example:

#+BEGIN_SRC racket
  (put 'raised-type '(integer) integer-to-rational)
#+END_SRC

Or quick lambdas.
Such as:

#+BEGIN_SRC racket
  (put 'raised-type '(integer) (lambda (x) '(rational)))
#+END_SRC

However, key is the option of returning =nil=.

#+BEGIN_SRC racket
  (put 'raised-type '(complex) nil)
#+END_SRC

With this, we can now reconstruct the heirarchy above a certain type:

#+BEGIN_SRC racket
  (define (get-above-types type)
    (if (null? type)
	nil
	(cons type ((get-above-types (raised-type type))))))
#+END_SRC

This is little more than recursively keeping track of the current type and moving to a super-type before combining everything into a list.

Now, we can find the first match fairly easily.
We know both types are part of a hierarchy, so if we start at the top of the hierarchy, we are sure to have a match.
We can store this, and then continually move down the hierarchy checking for matches.
As soon as a match fails to be found, we've attempted to move to a subtype of one of the types.
Hence, we should return the stored last match.

As a general procedure which works on any two lists, we have something like this:

#+NAME: def:first-match
#+BEGIN_SRC racket
	(define (first-match l1 l2)
	  (define (first-match-reversed l1 l2 previous)
	    (cond
	      ((or (not (pair? l1)) (not (pair? l2))) previous)
	      ((not (equal? (car l1) (car l2))) previous)
	      (else (first-match-reversed (cdr l1) (cdr l2) (car l1)))))
	  (let ((l1R (reverse l1))
		(l2R (reverse l2)))
	    (first-match-reversed l1R l2R nil)))
#+END_SRC

But, we can extend this to work on an arbitrary number of lists in the following way:

#+NAME: def:first-match-lists
#+BEGIN_SRC racket
      (define (first-match-lists lists)
	(define (first-match-reversed lists previous)
	  <<def:accumulate>>
	  <<def:filter>>
	  (cond
	    ((accumulate (lambda (x y) (or (not (pair? x)) y)) #f lists)
	     previous)
	    ((not (= (length lists) (length (filter (lambda (x) (equal? (car x) (car (car lists)))) lists))))
	     previous)
	    (else
	     (first-match-reversed (map cdr lists) (car (car lists))))))
	(first-match-reversed (map reverse lists) nil))
#+END_SRC

The second =cond= condition is a little messy here.
Effectively, we're ensuring the first element of every list is the same.
To do this we filter the list of lists by equality of the first element of the first list and then check to see no lists have been omitted.

Here are some tests:

#+BEGIN_SRC racket
   <<def:first-match-lists>>

  (first-match-lists (list (list 'a 'b 'c 'd) (list 'a 'b 'c 'd)))

  (first-match-lists (list (list 'b 'c 'd) (list 'a 'b 'c 'd)))

  (first-match-lists (list (list 'd) (list 'a 'b 'c 'd)))

  (first-match-lists (list (list 'b 'c 'd) (list )))

  (first-match-lists (list (list ) (list )))

  (first-match-lists (list (list 'a 'b 'c 'd) (list 'b 'c 'd) (list 'c 'd)))

  (first-match-lists (list (list 'a 'b 'c 'd) (list 'b 'c 'd) (list 'c 'd) (list 'd)))
#+END_SRC

Note, by using =first-match= we'll get a return of =nil= if the types do not belong to the same hierarchy.
So, with =apply-generic= we now switch out everything after a test for the same type to include a test for a shared type between all the arguments.
If a shared type is found, then each argumnet is coerced to that type.
Otherwise, no method is available.

It's easy to recusively raise a type so long as we have a guarntee raising is possible, which we do have in this case:

#+BEGIN_SRC racket
  (define (raise-to-type exp type)
    (if (equal? (type-tag exp) type)
	exp
	(raise-to-type (raise exp) type)))
#+END_SRC

So, to finish things off, we raise each type to the shared type.

#+BEGIN_SRC racket :tangle no
  (define (apply-generic op . args)
    <<def:list-of-elem>>
    (let ((type-args (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (cond ((= (length args) 0)
		   (error "No arguments given to an operator of arity > 0"))
		  ((list-of-elem (car type-tags) type-tags)
		   (error "No method for this type (for all arguments)" (list op (car type-tags))))
		  ;; Here, we figure out the shared type.
		  (else (let ((sharedType (first-match-lists (map get-above-types type-args))))
			  if (sharedType)
			  ;; Here we raise each type to the shared type.
			  (apply-generic op (map (lambda (x) (raise-to-type x sharedType)) args))
			  (error "No method for these types" (list op type-tags))
			  )))))))
#+END_SRC


