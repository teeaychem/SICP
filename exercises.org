#+STARTUP: Overview
#+PROPERTY: header-args :noweb eval :results output :tangle tangle.rkt :prologue "#lang sicp"
#+TITLE: SICP Exercises

* Some notes

** Racket and org

To get Racket working inside org-mode I'm using [[https://github.com/hasu/emacs-ob-racket][emacs-ob-racket by hasu]] and [[https://racket-mode.com][racket-mode]].

The relevant part of my emacs config looks like:

: (add-to-list 'load-path "~/path/to/emacs-ob-racket")
: (add-to-list 'org-src-lang-modes '("racket" . racket))
:    (org-babel-do-load-languages
:  'org-babel-load-languages
:  '((racket . t)))

You can run procedures through org mode, or by copying selections from code blocks to a .rkt file.

** code-block syntax

Code blocks are as follows:

: #+NAME:
: #+BEGIN_SRC racket
: wwwww
: #+END_SRC

name is optional etc.

At the start of this file I have:

: #+PROPERTY: header-args :prologue "#lang sicp" :noweb yes :results output

Using :lang scip also works, but the tangled result is the same as prologue

: #+PROPERTY: header-args :lang sicp :noweb yes :results output

** Referenced code-blocks

Exercises in SICP often use code from earlier exercises.

In order to avoid repeat code there are two options:

1. Keep a large file of all previous code.
2. Isolate previous code, but make a call to evaluate it when required.

This document takes the latter option.
However, this introcudes some small issues.

First, we need to name and reference blocks of code.

A nanmed block of code begins with: #+NAME:
To help clarify what's being referenced, a few common prefixes are used:

| def:    | definitions                   |
| sc:     | selectors and/or constructors |
| consts: | constants                     |

A block of code is referenced by <<name>>

The main issue is that a block of code may be evaluated twice if references are made naively, and #lang sicp isn't friendly to redefinition.

So, to avoid this issue, references are inlined when possible.

This is inefficient, and a little messy.

But, I think it's an okay trade-off.




* Chapter 1

** 1.1

#+BEGIN_SRC racket
  10 ;; 10

  (+ 5 3 4) ;; 12

  (- 9 1) ;; 8

  (/ 6 2) ;; 3

  (+ (* 2 4) (- 4 6)) ;; 6

  (define a 3)
  (define b (+ a 1))

  (+ a b (* a b)) ;; 6

  (= a b) ;; #f

  (if (and (> b a) (< b (* a b))) b a) ;; b, as 4 > 3, 4 < 12

  (cond ((= a 4) 6) ;; #f
	((= b 4) (+ 6 7 a)) ;; #t
	(else 25))

  (+ 2 (if (> b a) b a))

  (* (cond ((> a b) a)
	   ((< a b) b)  ;; #t
	   (else -1))
     (+ a 1) ;; 4
     ) ;; (* 4 4) = 16
#+END_SRC

** 1.2

#+BEGIN_SRC racket
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
#+END_SRC

** 1.3

Sum of squares function.
First, compare a and b.
If a >= b fix a, else b.
If a, then compare b and c.
If b, then compare a and c.

#+NAME: def:square
#+BEGIN_SRC racket
      (define (square x) (* x x))
#+END_SRC

#+BEGIN_SRC racket
  (define (sumSquare a b)
    <<def:square>>
    (+ (square a) (square b)))

  (define (twoBig a b c)
    (if
     (>= a b)
     (if (>= b c) (sumSquare a b) (sumSquare a c)) ;: Keeping a
     (if (>= a c) (sumSquare b a) (sumSquare b c)) ;: Keeping b
     ))

  ;; Test possible combinations
  (twoBig 1 2 3)
  (twoBig 2 3 1)
  (twoBig 3 1 3)
#+END_SRC

** 1.4

#+BEGIN_SRC racket
  (define (a-plus-abs-b a b) ;; Define procedure with two arguments
    ((if (> b 0) ;; Operator position is a procedure, so begin by evaluating this.
	 +       ;; Returns + procedure if b > 0, else the - procedure.
	 -) a b))

  (a-plus-abs-b 4 4)   ;; b > 0, so 4 + 4
  (a-plus-abs-b -4 4)  ;; b > 0, so -4 + 4
  (a-plus-abs-b 4 -4)  ;; b < 0, so (4 - -4) = (4 + 4)
  (a-plus-abs-b -4 -4) ;; b < 0, so (-4 - -4) = (-4 + 4) = 0
#+END_SRC

** 1.5

#+BEGIN_SRC racket
  (define (p) (p))

  (define (test x y)
    (if (= x 0)
	0
	y))
#+END_SRC

With applicative-order, start by evaluating test.
test is an if statement, so the predicate is evaluated.
The predicate contains x, so x is evaluated.
0 = 0, so test returns 0.
y / (p) is not evaluated.

With normal-order evluation, start by evaluating test, 0, and (p)
Here, when working through test (p) is substituted in for y.
And, as (p) is a process, it's evaluated.
So, with normal-order, this procedure should fail to terminate.

Key point here is procedure is evaluated first.
In turn, whatever procedure is obtained from this determines which arguments to evaluate.

So, here, first checking whether x or y are 0 would lead to a different result, e.g.

#+BEGIN_SRC racket
  (define (test2 x y)
  (if (or (= x 0) (= y 0)) 0
      (if (= x 0)
          0
          y)))
#+END_SRC

Nothing really changes on good values. If 0 is 0, 0 is returned, else, if 0 is not 0 y is returned, but y is already known to be 0.
Still, in contrast to test we've not got to evaluate y on the first test.
** 1.6

#+BEGIN_SRC racket
  (define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
#+END_SRC

the else-clause evaluated?
For, AOE could be read as saying arguments are only evaluated when applied, and with new-if
it's not clear else-clause is ever *applied*, it's only returned.
And, this should be the case, right.
For, in some cases you can return a procedure, and this wouldn't be possible if you need to
evaluate before returning.

Consider:

#+BEGIN_SRC racket
  (define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))
#+END_SRC

Here, + and - aren't evaluated after the predicate.

But, is it the case that any procedure is automatically evaluated?
I mean, you don't need to call eval explicitly at the top level.

I think this is it.
Any procedure is automatically evaluated.
However, as sqrt-iter is recursive, a new instance of sqrt-iter
is made before any evaluation takes place.
Can see this with rTest

#+BEGIN_SRC racket
(define (rTest x)
	(new-if (> 1 x) 0 (rTest (- x 1))))
(rTest 2)
#+END_SRC

This should terminate fast, but it doesn't.

By contrast, with a call to if, the two options are explicitly
evaluated. So, in a recursive case, as long as the function calls
a conditional which triggers a base case, there's the possibility of
stopping the recursion before it's triggered again.

If this is right, it seems a little subtle for the sixth question...

** 1.7

~good-enough?~ checks to see whether ~abs(guess^2 - target) < 0.001~.

In the case of small numbers, this not very effective and for large number inadequate.
As good-enough? compares two squared numbers, for small values there won't be much of a difference, while for large number there will be a significant difference.

Observe, squares increaes quickly with magnitude.

#+BEGIN_SRC racket
  <<def:square>>
  (- (square 0.5) (square 0.25))
  (- (square 5) (square 2.5))
  (- (square 50) (square 25))
#+END_SRC

So, with very small numbers, it's harder to get a difference less than 0.001, while for very large numbers it's fairly easy.
This means, more precision is needed to get below the threshold in the
small case, where the resulting difference isn't going to be noticable.
And, less precision is needed in the large case.

#+BEGIN_SRC racket
(define (sqrt2 x) (sqrtItr2 1.0 0.0 x))
#+END_SRC

#+BEGIN_SRC racket
  (define (sqrtItr2 guess previousGuess x)
    (if (goodEnough2? guess previousGuess)
	guess
	(sqrtItr2 (improve guess x) guess x)))
#+END_SRC

Mostly the same but for goodEnough2.

#+BEGIN_SRC racket
(define (goodEnough2? guess previousGuess)
  (< (abs (- guess previousGuess)) 0.001))
#+END_SRC

This, then, works as a limit on the number of significant digits we care about.
Alternatively, can apply to (square guess) (square previousGuess), etc.
Then, it's significant digits of the squared number, rather than root.

#+BEGIN_SRC racket
  (define (improve guess x) (average guess (/ x guess)))
#+END_SRC

#+NAME: def:average
#+BEGIN_SRC racket
  (define (average x y) (/ (+ x y) 2))
#+END_SRC

Things are now reversed.
For small numbers, things are less accurate, as the sqrt of a small number is going to be small, and we'll make smaller and smaller changes by taking the average.

** 1.8

Only thing that changes here is the improve function, where formula for better approximation is given.
goodCubeGuess? could also be adjusted, as with previous exercise.

#+NAME: def:cube
#+BEGIN_SRC racket
(define (cube x) (* x x x))
#+END_SRC

#+NAME: def:cubeRt
#+BEGIN_SRC racket
  (define (cubeRt x)
    (define (cubeInt guess) ; Using block structure and lexical scoping
      <<def:cube>>
      (define (goodCubeGuess? guess) (< (abs (- (cube guess) x)) 0.001)) ; Note x from cubeRt.
      (define (cubeImprove guess) (/ (+ (/ x (* guess guess)) (* 2 guess)) 3)) ; And again
      (if (goodCubeGuess? guess)
	  guess
	  (cubeInt (cubeImprove guess))))
    (cubeInt 1.0))
#+END_SRC

#+BEGIN_SRC racket
  <<def:cubeRt>>
  (cube 3)
  (cubeRt 27)
  (cube 2)
  (cubeRt 8)
#+END_SRC

** 1.9

#+BEGIN_SRC racket
  (define (+ a b)
    (if (= a 0)
	b
	(inc (+ (dec a) b))))
#+END_SRC

#+BEGIN_SRC racket :tangle no
(+ 4 5)
(inc (+ (dec a) b))
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc + 0 5))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+END_SRC

Recursive prodecure and recursive process.

#+BEGIN_SRC racket
  (define (+ a b)
    (if (= a 0)
	b
	(+ (dec a) (inc b))))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (+ 4 5)
  (+ (dec 4) (inc 5))
  (+ 3 6)
  (+ 2 7)
  (+ 1 8)
  (+ 0 9)
  9
#+END_SRC

Recursve procedure but iterative process

** 1.10

#+BEGIN_SRC racket :tangle no
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024
#+END_SRC

#+BEGIN_SRC racket :tangle no
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 (A 1 (A 1 1)))))
(A 1 (A 1 (A 1 (A 1 2))))
(A 1 (A 1 (A 1 (A 0 (A 1 1)))))
(A 1 (A 1 (A 1 (A 0 2))))
(A 1 (A 1 (A 1 4)))
(A 1 (A 1 (A 0 (A 1 3))))
(A 1 (A 1 (A 0 (A 0 (A 1 2)))))
(A 1 (A 1 (A 0 (A 0 (A 0 (A 1 1))))))
(A 1 (A 1 (A 0 (A 0 (A 0 2)))))
(A 1 (A 1 (A 0 (A 0 4))))
(A 1 (A 1 (A 0 8)))
(A 1 (A 1 16))
(A 1 (A 0 (A 1 15)))
#+END_SRC

Okay, this grows in a cool way.


#+NAME: def:A
#+BEGIN_SRC racket :results none
(define (A x y)
  (cond
    ((= y 0) 0)
    ((= x 0) (* 2 y))
    ((= y 1) 2)
    (else (A (- x 1) (A x (- y 1))))))
#+END_SRC


#+BEGIN_SRC racket
  <<def:A>>
  (A 1 10)
  (A 2 4)
  (A 3 3)
  (A 2 3)
#+END_SRC

- (A 0 n) is 2n
- (A 1 n) is 2^n
- (A 2 n) is 2^^(n - 1) i.e. if n = 3, 2^2^2, if n = 4 2^2^2^2

** 1.11

#+BEGIN_SRC racket
  (define (fR n)
    (if (< n 3)
	n
	(+ (fR (- n 1))
	   (* 2 (fR (- n 2)))
	   (* 3 (fR (- n 3))))))

  (define (fI n)
    (if (< n 3)
	n
	(fIHelp n 2 1 0)))

  (define (fIHelp current backOne backTwo backThree)
    (if (= 3 current)
	(+ backOne (* 2 backTwo) (* 3 backThree))
	(fIHelp (- current 1) (+ backOne (* 2 backTwo) (* 3 backThree)) backOne backTwo)))

  (define (testfRI n)
    (= (fR n) (fI n)))

  (testfRI 1)
  (testfRI 3)
  (testfRI 12)
  (testfRI 24)
#+END_SRC

** 1.12

Top left is (1,1) then count down and right.
So, first instance of 2 should be (2 3) and 6 should be (3 5)

Basically, define anything negative as 0.
With this anything positive is filled with, (x, y) = ((x - 1, y - 1) + (x, y - 1)).
I.e. look up left and up above – imagine triangle aligned left.
And, the triangle is generated by fixing (1, 1) as 1.

Very ineffective.

#+BEGIN_SRC racket
  (define (pascal x y)
    (cond
      ((or (< x 1) (< y 1)) 0)
      ((and (= x 1) (= y 1)) 1)
      (else (+ (pascal (- x 1) (- y 1)) (pascal x (- y 1))))))

  (pascal 1 1)
  (pascal 2 2)
  (pascal 3 2)
  (pascal 2 3)
  (pascal 3 5)
  (pascal 3 1)
#+END_SRC

** 1.13

It's clear the goal is to show
(phi^n - psi^n)/sqrt(5) = (phi^(n-1) - psi^(n-1))/sqrt(5) + (phi^(n-2) - psi^(n-2))/sqrt(5)
And, it's easy to go the case of 0 and 1 by hand for regular induction.
But, the induction case... no good idea.

Looking things up, I was going to be lost for a while...
Still, I should remember golden ratio is only positive solution to x + 1 = x^2.
And, phi as given is the golden ratio.
So, phi^(n-2) + phi^(n-1) = phi^(n-2)(phi + 1) = phi^(n-2)phi^2 = phi^n.
This hint might have been enough, as after noticing this with phi, it would be natural to to see
if a similar thing holds for psi.
If only I'd looked back to see that the equation was highlighted...

** 1.14

Steps: Theta(2^n)
Space: Theta(n)

count-change works in a very similar way to tree-recursive fibonacci.
For each call of the alogorithm, at most two calls are made.
One call reduces the amount by at least one.
The other changes the coin of interest.
So, we're asked about a function of the amount, but we can view this as a function of
amount + coins, as coins is constant.
Each call reduces amounts + coins by at least one.
So, after one call we have at most n - 1 calls remaining.
Each of these takes a constant number of steps.
We're doing some tests and then performing summation on the results of the two calls.

For space, I'm following the reasoning on p. 38--9.
We only need to keep track of where to return to.
The algorithm is set to brach n times.
So, the depth of the tree is n.
After each call, the number of leaves doubles.
That is, leaves is given by 2(n-1).
Hence, in total the leaves count to 4(n-1).

To be honest, I think this question is asking the reader to recall p. 39.
The number of steps required by a tree-recursive process will be proportional to the number
of nodes in the tree, while the space required will be proportional to the maximum depth.

For space, important thing to keep in mind is this is max space at any given point in time.
We only need to store a reference to the originial call when starting a new call.
So, in general this will use as much space as calls.
But, at any given time only a certain number of nodes will be in play.
In particular, the height of the tree.
For, there's no need (nor way) to explore multiple nodes at the same time.

** 1.15

*** a.

How many times is p applied?
sine is recursive, and evaluated on every call to sine, but need the result of the recursive call
to be applied.
So, we need to check how many times the recursive call is made before the base case is hit.
12.5/3^5 < 0.1.
So, after 5 additional calls the if condition is true.
p is not applied on the sixth call, but is applied on the 5 other calls.

*** b.

Theta(n) for both steps and space.

Steps, as we've got a test and then possible single recursive call.
There's no way to bound this call, and the other steps take constant(ish) time.
So, n.

Space, as the recursive call returns, need to keep track of the original call.
This is some constant(ish) space for each maximum call depth, which is roughly n.

Right, this is a linear recursive process.

** 1.16

Helper function to test for even

#+NAME: def:even?
#+BEGIN_SRC racket
  (define (even? n)
    (= (remainder n 2) 0))
#+END_SRC

Main fuction, following the hint

#+NAME: def:try
#+BEGIN_SRC racket
  (define (try a b n) ; a is current value, n is number of exponents remaining
     <<def:even?>>
     (cond
       ((= n 0) a)
       ((even? n)  (try a (* b b) (/ n 2))) ; So long as n is even, reduce remaing by half by squaring current.
       ; This is b^n = (b^2)^(n/2)
       ; As input, do a^n
       ; As output, a = a^2, still need a^(n/2)
       (else (try (* a b) b (- n 1)))))
#+END_SRC

#+NAME: def:expItr
#+BEGIN_SRC racket
  (define (expItr b n)
    <<def:try>>
    (try 1 b n)) ; Hide a as a helper variable.
#+END_SRC

#+BEGIN_SRC racket
  <<def:expItr>>
  (expItr 2 4)
  (expItr 6 5) ; Expect 7776
  (expItr 7 1) ; Expect 7
  (expItr 15 3) ; Expect 3375
  (expItr 15 0) ; Expect 1
#+END_SRC

** 1.17

Using ~(* 2 x)~ for ~(double x)~ and ~(/ x 2)~ for ~(half x)~.

dhMultH, only works for positive integers.
So, dhMult ensures positive numbers are passed through, and adjusts the result appropriately.

#+NAME: def:multPositiveTranslate
#+BEGIN_SRC racket
(define (multPositiveTranslate func a b)
  ((if (> 0 b) + -) 0 ((if (> 0 a) + -) 0 (func (abs a) (abs b)))))
#+END_SRC

#+NAME: def:dhMult
#+BEGIN_SRC racket
  (define (dhMultH a b)
    (cond
      ((> 0 b) (- 0 (dhMultH a (- 0 b))))
      ((= b 0) 0) ; 0 base case, return 0.
      ((= b 1) a) ; positive base case, return a.
      ((even? b) (* 2 (dhMultH a (/ b 2)))) ; Double whatever I get from halving multiplication to do.
      (else (+ a (dhMultH a (- b 1)))) ; Add b to whatever I get from reducing multiplication by one.
      ))

  (define (dhMult a b)
    <<def:multPositiveTranslate>>
    (multPositiveTranslate dhMultH a b))
#+END_SRC


#+BEGIN_SRC racket
  <<def:dhMult>>
  ;(dhMult 1 4)
  ;(dhMult 5 5)
  (dhMult 5 -8)
  (dhMult 5 8)
  (dhMult 5 -7)
  (dhMult 5 7)
  (dhMult 5 0)
  (dhMult -6 6)
  (dhMult -5 -5)
#+END_SRC

** 1.18


Calculate m * n.
Do this iteratively by doubling m and havling n.
When n is odd, copy the value of m to a store variable, added at the end.
Always go to n = 1, so add m to store variable.

#+NAME: def:dhMultIter
#+BEGIN_SRC racket
  (define (dhMultIterHelp a m n)
      (cond
	((= n 0) a)
	((even? n) (dhMultIterHelp a (* m 2) (/ n 2))) ;
	(else (dhMultIterHelp (+ a m) m (- n 1)))))

    (define (dhMultIterPos m n)
      (dhMultIterHelp 0 m n))

    (define (dhMultIter m n)
      <<def:multPositiveTranslate>>
      (multPositiveTranslate dhMultIterPos m n))
#+END_SRC

Some tests

#+BEGIN_SRC racket
  <<def:dhMultIter>>
  (dhMultIter 2 6)
  (dhMultIter 3 5)
  (dhMultIter 3 0)
  (dhMultIter 0 5)
  (dhMultIter 3 14)
#+END_SRC

** 1.19

Two applications of T_pq reduce to a single application of
a <- b(2pq + q^2) + (2pq + q^2) + a(p^2 + q^2)
b <- b(p^2) + a(2pq + q^2)

So, applied twice we have something of the same form, where:
new_q = (2pq + q^2)
new_p = (p^2)

With this in mind, finishing the function is simple, to double the values of
p and q, apply this transformation to itself.

#+NAME: def:fibI
#+BEGIN_SRC racket
  (define (fibI n)
    (fib-iter 1 0 0 1 n))

  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
	  ((even? count)
	   (fib-iter a
		     b
		     (+ (* p p) (* q q))
		     (+ (* p q) (* q q) (* q p))
		     (/ count 2)))
	  (else (fib-iter (+ (* b q) (* a q) (* a p))
			  (+ (* b p) (* a q))
			  p
			  q
			  (- count 1)))))
#+END_SRC

Testing

#+BEGIN_SRC racket
  <<def:fibI>>
  (fibI 0)
  (fibI 1)
  (fibI 2)
  (fibI 3)
  (fibI 4)
#+END_SRC

** 1.20

#+NAME: def:gcd
#+BEGIN_SRC racket
  (define (gcd a b)
    (if (= b 0)
	a
	(gcd b (remainder a b))))
#+END_SRC


(206 40)
(40 6)
(6 4)
(4 2)
(2 0)

The main operator of gcd is a conditional, and as described the condition of a conditional is
evaluated before either result is evaluated.
So, the remainder operations actually performed equal the number of times gcd is called, minus one.
For, on the last call (= b 0), which goes to a.

Or I'm missing something, but it seems the conditional must work in this way.
Normal order reduces everything to a primitive form.
But, with a recursive function like gcd a 'synthetic' primative form is needed.
For, otherwise, and additional call to gcd is always possible.

With all this in mind, given the flow is determined by a conditional, normal and evaluative order should be the same here.

** 1.21


A little before.
If d is a divisor of n, then so is n/d.
Proof for this seems easy by contradicition.
To show d divides n, just need an int such that d * a = n.
Consider n/d.
As d is a divisor of n, so n/d is an int, and clearly d * n/d = n.

#+NAME: def:divides?
#+BEGIN_SRC racket
  (define (divides? a b)
    (= (remainder b a) 0))
#+END_SRC

#+NAME: def:smallest-divisor
#+BEGIN_SRC racket
  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    <<def:divides?>>
    <<def:square>>
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (+ test-divisor 1)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:smallest-divisor>>
  (smallest-divisor 199)
  (smallest-divisor 1999)
  (smallest-divisor 19999)
#+END_SRC

? ? ? What is the purpose of this?

** 1.22

#+NAME: def:prime?
#+BEGIN_SRC racket
  (define (prime? n)
    <<def:smallest-divisor>>
    (= n (smallest-divisor n)))
#+END_SRC


#+NAME: def:search-for-primes
#+BEGIN_SRC racket
  (define (timed-prime-test n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    <<def:prime?>>
    (if (prime? n)
	(report-prime n (- (runtime) start-time))))

  (define (report-prime n elapsed-time)
    (newline)
    (display n)
    (display " *** ")
    (display elapsed-time))

  (define (prime-test-range-k-step n m k)
    (cond ((> n m)
	   (display " finished "))
	  (else
	   (timed-prime-test n)
	   (prime-test-range-k-step (+ n k) m k))))

  (define (search-for-primes n m)
    (prime-test-range-k-step (if (even? n) (+ n 1) n) (if (even? m) (- m 1) m) 2))
#+END_SRC

#+BEGIN_SRC racket
  <<def:search-for-primes>>
  (search-for-primes 1 100000)
#+END_SRC

Well, it takes a little longer, but things happen too fast to really test sqrt(n).
And, any significant deviation from average is probs. a scheduling thing.

** 1.23

#+BEGIN_SRC racket
(define (next n)
  (if (= n 2) 3 (+ n 2)))
#+END_SRC

#+BEGIN_SRC racket
(define (find-divisor-next n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor-next n (next test-divisor)))))
#+END_SRC

#+BEGIN_SRC racket
(define (smallest-divisor-next n)
  (find-divisor-next n 2))
#+END_SRC

#+BEGIN_SRC racket
(search-for-primes 1 100000)
#+END_SRC

The speed-up going to 100000 is significant.
Around 2~3 times as fast at the end tail.

** 1.24

#+BEGIN_SRC racket
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m)) m))
        (else
         (remainder (* base (expmod base (- exp 1) m)) m))))
#+END_SRC

#+BEGIN_SRC racket
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n ) a))
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC

#+BEGIN_SRC racket
(define (fast-prime? n times)
(cond ((= times 0) true)
      ((fermat-test n) (fast-prime? n (- times 1)))
      (else false)))
#+END_SRC

Again, timing isn't particularly easy here.
I'd expect 1,000,000 to not take too much more time than 1000, as we have Theta(long n) growth.

** 1.25

With expmod we have a way of figuring out the exponential of a number modulo another number (with Theta(log n) growth).
So, roughly remainder(base^exp / m).
The way this works is to figure out base^exp and then task the remainder at each call.
Difference is where remainder is called.
As given, we take remainder before squaring resut, in the even case.
So, this should make a differnece, at least in principle.
As, both remainder and square take time, and depending on the way things go, could lead to m long n growth.
But, presumably as the argument is kept small, this growth is 'hidden' behind the growth of the exponent.

As footnote 46 points out, the position of remainder ensures the numbers dealt with are not much larger than m.

By contrast, for the proposed expmod, we for sure need to consider the growth of remainder.
If it's n, then we have n + long n = n.

Though, I can't find much about the cost of remainder in the text.

** 1.26

With explicit multiplication, there are now two calls to expmod on each recursive call.
So, we've effectively doubled the amount of work. (log n)^2 = n.

With square, by contrast, the result of expmod is evaluated and then passed to the fuction.
The evaluated value is used twice, but the evaluation only happens once.

** 1.27

#+NAME: def:carmichael-fool
#+BEGIN_SRC racket
  (define (carmichael-fool n)
    (hidden-fool (- n 1) n))

  (define (hidden-fool b n)
    <<def:expItr>>
    (cond ((= b 0) (display " fooled "))
	  ((= (remainder (expItr b n) n) (remainder b n)) (hidden-fool (- b 1) n))
	  (else (display " found "))))
#+END_SRC


#+BEGIN_SRC racket
  <<def:carmichael-fool>>
  (carmichael-fool 561)
  (carmichael-fool 1105)
  (carmichael-fool 1729)
  (carmichael-fool 2465)
  (carmichael-fool 2821)
  (carmichael-fool 6601)
  (carmichael-fool 6600)
  (carmichael-fool 6602)
#+END_SRC

** 1.28

Modifying expmod to signal whether it discovers a non-trivial square root of 1.

An important detail was a little buried.
For, the test is only guaranteed for odd numbers.
So, when working through half of the numbers, we need to already be sure the number is odd.

Added some formatting, though ofc I should have a single call for n/prime display.

#+BEGIN_SRC racket
  (define (MR-expmod base exp m) ; base = a, exp = n
    <<def:square>>
    (cond ((= exp 0) 1)
	  ((even? exp)
	   (remainder (square (MR-check-sqaure (MR-expmod base (/ exp 2) m) m)) m))
	  (else (remainder (* base (MR-expmod base (- exp 1) m)) m))))

  (define (MR-check-sqaure a m)
    <<def:square>>
    (cond
      ((or (= a 1) (= a (- m 1))) a) ; In this case, a is trivial, so continue
      ((= (remainder (square a) m) 1) 0) ; We know a != 1 nor (m - 1), so check a % n = 1. Not prime if satisfied.
      (else a))) ; Otherwise, continue

  (define (MR-seq-test n a)
    (cond
      ((> a (/ n 2)) (display "Prime!\n"))
      ((= (MR-expmod a (- n 1) n) 0) (display "Not prime…\n"))
      (else (MR-seq-test n (+ a 1)))))


  (define (MR-prime? n)
    (display "Checking: ")
    (display n)
      (display "\n")
    (cond
      ((= n 2) (display "Prime!\n"))
      ((even? n) (display "Not prime…\n"))
      (else (MR-seq-test n 1))))

  (MR-prime? 2)
  (MR-prime? 3)
  (MR-prime? 4)
  (MR-prime? 7)
  (MR-prime? 9)
  (MR-prime? 10)
  (MR-prime? 11)
  (MR-prime? 12)
#+END_SRC

** 1.29

#+NAME: def:sum
#+BEGIN_SRC racket
  (define (sum term a next b)
    (if (> a b)
	0
	(+ (term a)
	   (sum term (next a) next b))))
#+END_SRC

#+NAME: def:inc
#+BEGIN_SRC racket
  (define (inc n) (+ n 1))
#+END_SRC

#+BEGIN_SRC racket
  (define (simpson f a b n)
    <<def:sum>>
    <<def:inc>>
    (define (sM k x)
      (cond
	((or (= k 0) (= k n)) x)
	((even? k) (* 2 x))
	(else (* 4 x))
	))
    (define (h) (/ (- b a) n))
    (define (fakh k) (sM k (f (+ a (* k (h))))))
    (* (/ (h) 3) (sum fakh 0 inc n)))

  <<def:cube>>

  (simpson cube 0 1 1000.0)
  (simpson cube 0 1 10000.0)
#+END_SRC

Well, the results are closer to 1/4…

** 1.30

#+NAME: def:sum-iter
#+BEGIN_SRC racket
  (define (sum-iter term a next b)
    (define (iter a result)
      (if (> a b)
	  result
	  (iter (next a) (+ (term a) result))))
    (iter a 0))
#+END_SRC

#+BEGIN_SRC racket
  <<def:sum-iter>>
  <<def:cube>>
  (sum-iter cube 0 inc 10)
#+END_SRC

** 1.31

*** a.

#+NAME: def:product
#+BEGIN_SRC racket
(define (product term a next b)
  (if (> a b)
      1
      (* (term a)
         (product term (next a) next b))))
#+END_SRC


This is just substituting * for +…
And factorial works with identiy and inc.

#+BEGIN_SRC racket
  (define (factorial n)
    <<def:product>>
    (product identity 1 inc n))
#+END_SRC


#+BEGIN_SRC racket
  (define (piHelpB d)
    <<def:square>>
    (/ (* (- d 1) (+ d 1)) (square d)))

  (define (incTwo n) (+ n 2))

  (define (piClose n)
    <<def:product>>
    (* 4.0 (product piHelpB 3 incTwo (+ n 3))))

  (piClose 500)
#+END_SRC

Use the numerator as the index, and work through pairs of denominators.

Either I've done something wrong, on this takes a lot to get close to pi.

*** b.

#+NAME: def:product-iter
#+BEGIN_SRC racket
(define (product-iter term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))
#+END_SRC

** 1.32



Made both versions, then read part b…

#+NAME: def:accumulate-first
#+BEGIN_SRC racket
(define (accumulate-first combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
         (accumulate-first combiner null-value term (next a) next b))))
#+END_SRC

#+NAME: def:accumulate-first-iter
#+BEGIN_SRC racket
  (define (accumulate-first-iter combiner null-value term a next b)
    (define (iter a result)
      (if (> a b)
	  result
	  (iter (next a) (combiner (term a) result))))
    (iter a null-value))
#+END_SRC


E.g.…

#+BEGIN_SRC racket
  (define (sum-accumulate-first term a next b)
    <<def:accumulate-first>>
    (accumulate-first + 0 term a next b))
#+END_SRC

To test, adapt previous use of sum/product.
Replace accumalate with accumalate-iter to vary recu/iter.

#+BEGIN_SRC racket
;; (sum-iter cube 0 inc 10)
;; (sum-accumulate-first cube 0 inc 10)
#+END_SRC

** 1.33

#+NAME: def:filtered-accumulate-first
#+BEGIN_SRC racket

(define (filtered-accumulate-first filter combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (if (filter a) (term a) null-value)
                (filtered-accumulate-first filter combiner null-value term (next a) next b))))
#+END_SRC

If the filter is satisfied, then combine (term a), otherwise combine via the null-value.

*** a.

#+BEGIN_SRC racket
  (define (sum-square-prime a b)
    <<def:filtered-accumulate-first>>
    <<def:prime?>>
    (filtered-accumulate-first prime? + 0 square a inc b))

  (sum-square-prime 1 10)
#+END_SRC

*** b.

#+BEGIN_SRC racket
  (define (sum-relatively-prime n)
    <<def:filtered-accumulate-first>>
    (define (predicate? a)
      (= (gcd a n) 1))
    (filtered-accumulate-first predicate? * 0 identity 0 inc n))

  (sum-relatively-prime 20)
#+END_SRC

No test values for this, but at least here I have a nice example of blocking the predicate.

** 1.34

#+BEGIN_SRC racket
  (define (f g) (g 2))

  (f square)
  (f (lambda (z) (* z (+ z 1))))
#+END_SRC

We apply 2 to 2.
With f labelled
(f1 f2) - > (f2 2) -> (2 2)
But, 2 isn't a procedure.

** 1.35


From p. 38 we have the golden ratio is (1 + sqrt(5))/2.
Let φ = (1 + sqrt(5))/2.
And, we know φ^2 = φ + 1.

To figure out how to express φ as a fixed point of x, we'll work through x = φ until we have a non-trivial transformation of x on the rhs.
So:

#+BEGIN_SRC racket
  x = φ
  x^2 = φ^2 \ Algebra
  x^2 = φ + 1 \ Given
  x^2 = x + 1 \ Initial equality.
  x = (x + 1)/x \ Algebra
  x = (x/x + 1/x) \ Algebra
  x = (1 + 1/x) \ Algebra
#+END_SRC

#+NAME: def:fixed-point
#+BEGIN_SRC racket
  (define (fixed-point f first-guess tolerance)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
    (try first-guess))
#+END_SRC

#+BEGIN_SRC racket
  <<def:fixed-point>>
  (display "φ is roughly: ")
  (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0 0.0000001)
#+END_SRC

** 1.36

#+BEGIN_SRC racket
(define (fixed-point-display f first-guess tolerance)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess guess-number)
    (let ((next (f guess)))
      (display "Guess: ")
      (display guess-number)
      (display " is: ")
      (display guess)
      (newline)
      (if (close-enough? guess next)
          next
          (try next (+ guess-number 1)))))
  (try first-guess 1))

(fixed-point-display (lambda (x) (/ (log 1000) (log x))) 20 0.0001)
#+END_SRC

** 1.37

*** a.

#+NAME: def:cont-frac
#+BEGIN_SRC racket
  (define (cont-frac n d k)
    (define (cont-frac-i n d k step)
      (if (= step k)
	  (/ (n step) (d step))
	  (/ (n step) (+ (d step) (cont-frac-i n d k (+ step 1))))))
    (cont-frac-i n d k 1))
#+END_SRC

#+BEGIN_SRC racket
  <<def:cont-frac>>
  (cont-frac (lambda (i) 1.0)
	     (lambda (i) 1.0)
	     11)
#+END_SRC

Looks as though k = 11 works for 4 decimal places.
1/φ = 0.6180339887498948482045868343656381177203091798057628621354486227…

*** b.

cont-frac is recursive, so for an iterative version…
Start the other way.
Do N_k/D_k and then work backwards.

#+BEGIN_SRC racket
(define (cont-frac-iter n d k)
  (define (cont-frac-i n d k so-far)
    (if (= k 0)
        so-far
        (cont-frac-i n d (- k 1) (/ (n k) (+ (d k) so-far)))))
  (cont-frac-i n d k 0))

(cont-frac-iter (lambda (i) 1.0)
                (lambda (i) 1.0)
                11)
#+END_SRC

** 1.38

There's nothing here other than figuring out a way to generate the desired sequence for Dk.
So, here's something excessive.

#+BEGIN_SRC racket
  <<def:cont-frac>>
  (define (dk i)
    (let ((x (- i (/ i 3))))
      (if (= (- x (floor x)) (/ 1 3))
	  (ceiling x)
	  1)))

  (+ 2 (cont-frac (lambda (x) 1.0) dk 200))
#+END_SRC

e = 2.7182818284590452353602874713526624977572470936999595749669676277…

** 1.39


Modify cont-frac.
n is constant x^2.
d is number variable, given as argument.
And, offset things a little.

At start, calculate x^2 to save some resources.
Then, work through offset cont-frac k times.

#+BEGIN_SRC racket
  (define (tan-cf x k)
    <<def:square>>
    (define (cont-frac-i x2 d k step)
      (if (= step k)
	  (/ x2 d)
	  (/ x2 (- d (cont-frac-i x2 (+ d 2) k (+ step 1))))))
      (let ((x2 (square x)))
	(/ x (- 1 (cont-frac-i x2 3 k 1)))))

    (tan-cf 1.0 10.0)
#+END_SRC

** 1.40

#+NAME: def:deriv
#+BEGIN_SRC racket
(define (deriv g)
  (let ((dx 0.00001))
    (lambda (x)
           (/ (- (g (+ x dx)) (g x))
              dx))))
#+END_SRC

#+NAME: def:newton-transform
#+BEGIN_SRC racket
  (define (newton-transform g)
    <<def:deriv>>
    (lambda (x) (- x (/ (g x) ((deriv g) x)))))
#+END_SRC

#+BEGIN_SRC racket
  (define (newtons-method g guess)
    <<def:newton-transform>>
    <<def:fixed-point>>
    (fixed-point (newton-transform g) guess 0.0000001))
#+END_SRC

#+BEGIN_SRC racket
  (define (cubic a b c)
    (define (cubic-all x a b c)
      <<def:square>>
      <<def:cube>>
      (+ (cube x) (* a (square x)) (* b x) c))
    (lambda (x) (cubic-all x a b c)))
  ;; (lambda (x)
  ;;   (+ (cube x) (* a (square x)) (* b x) c)
  ;;   ))
#+END_SRC

Here, just constructing a function.
There's two options.
First (as taken), define the general function, and then obtain a particular instance.
Second, directly define a particular instance (as commented).

** 1.41

#+BEGIN_SRC racket
(define (double f) (lambda (x) (f (f x))))

((double inc) 2)
(((double (double double)) inc) 5)
#+END_SRC

** 1.42

#+BEGIN_SRC racket
(define (compose f g) (lambda (x) (f (g x))))

((compose square inc) 6)
#+END_SRC

** 1.43

#+BEGIN_SRC racket
(define (repeated f times)
    (if (= times 1)
        f
        (compose f (repeated f (- times 1)))))

((repeated square 2) 5)
#+END_SRC

This is a little surprising.
For, the most natural base case is f x.
With this, completing recursive calls gets f^n x.
And, as a last step take λ x f^n x, or just leave the procedure as it is.

But, this isn't okay, as x dones't evaluate to anything.

So, instead, the base case is f.
The argument is not made explicit, so there's no issue of evaluting it.
We just return the procedure.

So, mabye it's not *that* strange.
With f x we are working with some arbitrary value, and as this is arbitrary, what we're doing is transformed into a procedure.
And, with f we are working with a procedure directly.

Hm.

** 1.44

#+BEGIN_SRC racket
(define (smoothed f dx)
  (lambda (x)
    (/ (+ (f x) (f (+ x dx)) (f (- x dx))) 3)))


(define (smooth-fold f dx n)
  ((repeated (lambda (x) (smoothed x dx)) n) f))
#+END_SRC


Nothing too exciting here.
We repeat the smoothing, and then apply this to the function.
(Repeating smoothing applied to the function would involve repeating the function.)
lambda lets us do this easily, though I guess it would also be easy if dx was fixed as a constant somewhere.

** 1.45

Average-damp(f(x)) = (x + f(x))/2

e.g. Average-damp(10^2) = 55 = (10 + 100)/2

In general, fixed point fails without dampening as y -> x/y -> x/(x/y) -> y
Then, y -> (x + x/y)/2.

In any case, this exercise seems rough.
We're asked to experiment to find out how many average damps are required to compute nth roots as a fixed-point search.
The problem is failure to converge, though.
Of course, things are a little better.
For, the general form of the problem is re-obtaining the initial value, or at least a prior value.
So, it's in principle possible to store every value computed and then check to see if any of these are repeated.
Still, it's not very interesting.

The final function isn't too interesting either.
Once the required number of times to average damp is figured out, the next task is to repeatedly average damp the function, and then apply the fixed point solver to this.

** 1.46

In outline, a conditional:

if (good? guess) guess (improve guess)

So, here, the only issue is obtaining the guess.
But, this is two lambda terms.
lambda f lambda x (f x)

#+NAME: def:iterative-improve
#+BEGIN_SRC racket
(define (iterative-improve good? improve)
  (lambda (guess) (if (good? guess)
      guess
      ((iterative-improve good? improve) (improve guess)))))
#+END_SRC

To help make things clear, a couple of let statements to define the relevant procedures.
Then, call iterative-improve.
Here, 1 could be anything – it's just a first guess.

#+NAME: def:iiSqrt
#+BEGIN_SRC racket
  (define (iiSqrt x)
    <<def:square>>
    <<def:average>>
    <<def:iterative-improve>>
    (let (
	  (good? (lambda (guess) (< (abs (- (square guess) x)) 0.001)))
	  (improve (lambda (guess) (average guess (/ x guess)))))
      ((iterative-improve good? improve) 1)))
#+END_SRC

Some tests

#+BEGIN_SRC racket
  <<def:iiSqrt>>
  (iiSqrt 4.0)
  (iiSqrt 16.0)
  (iiSqrt 125.0)
#+END_SRC

#+NAME: def:iiFixed-Point
#+BEGIN_SRC racket
  (define (iiFixed-Point f)
    <<def:iterative-improve>>
    (let ((good? (lambda (guess) (< (abs (- (f guess) guess)) 0.00001)))
	  (improve (lambda (guess) (f guess))))
      ((iterative-improve good? improve) 1)))
#+END_SRC

A couple of funcs from 1.3.3 (p. 69) for testing

#+BEGIN_SRC racket
  <<def:iiFixed-Point>>
  (iiFixed-Point cos)
  (iiFixed-Point (lambda (y) (+ (sin y) (cos y))))
#+END_SRC


* Chapter 2

** 2.1

#+NAME: def:numer
#+BEGIN_SRC racket
    (define (numer x) (car x))
#+END_SRC

#+NAME: def:demon
#+BEGIN_SRC racket
  (define (demon x) (cdr x))
#+END_SRC

Not particularly elegant.
Though, cheeky λ to avoid calculating (* n d) twice.
Note, doing (define (mult) (* n d)) wouldn't be any help, as this would just call the multiplcation.

#+NAME: def:make-rat-basic
#+BEGIN_SRC racket
  (define (make-rat-basic n d)
    (let ((sign ((lambda (x) (/ x (abs x))) (* n d))))
      (cons (* sign (abs n)) (abs d))))
#+END_SRC

It's not possible to always reference a let constant from another let constant.
This kind of makes sense to me.
At some point, need to make the reference happen.
This way, reference isn't assumed to be sequential, nor does one need to track dependencies.


#+BEGIN_SRC racket
(define (make-rat-basic-x n d)
  (let ((mult (* n d))
        (sign (/ mult (abs mult))))
    (cons (* sign (abs n)) (abs d))))
#+END_SRC

make-rat as defined in the book already does this.
But, it's due to a bug in gcd.
For, gcd(2, -3) = 1.
Yet, (gcd 2 -3) = -1.
And, in general, given (gcd a b), if a is positive and b is negative, then the result is negative.
Otherwise, the result has the sign of a.

#+NAME: def:make-rat
#+BEGIN_SRC racket
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
#+END_SRC

In the book, newline is first, but newline last fits with previous displays.

#+NAME: def:print-rat
#+BEGIN_SRC racket
  (define (print-rat x)
    <<def:numer>>
    <<def:demon>>
    (display (numer x))
    (display "/")
    (display (demon x))
    (newline))
#+END_SRC

#+BEGIN_SRC racket
  <<def:print-rat>>
  <<def:make-rat-basic>>
  <<def:make-rat>>

  (print-rat (make-rat-basic -2 -3))
  (print-rat (make-rat-basic -2 3))
  (print-rat (make-rat-basic 2 3))
  (print-rat (make-rat-basic -2 3))

  (print-rat (make-rat -2 -3))
  (print-rat (make-rat 2 -3))
  (print-rat (make-rat 2 3))
  (print-rat (make-rat -2 3))
#+END_SRC

** 2.2

#+NAME: sc:point
#+BEGIN_SRC racket
  (define (make-point x y) (cons x y))

  (define (x-point point) (car point))

  (define (y-point point) (cdr point))
#+END_SRC

#+BEGIN_SRC racket
  <<sc:point>>
  (x-point (make-point 1 2))
  (y-point (make-point 1 2))
#+END_SRC

#+NAME: sc:segment
#+BEGIN_SRC racket
  <<sc:point>>
  (define (make-segment start-point end-point) (cons start-point end-point))

  (define (start-segment segment) (car segment))

  (define (end-segment segment) (cdr segment))

  (define (midpoint-segment segment)
    (make-segment
     (/ (+ (x-point (start-segment segment)) (x-point (end-segment segment))) 2)
     (/ (+ (y-point (start-segment segment)) (y-point (end-segment segment))) 2)))
#+END_SRC

#+BEGIN_SRC racket
  <<sc:segment>>
  (midpoint-segment (make-segment (make-point 2 2) (make-point 4 4)))
  (midpoint-segment (make-segment (make-point -4 -8) (make-point 4 4)))
#+END_SRC

Though, I think this should be a little more general.
With a coordinate space, there's no limit on the dimension.
So, rather than having distinct x and y selectors, there should be a general selection which takes the dimension as an argument.
Then, it's easy to expand everything, given some way to test wether the dimension is stored.
Though, at this point in the book the problem is lists.
We only have pairs.

** 2.3

For a rectangle, there's a few ways to do this.
Though, point for origin and rationals for legnth and width seems most straightforward.

A rectange is stored as ((origin-x origin-y) (width height))

#+NAME: sc:rectangle
#+BEGIN_SRC racket
(define (make-rectangle origin width height)
  (cons origin (cons width height)))

(define (rectangle-origin rectangle)
  (car rectangle))

(define (rectangle-width rectangle)
  (car (cdr rectangle)))

(define (rectangle-height rectangle)
  (cdr (cdr rectangle)))
#+END_SRC


Not sure what is meant by perimeter here.
Length of the perimeter is… not very interesting.
Points to construct the perimeter is a little better.
So, that's what the following procedure does.
Points are enumerated clockwise starting with 1 as top-left going to 3 as bottom-left.

#+NAME: def-rectangle-perimeter
#+BEGIN_SRC racket
  (define (rectangle-perimeter rectangle point)
    <<sc:rectangle>>
    <<sc:point>>
    (if (= point 0)
	(rectangle-origin rectangle)
	(let ((xPoint (x-point (rectangle-origin rectangle)))
	      (yPoint (y-point (rectangle-origin rectangle))))
	  (cond
	    ((= point 1) (make-point (+ xPoint (rectangle-width rectangle)) yPoint))
	    ((= point 2) (make-point (+ xPoint (rectangle-width rectangle)) (+ yPoint (rectangle-height rectangle))))
	    ((= point 3) (make-point xPoint (+ yPoint (rectangle-height rectangle))))))))
#+END_SRC

#+BEGIN_SRC racket
  (define (rectangle-area rectangle)
    <<sc:rectangle>>
    (* (rectangle-width rectangle) (rectangle-height rectangle)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:rectangle-perimeter>>
  (define test-rect (make-rectangle (make-point 5 10) 15 10))
  (rectangle-origin test-rect)
  (rectangle-width test-rect)
  (rectangle-height test-rect)
  (rectangle-perimeter test-rect 2)
#+END_SRC

The representation of the rectangle doesn't matter, so long as there's selectors for origin, width, and height.

And, I can't think of an interesting alterantive representation.
Could take the center point.
The only thing here is origin is given by center.x - width/2, etc.

Could also take two points.
Say, top left and bottom right.
Then, origin is top left, and width is obtained from top right.x - bottom left.x in the positive case.

** 2.4

(car (cons x y)) = λm (m x y) (λ (p q) p)
                 = (λ (p q) p) x y
                 = x

for cdr

(define (cdr z)
(z (lambda (p q) q)))

So:

(cdr (cons x y)) = λm (m x y) (λ (p q) p)
                 = (λ (p q) q) x y
                 = y

** 2.5

To pair the numbers use any exponentiation procedure which takes base and exponent arguments.

To break apart the number, keep dividing by either 2 or 3 until no further integer division is possible.

I'd guess there's some trick with log here, but I don't see it quickly.

#+BEGIN_SRC racket
  (define (break-down pair n)
    (define (break-down-i pair n m)
      (if (not (= 0 (remainder pair n)))
	  m
	  (break-down-i (/ pair n) n (+ m 1))))
    (break-down-i pair n 0))

  (define (pair-numbers a b)
    <<def:expItr>>
    (* (expItr 2 a) (expItr 3 b)))

  (define (pair-number-a pair) (break-down pair 2))
  (define (pair-number-b pair) (break-down pair 3))

  ; Basic test
  (pair-number-a (pair-numbers 32 94))
  (pair-number-b (pair-numbers 32 94))

  ; Some edge cases.
  (pair-number-a (pair-numbers 1 1))
  (pair-number-b (pair-numbers 1 0))
#+END_SRC

Note, only asked to do with for non-negative integers.

** 2.6

So…

$0 = \lambda f \lambda x x$

$1 = \lambda f \lambda x f x$

$2 = \lambda f \lambda x ff x$


#+BEGIN_SRC racket
  (define one (lambda (f) (lambda (x) (f (x)))))
  (define two (lambda (f) (lambda (x) (f (f (x))))))
#+END_SRC

Okay, not allowed to apply repeat to add-1.

Still, this is just a variation on add-1.

#+BEGIN_SRC racket
  (define (add n m)
    (lambda (f) (lambda (x) (f (n f) ((m f) x)))))
#+END_SRC

Instead of ~x~, we have ~((m f) x)~.
~m~ is of the form $\lambda f \lambda x f^{m} x$.
So, ~((m f) x)~ is of the form $f^{m} x$.
~n~ is of the form $\lambda f \lambda x f^{n} x$.
So, ~(n f)~ is of the form $\lambda x f^{m} x$.
Hence, ~(f (n f) ((m f) x))~ reduces to $f^{n} (f^{m} x)$.
And, this is what we want. $f$ applied $n + m$ times.

** 2.1.4 Extended exercise

Why not do intervals by a precise quantity tolerance pair?
At least in the case of resistors, where things are specified this way?

Though, I can see in general specifying lower and upper bounds is easier.
Unless, upper + lower / 2.
This gets 'precise quantity'.
Then, upper - mid.
This gets half width.
So, either way seems fine.

*** 2.7

#+NAME: sc-interval
#+BEGIN_SRC racket
(define (make-interval a b) (cons a b))
(define (lower-bound i) (car i))
(define (upper-bound i) (cdr i))
#+END_SRC

So, this is as specified, but why rely on the user to fix the correct upper and lower bounds?

*** 2.8

So, add-interval reduces to addition on the upper and lower bounds.
In this way, sub-interval will do the same.
Though, add a check to ensure upper is upper and lower is lower.

#+NAME: def-add-interval
#+BEGIN_SRC racket
  (define (add-interval x y)
    <<sc:interval>>
    (make-interval (+ (lower-bound x) (lower-bound y))
		   (+ (upper-bound x) (upper-bound y))))
#+END_SRC

#+NAME: def:sub-interval
#+BEGIN_SRC racket
  (define (sub-interval x y)
    <<sc:interval>>
    (let (
	  (lIS (- (lower-bound x) (lower-bound y)))
	  (hIS (- (upper-bound x) (upper-bound y))))
      (if (> hIS lIS)
	  (make-interval hIS lIS)
	  (make-interval lIS hIS))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:add-interval>>
  <<def:sub-interval>>
  (add-interval (make-interval 0 1) (make-interval 9 10))
  (sub-interval (make-interval 0 2) (make-interval 9 10))
#+END_SRC

In the same way adding increases margin, subtancting decreases margin.
I feel this isn't quite right.
Instead, go with proposal above and take an procedure for combining two tolerances.

*** 2.9

#+BEGIN_SRC racket
  (define (interval-width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))
#+END_SRC

In the case of addition.
x.w + y.w = (x.u - x.l)/2 + (y.u - y.l)/2
          = ((x.u - x.l) + (y.u - y.l))/2
          = ((x.u + y.u) + (x.l - y.l))/2
          = (x + y).w

The reasoning is the same for subtraction.

For multiplication, consider some intervals using 0 and 1.
(1 0) * (1 0) = (0 0)
And, we have (1 0).w = 0.5, while (0 0).w = 0.
In contrast:
(1 1) * (1 1) = (1 1)
And, we have (1 1).w = 0.5

Division is… defined in terms of multiplication as the main operator.
This isn't a proof, but suggests similar problems.

*** 2.10

'spans 0' means 'has width 0'?
I mean, and interval crossing over 0 should be no problem.
Anyway, mul-interval written so variant of div-interval doesn't prevent anything else running.

#+BEGIN_SRC racket
  (define (mul-interval x y)
    (let (
	  (p1 (* (lower-bound x) (lower-bound y)))
	  (p2 (* (lower-bound x) (upper-bound y)))
	  (p3 (* (upper-bound x) (lower-bound y)))
	  (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
		     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (if (= 0 (interval-width y))
	(error)
	(mul-interval x
		      (make-interval (/ 1.0 (upper-bound y))
				     (/ 1.0 (lower-bound y))))))
#+END_SRC

*** 2.11

I'm not quite seeing the point of this exercise.
In any case, we can write out a table of all the possible positive/negative combinations.
Then, we can work out whether there's a guaranteed value for the upper and lower bounds.
With perhaps some errors, I have this:

| u_x | u_y | l_x | l_y | ub | lb |
| +   | +   | +   | +   | P4 | P1 |
| +   | +   | +   | -   | P4 | P3 |
| +   | +   | -   | +   | P4 | P2 |
| +   | +   | -   | -   |    |    |
| +   | -   | +   | +   | P3 | P4 |
| +   | -   | +   | -   | P2 | P3 |
| +   | -   | -   | +   |    |    |
| +   | -   | -   | -   | P1 | P3 |
| -   | +   | +   | +   | P2 | P3 |
| -   | +   | +   | -   |    |    |
| -   | +   | -   | +   | P1 | P4 |
| -   | +   | -   | -   | P1 | P2 |
| -   | -   | +   | +   |    |    |
| -   | -   | +   | -   | P3 | P1 |
| -   | -   | -   | +   | P4 | P1 |
| -   | -   | -   | -   | P1 | P4 |

Where:

| P1 | l_x | l_y |
| P2 | l_x | u_y |
| P3 | u_x | l_y |
| P4 | u_x | u_y |

Here, then, there's the 'else' case, which covers the four instances where we need to calculate more than two combinations.
In all the other cases, we need to calculate the listed two cases.

But, I guess I've got this a little wrong.
For, we can break this down into sets of calculations.
I.e. { P1, P4 } covers both the last and the first case.
Then, for the upper and lower bound we only need to figure out which is larger than the other.
This is still only two instances of multiplications.

But, on my count there are six distinct sets.
So, this means we only need to consider seven cases.

I guess I'm missing something here…

Ah, I guess I'm this potential user, huh.

*** 2.12

#+BEGIN_SRC racket
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))

  (define (make-center-percent c p)
    (let ((nudge (* (abs c) p)))
      (make-interval (- c nudge) (+ c nudge))))

  (define (i-center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
#+END_SRC

This isn't super precise with small percentages.
But, there's no way around this without changing the bound constructor.
As, imprecision has already entered by multiplying the center by the percentage to get the bounds.

#+BEGIN_SRC racket
(define (i-percent i)
  (- (/ (upper-bound i) (i-center i)) 1))
#+END_SRC

#+BEGIN_SRC racket
(i-center (make-center-percent 10 0.001))
(i-percent (make-center-percent 10 1.01))
#+END_SRC

*** 2.13

Assuming small percentage tolerances and all numbers are positive.

Formula for the approximate percentage tolerance of the product of two intervals
in terms of the tolerances of the factors.

So, for the product we take min/max of different upper/lower x/y combinations.
In general, then, product is of the form:

(x ± t_x) * (y ± t_y) = (xy ± yt_x ± xt_y ± t_xt_y)

Hm, well, to find the tolerance pertentage, divide upper by center then subtract 1.
Ignoring the part where we substract one, we have:
u / ((u + l) / 2) = 2u/(u * l)

If assuming everything is positive, then upper and lower bounds are direct.

So, we have

2(ux + tx)(uy + ty) / ((ux + tx)(uy + ty) + (lx + tx)(ly + ty))

Where tx is really uxtx, etc.
That is, ux + tx = ux(1 + tx).

Different way of looking at things.
If we start by keeping tolerance in play, then the upper bound for x, with tolerance is u_x(1 * tx).
So, then, the upper bound for product, with tolerance is
u_x * u_y * (1 * tx) * (1 * ty)
So, then, (1 * tx) * (1 * ty) = 1 + tx + ty + txty.
In this case, then, why not take the tolerance as tx + ty + txty?
This seems sufficiently simple, but gives the exactl tolerance…
Of course, tx + ty should get quite close when tx and ty are very small, as txty is going to be very very small.

#+BEGIN_SRC racket
(define (quick-mul-tolerance i1 i2) (+ (i-percent i1) (i-percent i2)))
#+END_SRC

This looks good to me…

#+BEGIN_SRC racket
(quick-mul-tolerance (make-center-percent 10 0.001) (make-center-percent 10 0.006))
(i-percent (mul-interval (make-center-percent 10 0.001) (make-center-percent 10 0.006)))
#+END_SRC

*** 2.14

#+BEGIN_SRC racket
  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
		  (add-interval r1 r2)))

  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval one
		    (add-interval (div-interval one r1)
				  (div-interval one r2)))))

  (define ti1 (make-center-width 2 0.01))
  (define ti2 (make-center-width 2 0.001))
  (define ti3 (make-center-width 4 0.001))

  ;; Two intervals are equal just in case they have the same upper and lower bounds.
  (define (i-equal i1 i2)
    (and (= (upper-bound i1) (upper-bound i2)) (= (lower-bound i1) (lower-bound i2))))

  (par1 ti1 ti2)
  (par2 ti1 ti2)
  (i-equal (par1 ti1 ti2) (par2 ti1 ti2))

  (i-percent (par1 ti1 ti2))
  (i-percent (par2 ti1 ti2))
#+END_SRC

*** 2.15

So, as intervals are just upper and lower bounds, the tolerance percentage is implicit.

When adding, everything should be preserved.
For, we sum the lower and upper bounds.
So, the center point of the new point is just the sum of the center points of the initial points.

Similar for subtraction.

In this sense, Eva Lu Ator isn't quite right.
The operations performed are important, not just the way the interval is written.

Things are different in the case of product and division, though.
Here we multiply bounds, and hence multiply tolerance.
As seen earlier, we get (1 * tx) * (1 * ty) = 1 + tx + ty + txty.

par2 has one less instance of multiplication than par1.
And, as x * y > x + y, at least when everything is positive, at least some of the additional tolerance from product is going to be preserved.

Going to need to define "better", tho.
It's not clear tolerance as given really reflects anything under these transformations.

*** 2.16

Well, par1 and par2 are the same when i1 and i2 are rational numbers, at least.
So, when addition, multiplication, etc. satisfy certain properties.
It's not clear these same properties are satisfied when working with intervals.

The answer here really depends on what is allowed with the package.
If mul and div are fixed, there's no way out.
Equivalent expressions using rationals won't translate to intervals.
Assuming, that is, something is different.

But really, the issue is this.
Resistor values are only know up to some tolerance.
These formulas are defined with respect to resistor values without accounting for tolerance.
It's a mistake to think operations on fixed values apply equally to intervals or whatever.

** 2.17

#+BEGIN_SRC racket
(define (last-pair l)
  (define (last-pear l e)
    (if (null? l)
        e
        (last-pear (cdr l) (car l))))
      (last-pear l nil))

(last-pair (list 23 72 149 34))
(last-pair (list 23 72 149))
(last-pair (list ))
#+END_SRC

** 2.18

See reverse as a special case of appending in reverse.
Then, reverse is just this with an empty list.

#+NAME: def-reverse
#+BEGIN_SRC racket
  (define (reverse l)
    (define (mirror-onto l1 l2)
      (if (null? l1)
	  l2
	  (mirror-onto (cdr l1) (cons (car l1) l2))))
    (mirror-onto l nil))
#+END_SRC

#+BEGIN_SRC racket
<<def:reverse>>
(reverse (list 23 72 149 34))
#+END_SRC

With lists like this, there's a tradeoff between easy read and easy write.
And, as set up, it's easy read.
For, it's easy to go from the right element to the last.
It's not easy write, though, as you need to traverse through every element until you get to the end.

Though, you'd expect this to be the case in general.
We need to keep track of things, and the easy-write probably changes more than the easy to read thing.

** 2.19

#+NAME: coin-lists
#+BEGIN_SRC racket
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))
#+END_SRC

#+NAME: def-cc-list
#+BEGIN_SRC racket
  (define (first-denomination coin-list) (car coin-list))
  (define (except-first-denomination coin-list) (cdr coin-list))
  (define (no-more? coin-list) (null? coin-list))

  (define (cc-list amount coin-values)
    (cond ((= amount 0) 1)
	  ((or (< amount 0) (no-more? coin-values)) 0)
	  (else
	   (+ (cc-list amount
		       (except-first-denomination coin-values))
	      (cc-list (- amount
			  (first-denomination coin-values)) coin-values)))))
#+END_SRC


#+BEGIN_SRC racket
  <<coin-lists>>
  <<def:cc-list>>
  (cc-list 100 us-coins)
  (cc-list 100 (reverse us-coins))
#+END_SRC

The order of the coin list doesn't matter.
For, we always try to make the value using with and without the current 'first' coin.
So, if, say, 50 is up first, the first call will split into using 50 and ignoring 50.
While, if 50 is up somewhere in the middle, this split will happen multiple times, according to the splits that have already happened.

** 2.20

#+NAME: def-same-parity
#+BEGIN_SRC racket
(define (same-parity e . l)
  (define (parity-list ie il)
    (if (null? il)
        nil
        (let ((eParity (remainder ie 2))
              (newElem (car il)))
          (if (= (remainder newElem 2) eParity)
            (cons newElem (parity-list ie (cdr il)))
            (parity-list ie (cdr il))))))
  (cons e (parity-list e l)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:same-parity>>
  (same-parity 1 2 3 4 5 6 7)
  (same-parity 2 3 4 5 6 7)
  (same-parity -2 3 4 5 -6 7)
#+END_SRC

I understand this way of writing procedures is useful.
Still, the application here seems strange.
same-parity feels like a regular procedure, which  takes some int and a list as an argument and returns a list.
Though, maybe I could think about this from a difference perspective.
At issue is the list is not explicit, but the same is true of +.
And in some sense the list is explicit, it's just that the first element is a procedure to apply.
And, kind of everything is a list in this way.
So, there's no need to make a list which contains a procedure and a list when we can just extend the list we'd be adding with the procedure.
Ok.

** 2.21

#+NAME: def:my-map
#+BEGIN_SRC racket
  (define (my-map proc items)
    (if (null? items)
	nil
	(cons (proc (car items))
	      (my-map proc (cdr items)))))
#+END_SRC

#+NAME: def:square-list-full
#+BEGIN_SRC racket
  (define (square-list-full items)
    (if (null? items)
	nil
	(cons (* (car items) (car items)) (square-list-full (cdr items)))))
#+END_SRC

#+NAME: def:square-list-my-map
#+BEGIN_SRC racket
  (define (square-list-my-map items)
    <<def:my-map>>
    (my-map (lambda (x) (* x x)) items))
#+END_SRC

#+BEGIN_SRC racket
  (define testSqList (list 1 2 3 4))

  <<def:square-list-full>>
  <<def:square-list-my-map>>

  (square-list-full testSqList)
  (square-list-my-map testSqList)
#+END_SRC

Yes, could have used (square x) in both, and yes in full this makes a difference as (car items) is only done once.

** 2.22

So, we've got an inner iterative function.
Takes as argument a in-list and out-list
Idea is to transfer in-list to out-list.
But, lists  work in a specific order.
We have (element rest of list)
So, we read from a list top to bottom.
But, built a list bottom to top.
In this respect, Louis' 'top' element from in-list is added as the 'bottom' element of out-list.

In the second case we're not building a list.

** 2.23

#+NAME: def-for-each
#+BEGIN_SRC racket
(define (for-each proc l)
  (cond ((null? (cdr l)) (proc (car l)))
        (else
         (proc (car l)) (for-each proc (cdr l)))))
#+END_SRC

Ideally I'd use a pass procedure on the null? test here.
Then, we could check if the argument is nil, rather than looking a step ahead.

#+BEGIN_SRC racket
  <<def:for-each>>
  (for-each (lambda (x) (display x) (newline))(list 57 321 88))
#+END_SRC

Switched (newline) to second, to keep display style.

As an aside, search seems difficult with lists.
Efficient search, that is.
For, it's easy to work through a list and check for equality.
But, it's hard to do a standard recurse onto sub-lists, as there's no quick way to make a sub-list.
That is, with this abstraction.
Though, moving to pointers things are very easy, especially if the length of the list is stored.

** 2.24

#+BEGIN_SRC racket
(list 1 (list 2 (list 3 4)))
#+END_SRC

This is basically a tree which immediately terminates when branching to the left.

** 2.25

#+BEGIN_SRC racket
(car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9))))))
(car (car (list (list 7))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))))
#+END_SRC

This last one is interesting.
(1 (2 …))
If do cdr then get (2 …).
Now, this is not simply a list with 2 as the first element.
For, then the initial argument would be (1 2 …)
So, we have a list with (2 …) as the first element.

** 2.26

#+NAME: def-append
#+BEGIN_SRC racket
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:append>>
  (define lx (list 1 2 3))
  (define ly (list 4 5 6))

  (append lx ly) ; A list of 1 2 3 4 5 6
  (cons lx ly) ; A list of (list of 1 2 3) 4 5 6
  (list lx ly) ; A list of (list of 1 2 3) (list of 4 5 6)
#+END_SRC

** 2.27

#+BEGIN_SRC racket
  (define (reverse l)
    (define (mirror-onto l1 l2)
      (if (null? l1)
	  l2
	  (mirror-onto (cdr l1) (cons (car l1) l2))))
    (mirror-onto l nil))

  (reverse (list 23 72 149 34))
#+END_SRC

#+BEGIN_SRC racket
(define (deep-reverse l)
  (define (mirror-onto l1 l2)
    (if (null? l1)
        l2
        (mirror-onto (cdr l1) (cons (deep-reverse (car l1)) l2))))
  (if (pair? l)
      (mirror-onto l nil)
      l))

(define lx2 (list (list 1 2) (list 3 4)))
(define lx22 (list 2 (list (list 1 2) (list 3 4)) (list (list 1 2) (list 3 4 5))))
lx2

(deep-reverse 3)
(deep-reverse (list 1 2))
(deep-reverse lx2)
(deep-reverse lx22)
#+END_SRC

** 2.28

#+NAME: def-fringe
#+BEGIN_SRC racket
  (define (fringe tree)
    (cond ((and (not (pair? tree)) (not (null? tree))) (list tree))
	  ((not (pair? tree)) nil)
	  (else
	   (append (fringe (car tree)) (fringe (cdr tree))))))
#+END_SRC

#+BEGIN_SRC racket
  (define (fringe tree)
    (cond ((null? tree) nil)
	  ((not (pair? tree)) (list tree))
	  (else
	   (append (fringe (car tree)) (fringe (cdr tree))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:fringe>>
  (define tx (list (list 1 2) (list 3 4)))
  (define tx2 (list (list (list 1 2) (list 4)) (list (list 1 2) (list 3 4))))
  (define tx3 (list (list 3 (list 1 2) (list 4)) (list (list 1 2) (list 3 4))))
  (fringe tx3)
  (fringe (list tx tx))
#+END_SRC

It's simply to test to see if we have a leaf.
Though, there's an issue of nil, which always ends a list, so is always an implicit leaf, so to speak.
So, we traverse left and then right.
There are two base cases.
First, not pair and a non-nil.
In this case, a leaf.
Second, as the first condition failed, it's either an branch or nil.
If not branch, then for sure nil.

Building up, we append lists.

As an aside, append here is key to ensure we flatter everything, rather than repeating the strcture of the tree.
Setting aside scaling, this is the only difference between scale-tree and fringe, along with making sure the base case returns a list so append always works.

Un-named version is a rewrite with hindsignt.
Base case conditions are in line with scale-tree

** 2.29

#+NAME: sc:mobile
#+BEGIN_SRC racket
  (define (make-mobile left right) (list left right))

  (define (make-branch length structure) (list length structure))

  (define (left-branch mobile) (car mobile))

  (define (right-branch mobile) (car (cdr mobile)))

  (define (branch-length branch) (car branch))

  (define (branch-structure branch) (car (cdr branch)))
#+END_SRC

I guess there's a better way of doing this.
As, sum-up here is just +, but applied to a list.
(cons + list) doesn't work, though.

#+NAME: def:sum-up
#+BEGIN_SRC racket
  (define (sum-up list)
    (if (null? list)
	0
	(+ (car list) (sum-up (cdr list)))))
#+END_SRC

To test whether we're going to a mobile from another mobile,
we look at the right element.
If this is a pair, then we've got another mobile.
Else, it's an int representing some weight.

#+NAME: sc:mobile-more
#+BEGIN_SRC racket
  <<sc:mobile>>
  (define (to-mobile? branch)
    (pair? (branch-structure branch)))

  (define (get-weight branch)
    (branch-structure branch))

  (define (total-weight mobile)
    (let ((twL (if (to-mobile? (left-branch mobile)) (total-weight (branch-structure (left-branch mobile))) (get-weight (left-branch mobile))))
	  (twR (if (to-mobile? (right-branch mobile)) (total-weight (branch-structure (right-branch mobile))) (get-weight (right-branch mobile)))))
      (+ twL twR)))
#+END_SRC

#+NAME: consts:m1-m2
#+BEGIN_SRC racket
  <<sc:mobile-more>>
  (define lb1 (make-branch 1 10))
  (define rb1 (make-branch 1 10))
  (define m1 (make-mobile lb1 rb1))
  (define rb2 (make-branch 1 m1))
  (define m2 (make-mobile lb1 rb2))
  (define lb2 (make-branch 1 m1))
  (define m3 (make-mobile lb2 rb2))
#+END_SRC

#+BEGIN_SRC racket
  <<consts:m1-m2>>
  (total-weight m1)
  (total-weight m2)
#+END_SRC

A 'relaxed' version of total-weight, which may be applied to mobiles or weights.

#+NAME: def:total-weight-relaxed
#+BEGIN_SRC racket
  (define (total-weight-relaxed weight-or-mobile)
    <<sc:mobile-more>>
    (if (pair? weight-or-mobile)
	(total-weight weight-or-mobile)
	weight-or-mobile))
#+END_SRC

#+BEGIN_SRC racket
  <<def:total-weight-relaxed>>
  <<consts:m1-m2>>
  (total-weight-relaxed 10)
  (total-weight-relaxed m2)
#+END_SRC

#+NAME: def:hang-weight
#+BEGIN_SRC racket
  (define (hang-weight branch)
    <<sc:mobile>>
    <<def:total-weight-relaxed>>
    (* (branch-length branch) (total-weight-relaxed (branch-structure branch))))
#+END_SRC

#+NAME: def:isBalanced?
#+BEGIN_SRC racket
  (define (isBalanced? mobile)
    <<sc:mobile-more>>
    <<def:hang-weight>>
    (display mobile)
    (newline)
    (and
     (= (hang-weight (left-branch mobile)) (hang-weight (right-branch mobile)))
     (if (to-mobile? (left-branch mobile)) (isBalanced? (branch-structure (left-branch mobile))) #t)
     (if (to-mobile? (right-branch mobile)) (isBalanced? (branch-structure (right-branch mobile))) #t)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:isBalanced?>>
  <<consts:m1-m2>>
  (isBalanced? m3)
#+END_SRC

In short, we need a conjunction of balanced applied to main and all sub-mobiles.
So, we check weight * length for each branch of the mobile.
Then, we get to work on sub-mobiles.
There's no guarantee of sub-mobules, so we only check when sure.
And, otherwise return #t does the value of the conjunction is determined by all the other components.
The only thing to note with the recusrive case is that we need to move to the structure of the branch, rather than the branch itself.

I'd need to change right-branch and brach-structure procedures.
For, these assume we're working with a list.
With a list, the right element is always either a list or nil.
So, some extra work is needed to get any value.
In particular, we're always working with a pair.
So, to get the right hand value, we need to cdr then car.
But, if cons is used, then we're just working with two values.
Hence, we'd car and be done.

** 2.30

#+BEGIN_SRC racket
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))

(scale-tree (list 1 (list 2 (list 3 4 5))) 4)
#+END_SRC

Cons works fine here, as we're breaking a list down into it's basic elements, then building back up.
Things would be different if flattening the list, etc.

#+BEGIN_SRC racket
  (define (square-tree-basic tree)
    (cond ((null? tree) nil)
	  ((not (pair? tree)) (* tree tree))
	  (else (cons (square-tree-basic (car tree))
		      (square-tree-basic (cdr tree))))))

  (square-tree-basic (list 1 (list 2 (list 3 4) 5) (list 6 7)))

  (define (square-tree-map tree)
    <<def-my-map>>
    (my-map (lambda (sub-tree)
	      (if (pair? sub-tree)
		  (square-tree-map sub-tree)
		  (* sub-tree sub-tree)))
    tree))

  (square-tree-map (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+END_SRC

Right, map here just goes through each element in the list and applies the procedure.
So, what this does is abstracts from the way the list works, as emphasised in the book.
It's important to keep in mind this is the limit of what's happening.
The code should look mostly the same, given that little is being done to reconstruct the tree via lists.

** 2.31

#+NAME: def:tree-map
#+BEGIN_SRC racket
  (define (tree-map proc tree)
    <<def:my-map>>
    (my-map (lambda (sub-tree)
	      (if (pair? sub-tree)
		  (tree-map proc sub-tree)
		  (proc sub-tree)))
    tree))
#+END_SRC

#+BEGIN_SRC racket
  (define (square-tree-again tree)
    <<def:tree-map>>
    <<def:square>>
    (tree-map square tree))

  (square-tree-again (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+END_SRC

** 2.32

#+NAME: def-subsets
#+BEGIN_SRC racket
  (define (subsets s)
    <<def:my-map>>
    (if (null? s)
	(list nil)
	(let ((rest (subsets (cdr s))))
	  (append rest (my-map (lambda (x) (cons (car s) x)) rest)))))
#+END_SRC

#+BEGIN_SRC racket
<<def:subsets>>
(subsets (list 1 2 3))
#+END_SRC

So, we're splitting on the first element of the list.
Then, applying subsets to all other elements of the list.
We then keep a copy of every subset from the other elements of the list.
So, the only thing to do is ensure we also have a copy of the those subsets with the element we excluded.
This is what the lambda expresion does.

So, for example, (a b)
rest is just b.
subsets applied to b goes once more, to the value b and nil.
Now, on the way back, we have nil turned into an empty list, and b joined with the empty list.
So, we have (() (b)).
Now, we store a copy of this, and also consider a included.
So, this is ((a) (a b)).
Combined, we have (() (b) (a) (a b)).

** 2.33

#+NAME: def:accumulate
#+BEGIN_SRC racket
  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(op (car sequence)
	    (accumulate op initial (cdr sequence)))))
#+END_SRC

#+BEGIN_SRC racket
  (define (map-again p sequence)
    <<def:accumulate>>
      (accumulate (lambda (x y) (cons (p x) y))  nil sequence))

  <<def:square>>
  (map-again square (list 1 2 3 4 5))
#+END_SRC

Okay.
The point here is op is a two place argument.
The first argument to op is the current element of the sequence, and accumulate works through these one-by-one.
Then second argument to op is the result of accumulating.
So, for example, rather than cons, we could have summed.

E.g., map-sum maps the procedure and then sums the list.


#+BEGIN_SRC racket
  (define (map-sum p sequence)
    <<def:accumulate>>
    (accumulate (lambda (x y) (+ (p x) y)) 0 sequence))

  <<def:square>>
  (map-sum square (list 1 2 3 4 5))
#+END_SRC

#+BEGIN_SRC racket
  (define (append-again seq1 seq2)
    <<def:accumulate>>
    (accumulate cons seq2 seq1))

  (append-again (list 1 2) (list 3 4))
#+END_SRC

We're going through every element in list1 and cons to list2.
Here, though, you need some idea of the way lists and accumulate work.
For, if we worked through the list on call rather than close, this would reverse list1.
I like abstraction, but here I'm not sure what the point is, given we need the details to understand why the abstraction works.

#+NAME: def:length
#+BEGIN_SRC racket
  (define (length sequence)
    <<def:accumulate>>
    (accumulate (lambda (x y) (+ (if (null? x) 0 1) y)) 0 sequence))
#+END_SRC

#+BEGIN_SRC racket
  <<def:length>>
  (length (list 1 2 3))
  (length (list ))
#+END_SRC

** 2.34

#+NAME: def-horner-eval
#+BEGIN_SRC racket
  (define (horner-eval x coefficient-sequence)
    <<def:accumulate>>
    (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* higher-terms x)))
		0
		coefficient-sequence))
#+END_SRC

#+BEGIN_SRC racket
  <<def:horner-eval>>
  (horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

Right, I figured out the goal was to modify addition.
But, the choice of a and b was guess work.
I originially had (+ (* a x) b).
Thinking that a would be a_n at first.
But, it's not really higher-terms, it's higher-terms already done, right?

It's, what's already been done with the higher-terms, or something like this.

Right, this is clear when looking at the definition of accumulate.
We have op applied to the current first thing in the sequence and the rest.
So, by higher-terms this is the op-defined as applied to all the higher-terms from the current term.

#+BEGIN_SRC racket
  (define (horner-test x coefficient-sequence)
    <<def:accumulate>>
    (accumulate (lambda (this-coeff higher-terms) (display higher-terms) (newline) this-coeff higher-terms)
		0
		coefficient-sequence))

  (horner-test 2 (list 1 3 0 5 0 1))
#+END_SRC

This 'test' is kind of useless, as higher-terms is the result of evaluating higher terms, not the other terms to evaluate.

At this point in the book we're not only learning about the way abstractions are useful.
But, we're also learning about the way remembering what the abstractions really do is also useful.

** 2.35

#+NAME: def-
#+BEGIN_SRC racket
  (define (count-leaves-acc tree)
    <<def:accumulate>>
    <<def:fringe>>
    (accumulate + 0 (map (lambda (x) 1) (fringe tree))))

  <<consts:m1-m2>>
  (count-leaves-acc m2)
#+END_SRC

As I missing something here?
With an accumulator we need a list.
So, somehow we need to collapse the tree into a list.
fringe does this.
Then, somehow accumulate the elements of the list to get the number of leaves.
Well, here then just set every leaf value to 1.

** 2.36

Here, a way to make a list of the first elements of the lists.
Then, the rest of the lists.

#+BEGIN_SRC racket
(list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 1 1 12))
#+END_SRC

#+NAME: def-accumulate-n
#+BEGIN_SRC racket
  (define (accumulate-n op init seqs)
    <<def:accumulate>>
    <<def:my-map>>
    (if (null? (car seqs))
	nil
	(cons (accumulate op init (my-map car seqs))
			  (accumulate-n op init (my-map cdr seqs)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:accumulate-n>>
    (accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
#+END_SRC

Alright, this exercise was really cool!

** 2.37

#+NAME: consts:test-matrix
#+BEGIN_SRC racket
  (define test-matrix (list (list 1 2 3 4) (list 4 5 6 6) (list 6 7 8 9)))
#+END_SRC

#+NAME: def-dot-product
#+BEGIN_SRC racket
  (define (dot-product v w)
    <<def:accumulate>>
    (accumulate + 0 (map * v w)))
#+END_SRC

Hold on, we defined map to take a proc and a list.
Yet, here, map takes a proc and two lists.
So, here we're using the base map mentioned in Footnote 12.
This takes a procedure of n arguments and n lists.
Then, applies the procedure to the ith element in each of the lists.

Oh, right, *this* is in footnote 17.

#+NAME: def:matrix-*-vector
#+BEGIN_SRC racket
  (define (matrix-*-vector m v)
    <<def:dot-product>>
    (map (lambda (row) (dot-product row v)) m))
#+END_SRC

#+NAME: def:transpose
#+BEGIN_SRC racket
  (define (transpose m)
    <<def:accumulate-n>>
    (accumulate-n cons nil m))
#+END_SRC

#+BEGIN_SRC racket
  <<def:transpose>>
  (transpose (list (list 1 2) (list 3 4) (list 5 6)))
#+END_SRC

#+NAME: def:matrix-*-matrix
#+BEGIN_SRC racket
  (define (matrix-*-matrix m n)
    <<def:transpose>>
    <<def:matrix-*-vector>>
    (let ((cols (transpose n)))
      (map (lambda (x) (matrix-*-vector cols x)) m)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:matrix-*-matrix>>
  (matrix-*-matrix (list (list 2 3 4)
			 (list 1 0 0))
		   (list (list 0 1000)
			 (list 1 100)
			 (list 0 10)))
#+END_SRC

** 2.38

#+NAME: def-fold-left
#+BEGIN_SRC racket
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
#+END_SRC

#+BEGIN_SRC racket
  <<def:accumulate>>
  <<def:fold-left>>

  (accumulate / 1 (list 1 2 3)) ;  1 / (2 / 3)
  (fold-left / 1 (list 1 2 3))  ; (1 / 2) / 3
  (accumulate list nil (list 1 2 3)) ; With cons, the same list.
				     ; With list, (list … (list nil))
				     ; So, (1 (2 (3 ())))
  (fold-left list nil (list 1 2 3)) ; With cons, (((nil 1) 2) 3)
				    ; With list, (list (list nil 1) 2)
#+END_SRC

I mean, op should be such that (op x y) = (op y x)
Right, commutative.

Hence, +, *, etc should work fine

#+BEGIN_SRC racket
  <<def:accumulate>>
  <<def:fold-left>>
  (= (accumulate * 1 (list 1 2 3)) (fold-left * 1 (list 1 2 3)))
  (= (accumulate + 0 (list 2 3 5 9)) (fold-left + 0 (list 2 3 5 9)))
#+END_SRC

Things like list fail as (list 2 3) = (2 3) != (3 2) = (list 3 2).
Same for /, ^, etc.

** 2.39

#+NAME: def:filter
#+BEGIN_SRC racket
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
        (cons (car sequence)
              (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
#+END_SRC

TODO

reverse-fr isn't it.
But, I'm drawing blanks.

The issue is, append-elem is a 'worse' version of append.
In that, with appened-elem we make all the same recursive calls, and all but the last are kind of pointless.
While, in the case of append these can be used for other elements.

I'm really drwawing blanks on a way to do this without refering to the procedure by name.

#+BEGIN_SRC racket
  (define (append-elem e list)
    (if (null? list)
	(cons e nil)
	(cons (car list) (append-elem e (cdr list)))))

  (define (reverse-fr sequence)
    <<def:accumulate>>
    <<def:append-elem>>
    (accumulate (lambda (x y) (append-elem x y)) nil sequence))

  (reverse-fr (list 1 2 3))
#+END_SRC

#+BEGIN_SRC racket
  (define (reverse-fl sequence)
    <<def:fold-left>>
    (fold-left (lambda (x y) (cons y x)) nil sequence))

  (reverse-fl (list 1 2 3))
#+END_SRC

#+NAME: def:flatmap
#+BEGIN_SRC racket
  (define (flatmap proc seq)
    <<def:accumulate>>
    (accumulate append nil (map proc seq)))
#+END_SRC

#+NAME: def:enumerate-interval
#+BEGIN_SRC racket
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
#+END_SRC

#+NAME: def:prime-sum?
#+BEGIN_SRC racket
  (define (prime-sum? pair)
    <<def:prime?>>
    (prime? (+ (car pair) (cadr pair))))
#+END_SRC

#+NAME: def:make-pair-sum
#+BEGIN_SRC racket
  (define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
#+END_SRC

#+NAME: def:prime-sum-pairs
#+BEGIN_SRC racket
  (define (prime-sum-pairs n)
    <<def:filter>>
    <<def:enumerate-interval>>
    <<def:flatmap>>
    <<def:make-pair-sum>>
    <<def:prime-sum?>>
    (map make-pair-sum
	 (filter prime-sum?
		 (flatmap
		  (lambda (i)
		    (map (lambda (j) (list i j))
			 (enumerate-interval 1 (- i 1))))
		  (enumerate-interval 1 n)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:enumerate-interval>>
  <<def:flatmap>>
  <<def:prime-sum-pairs>>

  (prime-sum-pairs 10)
  (enumerate-interval 1 10)
  (flatmap
   (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 10))
  (flatmap (lambda (x) (list x x)) (enumerate-interval 1 10))
#+END_SRC

flatmap

We take a procedure and a list.
The list can be of plain elements.
However, the procedure must return pairs.
So, in this case, after applying the procedure with map, we have a list of lists.
Or, at least, each elemnt mapped over is replaced by a list.
Flatmap then flattens this, so the original list is expanded with additional elements, but these aren't themselves inside a list.

** 2.40

#+NAME: def-unique-pairs
#+BEGIN_SRC racket
  (define (unique-pairs n)
    <<def:flatmap>>
    <<def:enumerate-interval>>
    (flatmap (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1)))) (enumerate-interval 1 n)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:unique-pairs>>
  (unique-pairs 10)


  (define (prime-sum-pairs-up n)
    <<def:make-pair-sum>>
    <<def:filter>>
    <<def:prime-sum?>>
    (map make-pair-sum
	 (filter prime-sum?
		 (unique-pairs n))))

  (prime-sum-pairs-up 10)
#+END_SRC

But, this was just cutting apart the definition of prime-sum-pairs…

Or was this the point?

** 2.41

#+BEGIN_SRC racket
  (define (unique-triples n)
    <<def-flatmap>>
    <<def:unique-pairs>>
    <<def:enumerate-interval>>

    (flatmap (lambda (i) (map (lambda (j) (cons i j)) (unique-pairs (- i 1)))) (enumerate-interval 1 n)))
  

  (define (unique-triples-to-n-sum-to-s n sum)
    <<def:filter>>
    <<def:accumulate>>
    (filter (lambda (x) (= sum (accumulate + 0 x))) (unique-triples n)))

  (unique-triples-to-n-sum-to-s 10 10)
#+END_SRC

** 2.42 (Queens)

Function which takes an index and a list.
Returns a ist where the first element is what was at the index, and the second elemnt is the list without the element at the index.

That is, the list with the ith element now the 0th element.

Originally this was thought of as the ith element removed and the rest of the list, but shifting to front is a more natural perspective.

Index starts at 0.

#+NAME: def-shift-to-front
#+BEGIN_SRC racket
  (define (shift-to-front i list)
    (define (shift-list-i old new i n)
      (if (= i n)
	  (cons (car old) (cons (cdr old) new))
	  (shift-list-i (cons (car new) old) (cdr new) i (+ n 1))))
    (define (recombine old new)
      (if (null? old)
	  new
	  (recombine (cdr old) (cons (car old) new))))
    (let ((split (shift-list-i nil list i -1)))
      (cons (car split) (recombine (car (cdr split)) (cdr (cdr split))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:shift-to-front>>
  (cdr (shift-to-front 3 (list 1 2 3 4 5 6)))
#+END_SRC

A variant of map.
Instead of applying each item to proc, we apply a number corresponding to the instance of map and the item.
So, for example, (map-i proc (a b)) does (proc 0 a) and then (proc 1 b).

#+NAME: def:map-i-to-n
#+BEGIN_SRC racket
(define (map-i-to-n proc items n)
  (define (map-apply-index proc i items n)
    (if (or (null? items) (= i n))
        nil
        (cons (proc i (car items))
              (map-apply-index proc (+ i 1) (cdr items) n))))
  (map-apply-index proc 0 items n))
#+END_SRC

So, now it's easy to apply shift-to-front diagonally

E.g. (map-i shift-to-front grid) or to be explicit (map-i (lambda (i x) (shift-to-front i x)) grid)
The latter form is kind of helpful, as it's easy to discard i and only apply x.

Getting all the diagonals of a grid is a little difficult.
We use map-i-to-n to dynamically shift and limit the mapping.

The problem is whenever we do this, the grid is sure to become a rectangle.
And, while it's easy to make a function which works with a grid or wide rectange, extending this to a tall rectange isn't easy.

(Basically, (map-i-to-n shift-to-front tallGrid (length tallGrid)) only considers a grid.)

So, we avoid this issue by tranpsoing the grid if needed, to ensure it's always a grid or a wide rectangle.
It's easy to see diagonals are preserved under this.

The only issue is that this procedure is that it includes the empty list.
So, filter this out.

#+NAME: def:get-diags-lr
#+BEGIN_SRC racket
  (define (get-diags-lr grid)

  <<def:filter>>

    (define (collect-diag-to diagList grid)

      <<def:shift-to-front>>
      <<def:transpose>>
      <<def:map-i-to-n>>

      (if (null? grid)
	  diagList
	  (let ((tallGrid (cond ((null? grid) grid)
				((< (length (car grid)) (length grid)) (transpose grid))
				(else grid))))
	    (let ((shifted-list (map-i-to-n shift-to-front tallGrid (length tallGrid))))
	      (collect-diag-to (append diagList (cons (map car shifted-list) nil)) (map cdr shifted-list))))))
    (filter (lambda (x) (not (null? x))) (collect-diag-to nil grid)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:get-diags-lr>>
  (get-diags-lr (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
#+END_SRC

get-diags-lr only gets diags going left to right.
But, given the representation of a grid here, there's an easy fix.
Apply reverse.
This gives us a mirror.
Hence, lr becomes rl.

#+NAME: def:get-diags-rl
#+BEGIN_SRC racket
  (define (get-diags-rl grid)
  <<def:get-diags-lr>>
    (get-diags-lr (reverse grid)))
#+END_SRC

#+BEGIN_SRC racket
  <<def:enumerate-interval>>
  (map (lambda (x) (if (= 2 x) 0 x)) (enumerate-interval 1 10))
#+END_SRC

We'll represent queens as 0s.
To test whether a board is safe, we check to see there are no two queens in a row column or diagonial.
get-diags gets us diagonials, grid is built with columsn, and transpose gets us rows.

So, all that's needed is a  couple of functions to ensure each list in a list of lists has at most one instance of a nubmer.
That's all these two functions do.

#+NAME: def:count-ns-in-list
#+BEGIN_SRC racket
  (define (count-ns-in-list n l)
    <<def:filter>>
    (length (filter (lambda (x) (= x n)) l)))
#+END_SRC

#+NAME: def:unique-n?
#+BEGIN_SRC racket
  (define (unique-n? n listOfLists)
    <<def:count-ns-in-list>>
    (if (null? listOfLists)
	#t
	(and (< (count-ns-in-list n (car listOfLists)) 2) (unique-n? n (cdr listOfLists)))))
#+END_SRC

#+NAME: def:queens
#+BEGIN_SRC racket
  (define (queens board-size)

    (define empty-board nil)  ; empty-board is nil.
			      ; adjoin-position will add a row.

    (define (safe? k positions)
      <<def:unique-n?>>
      <<def:transpose>>
      <<def:get-diags-lr>>
      <<def:get-diags-rl>>
      (and (unique-n? 0 (transpose positions)) (unique-n? 0 (get-diags-lr positions)) (unique-n? 0 (get-diags-rl positions))))

    (define (adjoin-position new-row k rest-of-queens)
      <<def:enumerate-interval>>
      (cons (map (lambda (x) (if (= new-row x) 0 x)) (enumerate-interval 1 board-size)) rest-of-queens)
      ; Place the queen at the new-row position.
      )
    (define (queens-cols k)
      <<def:filter>>
      <<def:flatmap>>
      <<def:enumerate-interval>>
      (if (= k 0)
	  (list empty-board)
	  (filter
	   (lambda (positions) (safe? k positions))
	   (flatmap
	    (lambda (rest-of-queens)
	      (map (lambda (new-row)
		     (adjoin-position new-row k rest-of-queens))
		   (enumerate-interval 1 board-size)))
	    (queens-cols (- k 1))))))
    (queens-cols board-size))
#+END_SRC

#+BEGIN_SRC racket
  <<def:queens>>
  (queens 8)
#+END_SRC

** 2.43

So, there's (queens-cols (- k 1)) and the number of times it's evaluated.
All this does is generate everything for the k - 1 case.
All here is a big all.
In the original proc, this is only evaluated once.
So, we make a lot of recursive calls, for sure, but these all stem from evaluating a single instance of queens-cols and going from there.

When things are flipped around, the proc is evluated for every instance in new-row.

Hence, if a single run takes T, then this is going to be even more than T * board-size.
Does it get close to T! ?

In any case, this is mostly about the way scheme evaluates.
So, moving on…

** 2.44

Going by the suggestion, this should paint two copies side-by-side below the arg.

#+BEGIN_SRC racket
  (define (up-split painter n)
    (if (= n 0)
	painter
	(let ((smaller (up-split painter (- n 1))))
	  (below painter (beside smaller smaller)))))
#+END_SRC

** 2.45

For reference, here's right-split

#+BEGIN_SRC racket
  (define (right-split painter n)
    (if (= n 0)
	painter
	(let ((smaller (right-split painter (- n 1))))
	  (beside painter (below smaller small)))))
#+END_SRC

Goal is 'split' such that:

#+BEGIN_SRC racket
(define right-split (split beside below))
(define up-split (split below beside))
#+END_SRC

So, proc which takes painter and n as argument.
lambda makes this easy.

#+BEGIN_SRC racket
  (define (split firstProc secondProc)
    (lambda (painter n)
      (if (= n 0)
	  painter
	  (let ((smaller ((split firstProc secondProc) painter (- n 1))))
	    (firstProc painter (secondProc smaller small))))))
#+END_SRC

** 2.46

#+BEGIN_SRC racket
(define (make-vect x y)
  (cons x y))

(define (xcor-vect v)
  (car v))

(define (ycor-vect v)
  (cdr v))

(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1) (xcor-vect v2)) (+ (ycor-vect v1) (ycor-vect v2))))

(define (sub-vect v1 v2)
  (make-vect (- (xcor-vect v1) (xcor-vect v2)) (- (ycor-vect v1) (ycor-vect v2))))

(define (scale-vect s v1)
  (make-vect (* s (xcor-vect v1)) (* s (ycor-vect v1))))
#+END_SRC

** 2.47

#+BEGIN_SRC racket
(define (make-frameL origin edge1 edge2)
  (list origin edge1 edge2))

(define (frameL-origin frame)
  (car frame))

(define (frameL-edge1 frame)
  (cadr frame))

(define (frameL-edge2 frame)
  (caddr frame))

(define (make-frameC origin edge1 edge2)
  (cons origin (cons edge1 edge2)))

(define (frameC-origin frame)
  (car frame))

(define (frameC-edge1 frame)
  (cadr frame))

(define (frameC-edge2 frame)
  (cddr frame))
#+END_SRC

** 2.48

#+BEGIN_SRC racket
  (define (make-segment origin start end)
    (cons start end))

  (define (start-segment seg)
    (car seg))

  (define (end-segment seg)
    (cdr seg))
#+END_SRC

There's nothing else here, right?
vec running from ogirin to the start-point is just start-point coordinates.
Same for end.

Unless the suggestion is to add start to origin, but I don't see good motivation for this.

On the other hand, I'm not sure why so many excercises are just cons car cdr…

** 2.49

So, fix the relevant coordinates, and then pass a list of segments to segmemts->painter.

I'm not interested enough to do the rest.

wave seems… a lot of work for basically nothing.

#+BEGIN_SRC racket
  (define (paintFrame frame)
    (let ((bottomLeft (frame-origin frame))
	  (bottomRight (add-vec (frame-origin frame) (frame-edge1 frame)))
	  (topRight (add-vec bottomRight (frame-edge2 frame)))
	  (topLeft (add-vec (frame-origin frame) (frame-edge2 frame))))
      (segmemts->painter
       (list
	(make-segment bottomLeft bottomRight)
	(make-segment bottomRight topRight)
	(make-segment topRight topLeft)
	(make-segment topLeft bottomLeft)))
      frame))
#+END_SRC

** 2.50

#+BEGIN_SRC racket
  (define (flip-hori painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))
#+END_SRC


So, origin is now (0, 1).
New x points to (1, 1)
And, y points to (0, 0).
Basically, everything is now upside down.

#+BEGIN_SRC racket
  (define (rotate180 painter) (rotate90 (rotate90 painter)))
#+END_SRC

I mean, really.
270 works the same way.

The point here is to minimize where things can go wrong.
Applying a rotation twice is straightforward.
So, then, leave 90 as the only complex operation.

Or, create a general function that works with any degree.

** 2.51

So, one option is to squish and shift origin.
The other is to squish, rotate 270, and mirror along the y-axis.

** 2.52

I'm good, for now.

Maybe someday I'll come back to this and see if there's a way to get everything to display…

** 2.53

#+NAME: def-memq
#+BEGIN_SRC racket
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:memq>>

  (list 'a 'b 'c) ; (a b c)
  (list (list 'george)) ; ((george))
  (cdr '((x1 x2) (y1 y2))) ; ((y1 y2)) - we're getting the list, just without the first element.
  (cadr '((x1 x2) (y1 y2))) ; (y1 y2)
  (pair? (car '(a short list))) ; #f - just 'a. though… (pair? (cddr '(a short list))) is #t, as list.
  (memq 'red '((red shoes) (blue socks))) ; #f, as red isn't in the main list.
  (memq 'red '(red shoes blue socks)) ; the entire list, as red is the first thing.
#+END_SRC

** 2.54

#+NAME: def-my-equal?
#+BEGIN_SRC racket
  (define (my-equal? l1 l2)
    (if (or (null? l1) (null? l2))
	true
	(and (eq? (car l1) (car l2)) (my-equal? (cdr l1) (cdr l2)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:my-equal?>>
  (my-equal? '(a b) '(c d))
  (my-equal? '(a b) '(a b))
#+END_SRC

I think this is what's being requested.
This is similar to how I did valid? for 8-queens.
For a similar or implementation DeMorgan.
Base case is false, and build up with or.
Though, something iterative would be better, as you can skip everything after finding a matching pair.

** 2.55

#+BEGIN_SRC racket
(car ''abracadabra)
(cddr ''abracadabra)

;; (car 'abracadabra)
;; (cdr 'abracadabra)
#+END_SRC

I mean, I'm not sure we've been told enough here.
If we do car we get quote, and if we do cdr we get 'abracadabra.
But, ' doesn'6 make a list.
(car 'abracadabra) fails.

Well, idea is ' is just a procedure.
So, 'abc is really (' a b c) or something of the sort.
And, as the procedure is quoted and is just a list, then everything inside is quoted.

(cddr ''abracadabra) is just the empty list.

This is easay to test:

#+BEGIN_SRC racket
(quote abc)
#+END_SRC

Yeah, seems about right.

** 2.56

#+NAME: sc:def-my-deriv
#+BEGIN_SRC racket
      (define (variable? e)
	(symbol? e))


      (define (same-variable? v1 v2)
	(and (variable? v1) (variable? v2) (equal? v1 v2))) ; Huh, so this includes checks for variables.


    (define (sum? e)
      (and (pair? e) (eq? (car e) '+)))


  (define (augend e)
    (if (null? (cdddr e))
	(caddr e)
	(cons '+ (cddr e))))


  (define (addend e)
    (cadr e))


  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
	  ((=number? a2 0) a1)
	  ((and (number? a1) (number? a2)) (+ a1 a2))
	  (else (list '+ a1 a2))))


  (define (product? e)
    (and (pair? e) (eq? (car e) '*)))


  (define (multiplier e)
    (if (and (pair? e) (pair? (cdr e))) ; okay, these checks are skipped.
	(cadr e)                        ; in part I understand. As pair? is a predicate.
	(error "not really a mult")))   ; And, pair? is still nice so long as we evaluate as needed and and is defined to use this.


  (define (multiplicand e)
    (if (null? (cdddr e))
	(caddr e)
	(cons '* (cddr e))))


  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
	  ((=number? m1 1) m2)
	  ((=number? m2 1) m1)
	  ((and (number? m1) (number? m2)) (* m1 m2))
	  (else (list '* m1 m2))))


  (define (=number? exp num)
    (and (number? exp) (= exp num)))

  (define (exponentiation? e)
    (and (pair? e) (eq? (car e) '^)))


  (define (make-exponent b e)
    (cond ((=number? e 0) 1)
	  ((=number? e 1) b)
	  (else (list '^ b e))))

  (define (exponent e)
    (caddr e))

  (define (base e)
    (cadr e))


  (define (my-deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp)
	   (if (same-variable? exp var) 1 0))
	  ((sum? exp)
	   (make-sum (my-deriv (addend exp) var)
		     (my-deriv (augend exp) var)))
	  ((product? exp) (make-sum
			   (make-product (multiplier exp)
					 (my-deriv (multiplicand exp) var))
			   (make-product (my-deriv (multiplier exp) var)
					 (multiplicand exp))))
	  ((exponentiation? exp) (make-product
				  (make-product
				   (exponent exp)
				   (make-exponent var (- (exponent exp) 1)))
				  (my-deriv (base exp) var)))
	  (else
	   (error "unknown expression type -- DERIV" exp))))
#+END_SRC

#+BEGIN_SRC racket
  <<sc:def:my-deriv>>
  (my-deriv (make-product 0 'x) 'x)
  (my-deriv '(+ x 3 4) 'x)
  (my-deriv '(* x y z 5) 'x)
  (my-deriv '(^ x 2) 'x)
  (my-deriv '(^ x 3) 'x)
  (my-deriv '(+ 5 (^ x 3)) 'x)
  (my-deriv '(* x y (+ x 3)) 'x)
#+END_SRC

** 2.57

Modified above.

Though, I don't like this.
For, these expressions as written aren't using make-product, etc.
And, when using make-porduct, there's no way to 'officially' construct something of this kind.

Of course, we can extend.

#+BEGIN_SRC racket
(define (make-sum-wild a)
  (cond
    ; First condition, check if everything in the list is a number, if so sum
    ((accumulate (lambda (x y) (and (number? x) y)) true a) (accumulate + 0 a))
    (else
     ; Else, we have some symbols.
     ; So, sum what we can, and collect all the variables.
     (let ((sumNum (accumulate + 0 (filter number? a)))
           (sumSym (filter (lambda (x) (not (number? x))) a)))
       ; Then, make a list.
       ; As we know sumSym is non-empty and the rest are literals, easiest to cons
       ; But, check to see whether there's any sense making the list
       (cond ((and (= sumNum 0) (= 1 (length sumSym))) (car sumSym))
             ((= sumNum 0) (cons '+ sumSym))
             (else (cons '+ (cons sumNum sumSym))))))))
#+END_SRC

#+BEGIN_SRC racket
(define (make-product-wild m)
  (cond ((memq 0 m) 0)
        ((accumulate (lambda (x y) (and (number? x) y)) true m) (accumulate * 1 m))
        (else
         (let ((multNum (accumulate * 1 (filter number? m)))
               (multSym (filter (lambda (x) (not (number? x))) m)))
           (cond ((and (= multNum 1) (= 1 (length multSym))) multSym)
                 ((= 1 multNum) (cons '* multSym))
                 (else (cons '* (cons multNum multSym))))))))
#+END_SRC

These work kind of nice, at least outside of deriv.
The problem is, these reduce too effectively.
And, deriv expects at least something binary.

So, I could reverse a little.
These setters could be written to match up with deriv and the way it works internally.
But, ugh.
At this point we have to modify deriv.
As, there's no way to allow the user to give a list, and for deriv to provide two arguments.

** 2.58

With infix and explicit parentheses, this amounts to reverting the representation of sum and product to work with two arguments and then updating where the symbol is stored.

After the mess of the previous question, I have no interest in the second part of this.
The simplest approach would be to create a process which rewrites the expression with correct parentheses.
Then, only need to pass the argument through this proc.

Else, as seen above, deriv no longer works.

Oh, does this mean the question is done?

The answer is no.
For, there's no way to build a constructor that allows the user to write expressions of this form while preserving the internals of deriv.

Ah, though maybe there is.
For example, we could write a proc which takes a single argumnet.
Then, depending on the value, does something or takes another argument.
In this way, we could test for a list, and if not then take on the second argument.

** 2.59

#+NAME: def-element-of-set?
#+BEGIN_SRC racket
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
#+END_SRC

#+NAME: def:union-set
#+BEGIN_SRC racket
  (define (union-set set1 set2)
  <<def:element-of-set?>>
    (cond ((null? set1) set2)
	  ((element-of-set? (car set1) set2) (union-set (cdr set1) set2))
	  (else (union-set (cdr set1) (cons (car set1) set2)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:union-set>>
  (union-set (list 1 2 3) (list 3 4 5))
#+END_SRC

** 2.60

Nothing needs to change with element-of-set? and intersection-set.
element-of-set? works through a list and checks to see if x is equal to anything on the list.
Nothing changes if duplicates are allowed.
Likewise, intersection-set remains the same. Work through each element in set1 and check whether it's in set2.

union-set can remain the same, or can be simplified.
All we really need to do is (append set1 set2).
Though, avoiding this helps with efficiency.

Speaking of, if we're measuring runtimes by the size of the set, then any particular instance will be at least as slow.
Though, there's no substantial change.
In particular, intersection will keep the runtime down, and union too if the original is kept.

I can't think of an interesting application.
If writing is cheap and reading is expensive, and you're not transforming sets much, then repetitions works better.
But, I'm not sure when this is the case.

** 2.61

#+NAME: def-adjoin-set-o
#+BEGIN_SRC racket
  (define (adjoin-set-o e set)
    (cond ((null? set) (list e))
	  ((= e (car set)) set)
	  ((< e (car set)) (cons e set))
	  (else (cons (car set) (adjoin-set-o e (cdr set))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:adjoin-set-o>>
  (adjoin-set-o 4 (list 1 2 3 5 6 7))
  (adjoin-set-o 0 (list 1 2 3 5 6 7))
  (adjoin-set-o 8 (list 1 2 3 5 6 7))
  (adjoin-set-o 8 (list 1 9 3 5 6 7))
#+END_SRC

** 2.62

#+NAME: def-union-set-o
#+BEGIN_SRC racket
(define (union-set-o set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        ((= (car set1) (car set2)) (union-set-o (cdr set1) set2))
        ((< (car set1) (car set2)) (cons (car set1) (union-set-o (cdr set1) set2)))
        ((< (car set2) (car set1)) (cons (car set2) (union-set-o set1 (cdr set2))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:union-set-o>>
  (union-set-o (list 1 2 3) (list 4 5 6))
  (union-set-o (list 1 2 3) (list 1 2 3))
  (union-set-o (list 4 5 6) (list 1 2 3))
  (union-set-o (list 1 4) (list 2 3))
#+END_SRC

** 2.63

#+NAME: sc:tree
#+BEGIN_SRC racket
  (define (entry tree) (car tree))

  (define (left-branch-tree tree) (cadr tree))

  (define (right-branch-tree tree) (caddr tree))

  (define (make-tree entry left right)
    (list entry left right))
#+END_SRC

#+NAME: def-element-of-set?-tree
#+BEGIN_SRC racket
  (define (element-of-set?-tree x set)
    <<sc:tree>>
    (cond ((null? set) false)
	  ((= x (entry set)) true)
	  ((< x (entry set)) (element-of-set?-tree x (left-branch-tree set)))
	  (else (element-of-set?-tree x (right-branch-tree set)))))
#+END_SRC

#+NAME: def:adjoin-set
#+BEGIN_SRC racket
  (define (adjoin-set x set)
    <<sc:tree>>
    (cond ((null? set) (make-tree x nil nil))
	  ((= x (entry set)) set)
	  ((< x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch-tree set)) (right-branch-tree set)))
	  ((> x (entry set)) (make-tree (entry set) (left-branch-tree set) (adjoin-set x (right-branch-tree set))))))
#+END_SRC

#+NAME: def:tree->list-1
#+BEGIN_SRC racket
  (define (tree->list-1 tree)
    <<sc:tree>>
    (if (null? tree)
	'()
	(append (tree->list-1 (left-branch-tree tree))
		(cons (entry tree)
		      (tree->list-1 (right-branch-tree tree))))))
#+END_SRC

#+NAME: def:tree->list-2
#+BEGIN_SRC racket
  (define (tree->list-2 tree)
    <<sc:tree>>
    (define (copy-to-list tree result-list)
      (if (null? tree)
	  result-list
	  (copy-to-list (left-branch-tree tree)
			(cons (entry tree)
			      (copy-to-list (right-branch-tree tree) result-list)))))
    (copy-to-list tree '()))
#+END_SRC

#+NAME: consts:2.16
#+BEGIN_SRC racket
  <<sc:tree>>

  (define 2.16a (make-tree 7 (make-tree 3 (make-tree 1 nil nil) (make-tree 5 nil nil)) (make-tree 9 nil (make-tree 11 nil nil))))
  (define 2.16b (make-tree 3 (make-tree 1 nil nil) (make-tree 7 (make-tree 5 nil nil) (make-tree 9 nil (make-tree 11 nil nil)))))
  (define 2.16c (make-tree 5 (make-tree 3 (make-tree 1 nil nil) nil) (make-tree 9 (make-tree 7 nil nil) (make-tree 11 nil nil))))
#+END_SRC

#+BEGIN_SRC racket
  (tree->list-1 2.16a)
  (tree->list-1 2.16b)
  (tree->list-1 2.16c)

  (tree->list-2 2.16a)
  (tree->list-2 2.16b)
  (tree->list-2 2.16c)
#+END_SRC


I think it's clear these are equivalent by inspection.
Though, trees of Diag. 2.16 written up.

And, tree->list-2 is more efficient.
The key difference is the way recursion is structured.

tree->list-1 does recursion on both branches at the same time.
This leads to needing to combine two lists.
No problem with pointers, but here this means a lot of car and cdr.

tree->list-2 does recursion on the right braches and then on the left.
So, on the close of a recursion call the only task is to add whatever the current entry is.
Everything to the right is already reduced to a list.

** 2.64

partial-tree takes two arguments:

1. elts a list of elements
2. n an integer such that m ≤ (length elts)

The result is a balanced binary tree containing the first n elements of elts.
For exposition, we assume n = (length elts).

This is recursive.
And, the very short version is partial-tree splits elts into half, save for the middle element.
partial-tree is then applied to the left and right 'havles' and the result of partial-tree forms the left and right branches associated with the current element.
This recusrive application stops when there are no more elements in elts.

We can be sure this creates a balanced tree as by assumption elts is ordered.
If n is odd, there there's a unique middle element for the root.
And, if n is even then we can choose either (floor (/ n 2)) or (ceil (/ n 2)) as we can't do any better than a slightly lopsided tree.

Visually, the process is something like this, from left to right (where the last step incorporates a couple of recursive calls.)

                   3               3
                 /   \            / \
(1 2 3 4 5)   (1 2)  (4 5)       2   4
                                /     \
                               1       5

Growth should be n.
For, each recursive call is tasked with half the work, intuitively.
However, we still need to do the work on both halves.

** 2.65

For union, the easiest thing to do is adjoin.
The problem is, there's no guarantee this makes a balanced tree.
but, adjoin should be (log n), hence this would be (n log n).

I don't think anything quite so fancy is expected.

First, we can flatten both sets.
This can be done in Theta(n) using tree->list-2.
Then, as the lists are ordered, it's easy to combine these.
This is just union for the ordered list representation.
Finally, we rebuild the set.
This is then n.

#+BEGIN_SRC racket
  (define (union-set-b set1 set2)
    <<def-union-set-o>>
    <<def:tree->list-2>>
    (let ((unionOL (union-set-o (tree->list-2 set1) (tree->list-2 set2))))
      (partial-tree unionOL (length unionOL))))
#+END_SRC

Intersection is then analogous.

Note, creating a tree by adjoining each element wound't be as effective.
This would be n log n in the worst case, as the final adjoinment might need to go through the entire tree.
But, this isn't what we're doing.
When we have an ordered set, there's no need to search through a tree.

From a slightly broader perspective, then, we have a new structure which allows for some operations to be faster.
And, for some difficult operations with the new structure, we have a way to transform the new structure into an older structure where the operations are fairly simple.
And, this is done in a fairly effective way.

This does take some work, and Theta may be hiding some real-world overhead of transforming between structures.
But, this is very nice.
And, a great way to make an incremental improvement.
Indeed, it's easy to convert all of the old ordered list sets into binary tree sets.

** 2.66

#+NAME: def:lookup-b
#+BEGIN_SRC racket
  (define (lookup-b e set)
    <<sc:tree>>
    (cond ((null? set) false)
	  ((= (entry set) e) true)
	  (else (or (lookup-b e (left-branch-tree set)) (lookup-b e (right-branch-tree set))))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:lookup-b>>
  <<consts:2.16>>
  (lookup-b 1 2.16a)
  (lookup-b 2 2.16b)
  (lookup-b 9 2.16c)
#+END_SRC

Straightfoward.
Can't do better than n as may need to check every node.

** Huffman prep


#+NAME: sc:hf
#+BEGIN_SRC racket
  (define (make-leaf symbol weight)
    (list 'leaf symbol weight))

  (define (leaf? object)
    (eq? (car object) 'leaf))

  (define (symbol-leaf x) (cadr x))

  (define (weight-leaf x) (caddr x))

  (define (left-branch-tree tree) (car tree))

  (define (right-branch-tree tree) (cadr tree))

  (define (symbols tree)
    (if (leaf? tree)
	(list (symbol-leaf tree)) ; leaf, so 2nd elem, but make into a list on one
	(caddr tree))) ; tree so 3rd elem

  (define (weight tree)
      (if (leaf? tree)
	  (weight-leaf tree)
	  (cadddr tree)))

  (define (make-code-tree left right)
    (list left
	  right
	  (append (symbols left) (symbols right))
	  (+ (weight left) (weight right))))
#+END_SRC

#+NAME: def:choose-branch-hf
#+BEGIN_SRC racket
  (define (choose-branch bit branch)
    <<sc:hf>>
    (cond ((= bit 0) (left-branch-tree branch))
	  ((= bit 1) (right-branch-tree branch))
	  (else (error "bad bit -- CHOOSE-BRANCH" bit))))
#+END_SRC

#+NAME: def:decode-hf
#+BEGIN_SRC racket
  (define (decode bits tree)
    (define (decode-1 bits current-branch)
      <<def:choose-branch-hf>>
      <<sc:hf>>
      (if (null? bits)
	  '()
	  (let ((next-branch
		 (choose-branch (car bits) current-branch)))
	    (if (leaf? next-branch)
		(cons (symbol-leaf next-branch)
		      (decode-1 (cdr bits) tree))
		(decode-1 (cdr bits) next-branch)))))
    (decode-1 bits tree))
#+END_SRC

#+NAME: def:adjoin-set-hf
#+BEGIN_SRC racket
  (define (adjoin-set e set)
    <<sc:hf>>
    (cond ((null? set) (list e))
	  ((< (weight e) (weight (car set))) (cons e set))
	  (else (cons (car set)
		      (adjoin-set e (cdr set))))))
#+END_SRC

#+NAME: def:make-leaf-set-hf
#+BEGIN_SRC racket
  (define (make-leaf-set pairs)
    <<def:adjoin-set-hf>>
    <<sc:hf>>
    (if (null? pairs)
	'()
	(let ((pair (car pairs)))
	  (adjoin-set (make-leaf (car pair)
				 (cadr pair))
				 (make-leaf-set (cdr pairs))))))
#+END_SRC

Here, we can see pair should be a list, rather than a pair.

With decode a bit is always removed as we've either finished decoding or used the bit to move further into the tree.

** 2.67

#+NAME: consts:2.67
#+BEGIN_SRC racket
  <<sc:hf>>

  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
		    (make-code-tree
		     (make-leaf 'B 2)
		     (make-code-tree (make-leaf 'D 1)
				     (make-leaf 'C 1)))))

  (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+END_SRC

#+BEGIN_SRC racket
  <<consts:2.67>>
  <<def:decode-hf>>

  (decode sample-message sample-tree)
#+END_SRC

** 2.68

encode-symbol has a helper function which does most of the work.

In short, work through the tree until you get to a leaf.
If the symbol of the leaf matches the symbol taken as argumnet, we want to return the path we took to get here.
Otherwise, we want to do nothing.

If returning path, we start with nil.
To ignore results, return false.

If we're not at a leaf, we explore both left and right branches – the symbol could be anywhere in the tree!

If either branch is not false, then add the option we took to get this result.
If both branches are false, return false – the sym hasn't been found.

At the end, we replace false with the desired error message.


#+NAME: def:encode-symbol
#+BEGIN_SRC racket
  (define (encode-symbol sym tree)
    (define (encode-symbol-f sym tree)
      <<sc:hf>>
      (cond ((leaf? tree)
	     (if (equal? (symbols tree) (list sym))
		 nil
		 #f))
	    (else
	     (let ((leftResult (encode-symbol-f sym (left-branch-tree tree)))
		   (rightResult (encode-symbol-f sym (right-branch-tree tree))))
	       (cond ((not (equal? leftResult #f)) (cons 0 leftResult))
		     ((not (equal? rightResult #f)) (cons 1 rightResult))
		     (else #f)
		     )))))
    (let ((encode (encode-symbol-f sym tree)))
      (if (equal? encode #f)
	  (error "symbol not in tree -- ENCODE-SYMBOL" sym)
	  encode
	  )))
#+END_SRC


#+BEGIN_SRC racket
  <<consts:2.67>>
  <<def:encode-symbol>>

  (encode-symbol 'A sample-tree)
  (encode-symbol 'B sample-tree)
  (encode-symbol 'X sample-tree)
#+END_SRC

#+NAME: def:encode-hf
#+BEGIN_SRC racket
  (define (encode message tree)
    <<def:append>>
    <<def:encode-symbol>>
    (if (null? message)
	'()
	(append (encode-symbol (car message) tree)
		(encode (cdr message) tree))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:encode-hf>>
  <<consts:2.67>>
  (encode '(A D A B B C A) sample-tree)
#+END_SRC

** 2.69

#+NAME: successive-merge-hf
#+BEGIN_SRC racket
  (define (successive-merge set)
    <<def:adjoin-set-hf>>
    <<sc:hf>>
    (cond
      ((= (length set) 0) '())
      ((= (length set) 1) (car set))
      (else (successive-merge (adjoin-set (make-code-tree (car set) (cadr set)) (cddr set))))))
#+END_SRC

Testing successive-merge

#+BEGIN_SRC racket
  (define sfp (list (list 'A 4) (list 'B 2) (list 'C 1) (list 'D 1)))

  <<def:make-leaf-set-hf>>
  <<successive-merge-hf>>
  <<def:encode-hf>>

  (successive-merge (make-leaf-set sfp))
  (successive-merge (make-leaf-set (list )))

  (encode '(A D A B B C A) (successive-merge (make-leaf-set sfp)))
#+END_SRC

#+NAME: def:generate-huffman-tree-hf
#+BEGIN_SRC racket
  (define (generate-huffman-tree pairs)
    <<def:make-leaf-set-hf>>
    <<successive-merge-hf>>
    (successive-merge (make-leaf-set pairs)))
#+END_SRC

** 2.70

#+NAME: consts:2.70
#+BEGIN_SRC racket
  (define 80alphUO (list (list 'A 2)
			 (list 'BOOM 1)
			 (list 'GET 2)
			 (list 'JOB 2)
			 (list 'NA 16)
			 (list 'SHA 3)
			 (list 'YIP 9)
			 (list 'WAH 1)))

  <<def:accumulate>>
  <<sc:hf>>
  <<def:adjoin-set-hf>>
  (define 80alphOL (accumulate
		    (lambda (e s) (adjoin-set (make-leaf (car e) (cadr e)) s))
		    (list )
		    80alphUO))
  (define 80alphO
    (accumulate (lambda (e s) (cons (list (cadr e) (caddr e)) s)) nil 80alphOL))
#+END_SRC

So, I got a little sidetracked trying to order the list by a direct call to adjoin-set.
The issue is, adjoin-set only works with leaves.
Hence, to make this work, need to transform elements to leaves.
Then, of course, it's easy to revert the elemnts back once in ordered state.

Still, much easier to define an instance of ordered insert on symbol frequency pairs.
Or, just, y'know, generate the tree from an unordered list.
As, make-leaf-set ensures everything is ordered.

#+BEGIN_SRC racket
  <<consts:2.70>>
  <<def:generate-huffman-tree-hf>>
  (generate-huffman-tree 80alphUO)

  (length (generate-huffman-tree 80alphUO))
#+END_SRC

We need 4 bits for each symbol (I think, as height of the tree should correspond to the number of choices that need to be made).
So, to encode the song we need number of symbols * 4 bits.
Though, spaces are an issue, unless it's assumed there is a space after every symbol…

With fixed-length coding we'd need 3 bits.

The issue here is the first symbol.
As this is 0 (or 1), we 'loose' the rest of the bits.
As, every other symbol needs to begin with 1.

** 2.71

I think n bits.
The issue here is that the combined weight of the previous two merges is always going to be less than the weight of the next sym-freq pair.
Hence, the tree is created one branch at a time.

Stated a little more intuitively, the idea of Huffman encoding is to trade any remaining bits used to store information so long as we do not expect to use those bits to access information more often that the information we're currently accessing.

And, this sequence is such that we always expect to use the current piece of information at least as much as any following piece of information.

So, we get a tree which has no balance.

** TODO 2.72

I'd like to consider the general case.

And, also, work through a few more basic problems first.

** 2.73
*** a.

For this rewrite of deriv we allow adding arbitrary operations by add and get.
However, get is defined to take an operator.
And, then get returns a procedure corresponding to the operator.

It is not possible to assimilate the predicates namer? and same-variable? in this way as these function as tests on whether the expression contains an operator.
Note, in particular, this test is implicit to same-variable?, which ensures the two expressions are varaiables, and then tests for equality.

Put slightly differently, an expression contains an operator if and only if it is neither a number nor a variable.
As the call to get requires an operator, we must perform some tests to ensure the expression is neither a number nor a variable before the call to get can do some work. This is what the two predicates do.

*** b.

Our original procedure for symbolic differentation looked like this:

#+BEGIN_SRC racket :tangle no
  (define (deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp) (if (same-variable? exp var) 1 0))
	  ((sum? exp)
	   (make-sum
	    (deriv (addend exp) var)
	    (deriv (augend exp) var)))
	  ((product? exp) (make-sum
			   (make-product (multiplier exp)
					 (deriv (multiplicand exp) var))
			   (make-product (deriv (multiplier exp) var) (multiplicand exp))))
	  ; (more rules can be added here)
	  (else (error " unknown expression type -- DERIV" exp))))
#+END_SRC

With data-directed programming, we have the option of making deriv addidative.

On way of approaching this rewrite is to write out functions for each type combination.
For example, make-sum starts to look something like this:

#+BEGIN_SRC racket :tangle no
  (define (make-sum-numbers exp1 exp2) (+ exp1 exp2))

  (define (make-sum-sym exp1 exp2) (list '+ exp1 exp2))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (put 'make-sum '(number number) make-sum-numbers)

  (put 'make-sum '(symbol symbol) (list '+ exp1 exp2))
#+END_SRC

Indeed, ~'deriv~ already does some basic type checking.
However, the approach taken is to use data-directed programming to obtain arbitrary operators relative to ~'deriv~, without type-checking.

The base code given is:

#+BEGIN_SRC racket :tangle no
  (define (deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp) (if (same-variable? exp var) 1 0))
	  (else ((get 'deriv (operator exp)) (operands exp) var))))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))
#+END_SRC

So, the call to get takes ~'deriv~ and the operator.
Hence, the procedure we define does not work on typed objects.
So, ~make-sum~ is close to before.
Though, now we have a list of expressions and a variable, and maybe the need to call ~'deriv~.

#+BEGIN_SRC racket :tangle no
  (define (make-sum exps var)
    (let ((exp1 (car exps))
	  (exp2 (cadr exps)))
      (cond ((=number? exp1 0) exp2)
	    ((=number? exp2 0) exp1)
	    ((and (number? exp1) (number? exp2)) (+ exp1 exp2))
	    (else (list '+
			((get 'deriv (operator exp1)) (operands exp1) var)
			((get 'deriv (operator exp2)) (operands exp2) var))))))
#+END_SRC

Note, the ~number?~ cases function like base cases.
There's nothing more to be done.
And, the ~else~ case just breaks down the expression one step.


To make this available, we ~put~ a suitable name relative to ~'deriv~.
For example:

#+BEGIN_SRC racket :tangle no
  (put 'deriv 'make-sum make-sum)
#+END_SRC

And perhaps:

#+BEGIN_SRC racket :tangle no
  (put 'deriv '+ make-sum)
#+END_SRC

Here, with the data-directed approach we have a lot of flexibility with the possible operator symbols.

~make-product~ is transformed in an analogous way.

*** c.


I don't think this is sufficiently different from part b.

*** d.


We'd need to update each of the helper functions, as these may calls to ~get~.
Aside from this, no significant changes are required.

However, things could get complex.
For, in addition to ~'deriv~, the same operators may be associated with other procedures.
As things are originially, there's nothing too difficult.
Rather than ~'deriv~ we'd have a name for the new procedure, and specify operators relative to the procedure.

However, on the proposed change we'd need to ensure each existing operator was appropriately disambiguated.

Well, I'd guess.
We have a lookup table and ordered argumnets.
So, I would expect ~get~ searches by row then column or vice-versa.
If ~get~ doesn't work this way, then there's nothing too signficant.

** 2.74

I don't think there's need to write anything specific for this exercise.
So, high level answers follow.

In general, we follow data-directed dispatch.
Where dispatch follows the division.

Note, there should be a unique name for each division recgonised by central.

In this way, each division can set common functions relative to their division and only need to know:

1. Which common functions to write.
2. The name of their division.

*** a.

Personnel files are single files containing a set of records keyed to employee names, relative to each division.
So, get-record will use the division's procedure for opening their personnel file and searching through the set to find the employee name and record.

Ideally, central will specify a general form for the record to take.
If so, each division can transform however their record is stored into something of the same form as obtained from other divisions.

Depending on what else is going on, one may wish to implement a procedure for obtaining the raw record and also make any transformation procedures public.

With no further modifications, central would need to supply a division to dispatch on and an employee name.
Though, employee names could be tagged with the division to which they belong.
Though, if names are unique and requests for records are infrequent, it may make sense to search through each division.

*** b.

Ah, get-salary is a special case of the above.
We'd require each division to implement a salary option.
The way records are structured is up to each division.

*** c.

For find-employee-record we're given a name and all the files of a division.
The first, and only significant, task is to obtain the personnel records file.
As each division has one of these, it seems easiest to require each division to set to a generic return-records procedure.
Or, a generic find-employee-record.

A beneift of the former is a way for central to combine generic arguments.

Without central knowing the way each division stores their files, nothing more can be done.
E.g. one division may store their files as a list, while another may have a Huffman tree based on files access frequency.

*** d.

I'm not sure what 'the new personnel information' refers to.
This isn't new information about employees, and the only other information considered is old to each division.

Central needs to write generic functions, along with put and get procedures.
And, let each division know about all of this!

** 2.75

In mess-age passing style make-from-real-imag is as follows:

#+BEGIN_SRC racket
  (define (make-from-real-imag x y)
    (define (dispatch op)
      (cond ((eq? op 'real-part) x)
	    ((eq? op 'imag-part) y)
	    ((eq? op 'magnitude)
	     (sqrt (+ (square x) (square y))))
	    ((eq? op 'angle) (atan y x))
	    (else
	     (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
    dispatch)
#+END_SRC

make-from-real-imag takes two arguments, the real and imaginary part of the complex number, respectively.
In return, a procedure is given which takes the name of a procudeure and then performs the procedure on the arguments initially given.

Working with magnitudes and angles, we have a very similar procedure.
Though, here mangitudes and angles are stored, and real and imaginary parts are calculated.

#+BEGIN_SRC racket
  (define (make-from-mag-ang mag ang)
    (define (dispatch op)
      (cond ((eq? op 'real-part) (* mag (cos ang))
	    ((eq? op 'imag-part) (* mag (sin ang))
	    ((eq? op 'magnitude) mag)
	    ((eq? op 'angle) ang)
	    (else
	     (error "Unknown op -- MAKE-FROM-MAG-ANG" op))))
    dispatch)
#+END_SRC

** 2.76
**** Generic operations with explict dispatch

For generic operations with explicit dispatch, adding a new type amounts to tagging objects with the relevant type.
This is very much the same as data-directed style.
However, if we expect existing procedures to extend to the new type, we need to update the procedure definitions with conditions for the type.

And, any new operation needs to be defined.

**** Data-directed style

For a new type we should provide a way of tagging objects as the relevant type, define isolated procedures on the relevant objets and then ~put~ these procedures on the table.

As with generic operations with explict dispatch, we need to explictly extend existing procedures to the new types.
However, this doesn't necessarily involve writing anything new.
For, with ~put~ we can associate an existing procedure with the new type, so long as the procedure works as intended on the typed object.

Ideally, though, we would design a package with constructors, selectors, and all other procedures for the relevant type.

In contrast to message-passing style, we don't introduce 'new' objects.
However, we do introduce a way of disamguating the way we interact with familar lisp lists based on types.

**** Message-passing style

For a new type we need to specify a constructor, and internal to this we have the relevant selectors.

For new procedures, it depends.
Procedures like ~make-from-real-imag~ and ~make-from-mag-ang~ return an object, and for procedures on the object, we should specify messages to recieve.

For other procedures I'm not sure.
And, to be honest I'm not sure with the two procedures either.

For, from a general perspective, each operator can be seen as an object.
In this sense, something which takes two objects could recieve a message, such as ~make-from-real-imag~ or ~+~ and then work out what to do.
On the other hand, we're still building everything from the foundations of lisp, so you should decide whether the procedure is creating an object that should recieve messages.
And, if so write out ways to handle those messages.

** 2.77

The important thing to keep in mind with the data-directed style is that as soon as we remove types, everything is basic lisp.
So, as long as ~real-part~, etc. work on complex numbers, there's no issue associating ~real-part~ with the ~complex~ type.

#+BEGIN_SRC racket :tangle no
  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (error
	     "No method for these types -- APPLY-GENERIC"
	     (list op type-tags))))))
#+END_SRC

The represenation of 3 + 4i in rectungular form in Figure 2.24, written in standard form is:

#+BEGIN_SRC racket  :tangle no
  ('complex ('rectangular (3 4)))
#+END_SRC

We have evaluated:

#+BEGIN_SRC racket  :tangle no
  (put 'magnitude '(complex) magnitude)
#+END_SRC

However, this means there's room for some ambiguity.
The expression we're asked to evaluate is ~(magnitude z)~, but should this be read ~('magnitude z)~?
This is resolved when recalling on p. 184 we have:

#+BEGIN_SRC racket  :tangle no
  (define (magnitude z) (apply-generic 'magnitude z))
#+END_SRC

Our task is to evaluate ~(magnitude z)~.
In turn, this amounts to evaluating ~(apply-generic 'magnitude z)~.
Putting in the value for ~z~, we have:

#+BEGIN_SRC racket  :tangle no
  (apply-generic 'magnitude ('complex ('rectangular (3 4))))
#+END_SRC

Expanded:

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags (map type-tag ('complex ('rectangular (3 4))))))
    (let ((proc (get 'magnitude type-tags)))
	  (if proc
	      (apply proc (map contents ('complex ('rectangular (3 4)))))
	      (error
	       "No method for these types -- APPLY-GENERIC"
	       (list 'magnitude type-tags))))))
#+END_SRC

Recall, the definition of ~type-tag~ is:

#+BEGIN_SRC racket  :tangle no
  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error " Bad tagged datum -- TYPE-TAG" datum)))
#+END_SRC

So, applying the first ~map~ we obtain:

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags 'complex))
    (let ((proc (get 'magnitude 'complex)))
	  (if proc
	      (apply proc (map contents ('complex ('rectangular (3 4)))))
	      (error
	       "No method for these types -- APPLY-GENERIC"
	       (list 'magnitude 'complex))))))
#+END_SRC

At this point, Alyssa's procedure is used for the second ~let~!

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags 'complex))
    (let ((proc magnitude))
	  (if proc
	      (apply proc (map contents ('complex ('rectangular (3 4)))))
	      (error
	       "No method for these types -- APPLY-GENERIC"
	       (list 'magnitude 'complex))))))
#+END_SRC

As we have a ~proc~, we need ~contents~ for the second ~map~.
Here it is:

#+BEGIN_SRC racket  :tangle no
  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error " Bad tagged datum -- TYPE-TAG" datum)))
#+END_SRC

So, we get:

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags 'complex))
    (let ((proc magnitude))
	  (if proc
	      (apply proc ('rectangular (3 4)))
	      (error
	       "No method for these types -- APPLY-GENERIC"
	       (list 'magnitude 'complex)))))
#+END_SRC

So, now our task is to evaluate ~(apply proc ('rectangular (3 4)))~.
Where ~proc~ is ~magnitude~.
It's the same problem as above, where evaluating ~magnitude~ makes results in a call to ~apply-generic~.
Alyssa's procedure works because ~'complex~ is just a wrapper for ~'rectangular~ and ~'polar~.
So, by making a second call to ~magnitude~ we're effectively ignoring the ~'complex~ type.
Though, this is only with respect to the version of ~magnitude~ installed by the complex package.

So, the process starts again!
This time, though, the type is ~'rectangular~.
So, the version of ~magnitiude~ installed by the rectangular package is used.

#+BEGIN_SRC racket  :tangle no
  (let ((type-tags ('rectangular)))
    (let ((proc magnitude))
      (if proc
	  (apply proc (3 4))
	  (error
	   "No method for these types -- APPLY-GENERIC"
	   (list 'magnitude type-tags)))))
#+END_SRC

So, we get to:

#+BEGIN_SRC racket  :tangle no
  (magnitude (3 4))
#+END_SRC

#+BEGIN_SRC racket  :tangle no
  (sqrt (+ (square (real-part (3 4)))
	   (square (imag-part (3 4)))))
#+END_SRC

Here, these functions are internal to the package.
So, we get:

#+BEGIN_SRC racket  :tangle no
  (sqrt (+ (square (car (3 4)))
	   (square (cdr (3 4)))))
#+END_SRC

I.e.

#+BEGIN_SRC racket  :tangle no
  (sqrt (+ (square 3)
	   (square 4)))
#+END_SRC

In total, then, we make two calls to ~apply-generic~.

** 2.78

The initial definitions of ~type-tag~, ~contents~, and ~attach-tag~ are as follows:

#+BEGIN_SRC racket :tangle no
  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error " Bad tagged datum -- TYPE-TAG" datum)))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS " datum)))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (define (attach-tag type-tag contents)
    (cons type-tag contents))
#+END_SRC

To extend these so the generic system takes advantage of Scheme's interval type system using ~symbol?~ and ~number?~ we make use of some ~cond~ instances.

#+BEGIN_SRC racket :tangle no
  (define (type-tag datum)
    (cond ((pair? datum) (car datum))
	  ((number? datum) ('number))
	  ((symbol? datum) ('symbol))
	  (else error " Bad tagged datum -- TYPE-TAG" datum)))
#+END_SRC


#+BEGIN_SRC racket :tangle no
  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
	  ((number? datum) datum)
	  ((symbol? datum) datum)
	(error "Bad tagged datum -- CONTENTS " datum)))
#+END_SRC

~attach-tag~ is a little puzzling.
As specified, ~attach-tag~ takes a tag argument and contents.
So, there's no room for making use of Scheme's internal type system.
A type must be given!

However, if we reverse the order of arguments, then we can make the type optional.

#+BEGIN_SRC racket :tangle no
  (define (attach-tag contents . type-tag)
    (cond ((number? contents) (cons 'number contents))
	  ((symbol? contents) (cons 'symbol contents))
	  (else (cons type-tag contents))))
#+END_SRC

** 2.79

Or, maybe…

#+BEGIN_SRC racket
  (define (equ? a b)
    (let ((type-a (type-tag a))
	  (type-b (type-tag b)))
      (get 'equ type-a type-b) a b))
#+END_SRC

I don't think this is too interesting.

- We already have a test for ordinary numbers.
- With rational numbers, we probably want to test the reduced form of both number, unless there's a guarantee these numbers have been provided by make-rational.
- Complex numbers will have two cases, depending on the representation.
  As the procedure works on typed objects directly, I'd suggest three procedures.
  On for rectangular, one for polar, and the final for either rectangular or polar.
  The latter, of course, reduces to one of the former, similar to ~magnitude~, above.

So, the general structure would be:

#+BEGIN_SRC racket :tangle no
  (define (install-equ-package)
    (define (equ-number a b) (…))

    …

    (put 'equ '(number number) (equ-number))

    …
    )
#+END_SRC

In contrast to the other packages, there's no need to tag the result.
Unless, that is, we like ~bool~.

** 2.80

In terms of installing the package, this is no different from the above.
Noting, of course, ~zero?~ takes a single argumnet.

So, I guess the only interesting thing here is writing the inidivudal functions?

I'll pass on this.

I get the feeling these are exercises designed so something which involves writing code can be assigned in a class.
Perhaps there's something interesting!
But, I think the cost of finding out is too high…

** 2.81

#+BEGIN_SRC racket :tangle no
  (define (apply-generic op . args)
    (let ((type-args (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (if (= (length args) 2)
		(let ((type1 (car type-tags))
		      (type2 (cadr type-tags))
		      (a1 (car args))
		      (a2 (cadr args)))
		  (let ((t1->t2 (get coercion type1 type2))
			(t2->t1 (get coercion type2 type1)))
		    (cond (t1->t2 (apply-generic op (t1->t2 a1) a2))
			  (t2->t1 (apply-generic op a1 (t2->t1 a2)))
			  (else
			   (error "No method for these types" (list op type-tags))))))
		(error "No method for these types" (list op type-tags)))))))
#+END_SRC

Louis observes ~apply-generic~ may try to coerce the arguemnts to each others type even if they already have the same type.

This certainly happens if there's no procedure for the types in question.
As, coercion is attempted without any further check.

And, as coercion is only attempted if no procedure is found, this is the only way it happens.

So, why not turn the ~if~ into a ~cond~ and first check to see whether all the types are the same?

Setting this aside!

*** a.

If we call ~exp~ with two complex numbers as arguments then we get an error.
~proc~ will not be found, and coercion from complex to complex will be attempted.
But, ~exp~ only has an entry on scheme-numbers, and coercion is only attempted relative to the other argument (of a pair).

*** b.

I think ~apply-generic~ works as is.

*** c.

Ah, this is what I was thinking before.

Here's a helper function I think I may have written before to check whether every item in a list is the same as a given element.

#+NAME: def:list-of-elem
#+BEGIN_SRC racket
  (define (list-of-elem elm l)
    <<def:accumulate>>
    (accumulate (lambda (x y) (and (equal? x elm) y)) #t l))

  (list-of-elem 0 (list 0 0 0))
#+END_SRC

We use ~list-of-elem~ see whether all the types given are equal.
As ~list-of-elem~ takes an arbitrary list, this is done /before/ we limit ourselves to binary operators.

#+BEGIN_SRC racket :tangle no
  (define (apply-generic op . args)
    <<def:list-of-elem>>
    (let ((type-args (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (cond ((= (length args) 0)
		   (error "No arguments given to an operator of arity > 0"))
		  ((list-of-elem (car type-tags) type-tags)
		   (error "No method for this type (for all arguments)" (list op (car type-tags))))
		  ((= (length args) 2)
		   (let ((type1 (car type-tags))
			 (type2 (cadr type-tags))
			 (a1 (car args))
			 (a2 (cadr args)))
		     (let ((t1->t2 (get coercion type1 type2))
			   (t2->t1 (get coercion type2 type1)))
		       (cond (t1->t2 (apply-generic op (t1->t2 a1) a2))
			     (t2->t1 (apply-generic op a1 (t2->t1 a2)))
			     (else
			      (error "No method for these types" (list op type-tags)))))))
		  (else	(error "No method for these types" (list op type-tags))))))))
#+END_SRC

** 2.82

Attempting to coerce arguments to types given isn't ideal.
Sometimes, different type.

For example, scalar multiplication with a rational.

Though, this has it's own problems.
Should the result be a vector of scheme-numbers or of rationals?

Still, nothing here really relies on arguments other than two.

And, the same observation applies to predicates.
For example, ~prime?~ appplies to rational numbers, as natural numbers are a subset.
But, there's no possible additional argument to obtain the ~scheme-number~ type from.

So, is there something interesting which happens with more than two arguments?
I'm not sure.
For example, perhaps we have three arguments, and we'd like to coerce the second argumnet to the type of the first argumnet, but leave the type of the third argument as is.
This isn't possible on the current approach, but I can't think of a natural procedure which would have this form.

In any case, a naive approach is to modify the ~(= (length args) 2)~ case.
Instead of working with the two types explicitly, we consider the arity of the operation (e.g. by ~(length type-args)~) and all the types given.
Then, consider all possible permutations of those types which match the arity.

I.e. we'd have a way of getting all permutations.
Then, we'd have a sub-procedure which takes ~tpye-args~, the permutation, and the arguments.
The sub-procedure then attempts coercion, and if coercion is possible, returns the result of applying the procedure after coercion.

At this point, there are two things we could do.

First, we could return the first successful coercion.
This makes sense if there's no possibility of coercing things in unexpected ways.

Second, we could collect all the successful coercions.
And, only return a result if all the coercions match.

On the first approach we may end up with either a scheme-number or rational, depending on which coercion was attempted first.
On the latter approach we'd end up with a scheme-number only if there was no coercion which resulted in a rational number.

So, this is all quite open-ended.
At the moment, here's some functions which build up to permuting a list up to some length.

First, a way to prepend an item to everything in a list.

#+NAME: def:prepend-to-all
#+BEGIN_SRC racket
  (define (prepend-to-all item list-of-lists)
    (map (lambda (x) (cons item x)) list-of-lists))
#+END_SRC

Second, an extension to a list of items.

#+NAME: def:prepend-items-to-lists
#+BEGIN_SRC racket
  (define (prepend-items-to-lists items list-of-lists)
    <<def:prepend-to-all>>
    <<def:flatmap>>
    (flatmap ((lambda (x) (lambda (y) (prepend-to-all y x))) list-of-lists) items))
#+END_SRC

#+NAME: def:permute-to-n
#+BEGIN_SRC racket
  (define (permute-to-n l n)
      (define (permute-items-to items list-of-list n)
	<<def:prepend-items-to-lists>>
	(if (= 1 n)
	    list-of-list
	    (permute-items-to l (prepend-items-to-lists items list-of-list) (- n 1))))

      (cond ((= n 0) '())
	    ((= n 1) (map (lambda (x) (list x)) l))
	    (else (permute-items-to l (map (lambda (x) (list x)) l) n))))
#+END_SRC

Quick test:

#+BEGIN_SRC racket
  <<def:permute-to-n>>
  (permute-to-n (list 'a 'b 'c 'd) 0)
  (permute-to-n (list 'a 'b 'c 'd) 1)
  (permute-to-n (list 'a 'b 'c 'd) 3)
#+END_SRC

This is a lot of checking.
Though, if we had direct access to a coercion table things could be improved.
As, we could gather the possible coercions for each argument in a list, and consider all permutations drawing from types in the respective list.
Though, this would require a modified function.

** 2.83

Here we have a simple tower of types:

#+BEGIN_SRC racket :tangle no
  integer => rational => real => complex
#+END_SRC

It's possible to raise a type, as there is always a unique super-type (expect in the case of ~complex~).

So, the simplest way to implement a generic raise operation is to use ~apply-generic~.
For, this will evaluate ~(get 'raise type)~.
Hence, we have:

#+NAME: def:raise
#+BEGIN_SRC racket
  (define (raise exp) (apply-generic 'raise exp))
#+END_SRC

Now, we only need to ~put~ various procedures.
For example (as $n = n/1$):

#+BEGIN_SRC racket
  (define (integer-to-rational n) (make-rational n 1))
#+END_SRC

And then:

#+BEGIN_SRC racket
  (put 'raise '(integer) integer-to-rational)
#+END_SRC

This means the hierarchy is spread throughout the code.
So, an alternative method is to store the hierarchy as a list.
Then, given an expression, we use the list to find the relevant transform type.
However, this doesn't lend well to a generic ~raise~ procedure, as asked for.

** 2.84

It's fairly easy to implement a general method for finding the type of a raised expression.
For example, we can start with:

#+BEGIN_SRC racket
  (define (raised-type exp)
    <<def:raise>>
    (type-tag (raise exp)))
#+END_SRC

Then, substitute this for a generic version of raised-type.

With this, we could keep raising the type of an expression to create a list of the possible raises.
Then, we just need to search for the first match in the lists.

The issue is ~raised-type~ can't rely on or be generic here.
For, we'll need to figure out a way to see there's no possibility of raising a type any further.
To do this we'd need to observe ~raised-type~ does not return a type.
But, this will result in an error.

So, implementing ~raised-type~ via ~raise~ isn't a good first step.
However, implementing a generic ~raised-type~ is fine.

#+NAME: def:raised-type
#+BEGIN_SRC racket
  (define (raised-type exp) (apply-generic 'raised-type exp))
#+END_SRC

#+BEGIN_SRC racket
  (define (integer-to-rational-type n) '(rational))
#+END_SRC

We just have many simple procedures.
For example:

#+BEGIN_SRC racket
  (put 'raised-type '(integer) integer-to-rational)
#+END_SRC

Or quick lambdas.
Such as:

#+BEGIN_SRC racket
  (put 'raised-type '(integer) (lambda (x) '(rational)))
#+END_SRC

However, key is the option of returning ~nil~.

#+BEGIN_SRC racket
  (put 'raised-type '(complex) nil)
#+END_SRC

With this, we can now reconstruct the heirarchy above a certain type:

#+BEGIN_SRC racket
  (define (get-above-types type)
    (if (null? type)
	nil
	(cons type ((get-above-types (raised-type type))))))
#+END_SRC

This is little more than recursively keeping track of the current type and moving to a super-type before combining everything into a list.

Now, we can find the first match fairly easily.
We know both types are part of a hierarchy, so if we start at the top of the hierarchy, we are sure to have a match.
We can store this, and then continually move down the hierarchy checking for matches.
As soon as a match fails to be found, we've attempted to move to a subtype of one of the types.
Hence, we should return the stored last match.

As a general procedure which works on any two lists, we have something like this:

#+NAME: def:first-match
#+BEGIN_SRC racket
	(define (first-match l1 l2)
	  (define (first-match-reversed l1 l2 previous)
	    (cond
	      ((or (not (pair? l1)) (not (pair? l2))) previous)
	      ((not (equal? (car l1) (car l2))) previous)
	      (else (first-match-reversed (cdr l1) (cdr l2) (car l1)))))
	  (let ((l1R (reverse l1))
		(l2R (reverse l2)))
	    (first-match-reversed l1R l2R nil)))
#+END_SRC

But, we can extend this to work on an arbitrary number of lists in the following way:

#+NAME: def:first-match-lists
#+BEGIN_SRC racket
      (define (first-match-lists lists)
	(define (first-match-reversed lists previous)
	  <<def:accumulate>>
	  <<def:filter>>
	  (cond
	    ((accumulate (lambda (x y) (or (not (pair? x)) y)) #f lists)
	     previous)
	    ((not (= (length lists) (length (filter (lambda (x) (equal? (car x) (car (car lists)))) lists))))
	     previous)
	    (else
	     (first-match-reversed (map cdr lists) (car (car lists))))))
	(first-match-reversed (map reverse lists) nil))
#+END_SRC

The second ~cond~ condition is a little messy here.
Effectively, we're ensuring the first element of every list is the same.
To do this we filter the list of lists by equality of the first element of the first list and then check to see no lists have been omitted.

Here are some tests:

#+BEGIN_SRC racket
   <<def:first-match-lists>>

  (first-match-lists (list (list 'a 'b 'c 'd) (list 'a 'b 'c 'd)))

  (first-match-lists (list (list 'b 'c 'd) (list 'a 'b 'c 'd)))

  (first-match-lists (list (list 'd) (list 'a 'b 'c 'd)))

  (first-match-lists (list (list 'b 'c 'd) (list )))

  (first-match-lists (list (list ) (list )))

  (first-match-lists (list (list 'a 'b 'c 'd) (list 'b 'c 'd) (list 'c 'd)))

  (first-match-lists (list (list 'a 'b 'c 'd) (list 'b 'c 'd) (list 'c 'd) (list 'd)))
#+END_SRC

Note, by using ~first-match~ we'll get a return of ~nil~ if the types do not belong to the same hierarchy.
So, with ~apply-generic~ we now switch out everything after a test for the same type to include a test for a shared type between all the arguments.
If a shared type is found, then each argumnet is coerced to that type.
Otherwise, no method is available.

It's easy to recusively raise a type so long as we have a guarntee raising is possible, which we do have in this case:

#+BEGIN_SRC racket
  (define (raise-to-type exp type)
    (if (equal? (type-tag exp) type)
	exp
	(raise-to-type (raise exp) type)))
#+END_SRC

So, to finish things off, we raise each type to the shared type.

#+BEGIN_SRC racket :tangle no
  (define (apply-generic op . args)
    <<def:list-of-elem>>
    (let ((type-args (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (cond ((= (length args) 0)
		   (error "No arguments given to an operator of arity > 0"))
		  ((list-of-elem (car type-tags) type-tags)
		   (error "No method for this type (for all arguments)" (list op (car type-tags))))
		  ;; Here, we figure out the shared type.
		  (else (let ((sharedType (first-match-lists (map get-above-types type-args))))
			  if (sharedType)
			  ;; Here we raise each type to the shared type.
			  (apply-generic op (map (lambda (x) (raise-to-type x sharedType)) args))
			  (error "No method for these types" (list op type-tags))
			  )))))))
#+END_SRC

** MAYBE 2.85

Really? I think this is a mix of everything done above.
So, I'm not sure what the payoff is.

I may come back to this…

** MAYBE 2.86

Wow, this is an exercise!

Though, I'm not sure what the goal is.

If it's to simply work with numbers input in various ways, then we could simply raise everything as high as possilbe.
So, the reals and complex numbers, I think.
Or, maybe just complex numbers.
Though, trig. operations such as sine… might not be defined for complex numbers.

So, an upshot of this exercise is finding out some limits of creating generic operations and coercion, while also recognising benefits of cases avoided.

And, with coercion there's no real worry out the resultant type.
If a different type was desired, and possible, then it's easy to coerce.

For now this is a maybe.
I can see why these exercises are interesting, though.
And, especially at the time, I imagine this was an interesting avenue for research.
And, I recognise dynamic typing is a thing which may work in the way described here.
But, I'm not sure it's worth going through everything while ~put~ and ~get~ are still out of reach.

** 2.87

~zero?~ for polynomials checks to see whether every coefficient is 0.

The following should do the trick.
~accumulate~ walks through ~(term-list poly)~ where ~x~ is the next element to process and ~y~ is the result of previously processed elements.
So, we conjoin the previously processed elements with a check on whether the current term has a coefficient of 0.

#+BEGIN_SRC racket
  (define (zero? poly)
    <<def:accumulate>>
    (accumulate (lambda (x y) (and (= 0 (coeff x)) y)) #t (term-list poly)))
#+END_SRC

Here are a few tests, where the term lists are written by hand, and ~cadr~ replaces ~coeff~.

#+BEGIN_SRC racket
  <<def:accumulate>>
  (accumulate (lambda (x y) (and (= 0 (cadr x)) y)) #t (list (list 5 6) (list 3 1) (list 2 6) (list 1 5)))

  (accumulate (lambda (x y) (and (= 0 (cadr x)) y)) #t (list (list 5 6) (list 3 1)))

  (accumulate (lambda (x y) (and (= 0 (cadr x)) y)) #t (list (list 5 0) (list 3 1)))

  (accumulate (lambda (x y) (and (= 0 (cadr x)) y)) #t (list (list 5 0)))
#+END_SRC

Given I've used this idea twice, here's the general form:

#+NAME: def:big-and
#+BEGIN_SRC racket
  (define (big-and predicate list)
    <<def:accumulate>>
    (accumulate (lambda (x y) (and (predicate x) y)) #t list))
#+END_SRC

#+NAME: def:big-or
#+BEGIN_SRC racket
  (define (big-or predicate list)
    <<def:accumulate>>
    (accumulate (lambda (x y) (or (predicate x) y)) #f list))
#+END_SRC

So, we can write:

#+BEGIN_SRC racket :tangle no
  (define (zero? poly)
    <<def:big-and>>
    (big-and (lambda (x) (= 0 (coeff x))) (term-list poly)))
#+END_SRC

And this should work exactly as the other definition.

** 2.88

The basic subtraction operator mirrors addition.
Where, all the work is passed on to ~sub-terms~:

#+BEGIN_SRC racket :tangle no
  (define (sub-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
	(make-poly (variable p1)
		   (sub-terms (term-list p1)
			      (term-list p2)))
	(error "Polys not in same var -- SUB-POLY" (list p1 p2))))
#+END_SRC

Here, our work is a little easier by observing $(x - y) = (x + (- y))$.

#+BEGIN_SRC racket :tangle no
  (define (sub-terms L1 L2)
    (add-terms L1 (negate-terms L2)))
#+END_SRC

In turn, we can break down the term list as usual, applying a unary negation operator on the coeffectient of terms.

#+BEGIN_SRC racket :tangle no
  (define (negate-terms term-list)
    (if (null? term-list)
	nil
	(let ((term (car term-list)))
	  (cons (make-term (order term) (negate (coeff term))) (negate-terms (cdr term-list))))))
#+END_SRC

At this point, it makes sense to use to generic procedure.

#+BEGIN_SRC racket :tangle no
  (define (negate z) (apply-generic 'negate n))
#+END_SRC

So, our task now reduces to writing out the negate operator for each relevant type and then using ~put~ to make these accessible.
For example, we'd write something like the following for rationals:

#+BEGIN_SRC racket :tangle no
  (define (negate rational)
    (make-rational (negate (numerator rational)) (denomenator rational)))
#+END_SRC

Here, we simply negate the numerator.
Here, again, negate is dynamically applyed to whatever type the numerator is.

The simplest case is basic numbers.
Here, we define:

#+BEGIN_SRC racket :tangle no
  (define (negate number) (- number))
#+END_SRC

Ah, so peaceful!

** 2.89

For dense polynomals…

Ah, this is not fun.
Instead of a set of order coefficient pairs we'd work with a list for which the $i$th index is the coeffciient for the $i$th order.
This is quite the headache.
As, we pass around terms isolated from the term list.
And, these need to have order information.
But, in the case of dense polynomials, this means we either translate to sparse representation or have a dense representation which is mostly empty.
And, as we don't have sparse/dense typing, only the latter is sensbile.
(Though, if you really wanted you could inspect the structure of the data, but this seems a little unsafe.)

- ~adjoin-term~ would basically merge two lists, where the adjoining term is a list empty but for one place.
- ~first-term~ would ~car~ the term-list
- ~rest-terms~ would ~cdr~ the term-list
- ~make-term~ would create a list of (- order 1)~ 0s, and then the coeffecient.
- ~order~ would ~car~ the list until something non-zero is found, and return the number of ~car~ applied plus one or error if nil is found.
- ~coeff~ would ~car~ the list until something non-zero is found, and return whatever that is or zero is nil is found.

I think that covers everything.

** MAYBE 2.90

Ah, so this exercise is to implement sparse/dense typing.

In short, we need to introduce generic procedures for dealing with polynomials.

And, on top of this work out a function for concerting between the two types.

Is there interesting trade-off here?
For sparse representation, when searching through the terms we need to make a comparison.
While, with dense representation we only need to walk to a certain point in the list.
But, if the comparison is assumed to take a constant about of time, there's not going to be a $\Theta$ difference.
As, it's $n$ ~car~ and ~null?~ instances versus $n$ ~car~, ~car~, ~=~, and ~null?~ instances.
It is double, but doubling of a constant.

So, we're very much into detailed efficiency.
And, this is arguably going to rely on information about the way the system is used, what equality checking involves, etc.

Ah, well, this is almost-certainly-skip-maybe.

** 2.91

Something like this?

#+BEGIN_SRC racket :tange no
  (define (div-terms L1 L2)
    (if (empty-list? L1)
	(list (the-empty-termlist) (the-empty-termlist))
	(let ((t1 (first-term L1))
	      (t2 (first-term L2)))
	  (if (> (order t2) (order t1))
	      ;; When order or divisor is greater than order of dividend, the dividend is the remainder
	      (list (the-empty-termlist) L1)
	      ;; Else, we can do some work
	      (let ((new-c (div (coeff t1) (coeff t2)))
		    (new-o (- (order t1) (order t2))))
		(let ((rest-of-result
		       ;; Compute rest of result recursively, with the inputs described.
		       (div-terms (sub-terms L1 (mult-terms (make-term new-c new-o) L2)) L2)))
		  ;; Form complete result by taking the quotient and adding the term obtained, and leaving the remainder as is.
		  ;; However, also check we shouldn't be returning zero
		  (let ((newQuoteient (cons (make-term new-c new-o) (car rest-of-result)))
			(newRemainder (cdr rest-of-result))
			(if (zero? newQuoteient)
			    (cons (cons 0 0) '(cons 0 0)) ;; Not sure what the representation for zero is.
			    (cons newQuoteient newRemainder))))))))))
#+END_SRC

I think the rest of the result is obtained as described.
This will return a quotient and remainder pair.
So, we need to modify this so that the current coefficient order pair is part of the quotient to be returned, and the remainder is left as is.

The check for the dividend being zero is applied to the new quotient.
As, we either make the new quoitent and then check zero or check zero on parts to combine and then combine if ok.
This seems more straightforward.
Aside from whether this is really what was intended, I'm not sure what the representation used for 0 is.
I'm guessing it's ~(0 . 0)~ as this should be ~0~ for the 0th term. (I.e., just 0).
Though, ~the-empty-termlist~ might also work.

Using this to implement ~div-poly~ is straightforward.
See ~sub-poly~ above.
Everything interesting happens in ~div-terms~.

** MAYBE 2.92

This problem is interesting, for sure.

However, unless I've missed something ~apply-generic~ will be used, and so any way to interact with the procedures would be deferred to Chapter 3 where we see how to implement ~put~ and ~get~ (going by p. 181).

So, without the option to run any code, I'll pass on this for now.

** MAYBE Extended exercise: Rational functions
*** MAYBE 2.93

Huh? We're asked to modify the rational-arithmetic package to use generic operations, and then test the system.
But, there's no way to test the system…

#+BEGIN_SRC racket
  (put 'proc (list 'rational))
#+END_SRC

#+BEGIN_SRC racket
  (get 'proc (list 'rational))
#+END_SRC

Checking ~#lang sicp~ here: https://docs.racket-lang.org/sicp-manual/SICP_Language.html?q=sicp we can see ~put~ and ~get~ aren't provided.

So, maybe I'll be able to come back to this after chapter 3?

*** MAYBE 2.94

Same problem as above, exercise includes tests I don't have a way to run.

*** MAYBE 2.95

Depends on completion of 2.94.

*** MAYBE 2.96

Depends on completion of 2.95.

*** MAYBE 2.97

Well, as this is a contination of the previous exercises, this is also on the list of things to return to.


* Chapter 3

** Check on argument evaluation

Quick check to see evaluation of a procedure with an argument does something like:

- Define a variable for the argument.
- Assign the input value to the variable.

#+BEGIN_SRC racket
  (define (make-withdraw balance)
    (lambda (amount)
      (if (>= balance amount)
	  (begin (set! balance (- balance amount))
		 balance)
	  "Insufficient funds")))

  (define balance 100)

  (define W1 (make-withdraw balance))
  (define W2 (make-withdraw balance))

  (W1 50)
  (W2 75)
#+END_SRC

#+RESULTS:
: 50
: 25

Note, both W1 and W2 take the same argumnet, but an instance of W1 does not affect W2.

** 3.1

#+NAME: def:make-accumulator
#+BEGIN_SRC racket
  (define (make-accumulator n)
    (lambda (m) (begin
		  (set! n (+ n m))
		  n)))
#+END_SRC

Tests:

#+BEGIN_SRC racket
  <<def:make-accumulator>>
  (define A (make-accumulator 5))
  (A 10)
  (A 10)
#+END_SRC

#+RESULTS:
: 15
: 25

** 3.2

Note, we only update called when ~f~ is set to run, not ~mf~.

#+NAME: def:make-monitored
#+BEGIN_SRC racket
  (define (make-monitored f)
    (define called 0)
    (define (mf arg)
      (cond ((eq? arg 'how-many-calls?) called)
	    (else
	     (begin
	       (set! called (+ called 1))
	       (f arg)))))
    mf)
#+END_SRC

Some tests:

#+BEGIN_SRC racket
  <<def:make-monitored>>
  (define s (make-monitored sqrt))
  (s 100)
  (s 'how-many-calls?)
  (s 25)
  (s 'how-many-calls?)
#+END_SRC

#+RESULTS:
: 10
: 1
: 5
: 2

** 3.3

To implement password-protected accounts we place a check on dispatch.
As everything to do with account is handled via dispatch in message passing style, this restricts any interaction appropriately.
And, nothing else needs to be modified.

#+NAME: def:make-account
#+BEGIN_SRC racket
  (define (make-account balance password)
    (define (withdraw amount)
      (if (>= balance amount)
	  (begin (set! balance (- balance amount))
		 balance)
	  "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch word m)
      (if (eq? word password)
	  (cond ((eq? m 'withdraw) withdraw)
		((eq? m 'deposit) deposit)
		(else (error "Unknown request --- MAKE-ACCOUNT" m)))
	  (lambda (x) (display "Incorrect password"))
	  ))
    dispatch)
#+END_SRC

Tests:

#+BEGIN_SRC racket
  <<def:make-account>>
  (define acc (make-account 100 'secret))
  ((acc 'secret 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
#+END_SRC

#+RESULTS:
: 80
: Incorrect password

** 3.4

There are a few things to note.

- As we're testing for a password on dispatch we return the incorrect password notification as a function.
  This way, something like ~((acc 'SeCrEt 'withdraw) 20)~ doesn't error by attempting to apply ~20~ to ~"Incorrect password"~.
  - (This should also have been the case in the previous exercise, and is now updated.)
- ~call-the-cops~ is underspecified, so prints a message.
- What to do on a correct password after too many incorrect is undefined.
  At the moment, a correct password resets everything (though the police are on the way).
  Alternatively, a check for passowrd attempts to be less than 7 at the beginning of ~dispatch~ would lock the account on the final failure.

#+NAME: def:make-account-cops
#+BEGIN_SRC racket
  (define (call-the-cops)
    (lambda (x) (begin (display "Siren sounds") (newline))))

  (define (make-account balance password)
    (define passwordAttempts 0)
    (define (withdraw amount)
      (if (>= balance amount)
	  (begin (set! balance (- balance amount))
		 balance)
	  "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch word m)
      (cond
	((eq? word password)
	 (begin
	   (set! passwordAttempts 0)
	   (cond ((eq? m 'withdraw) withdraw)
		 ((eq? m 'deposit) deposit)
		 (else (error "Unknown request --- MAKE-ACCOUNT" m)))))
	(else
	 (set! passwordAttempts (+ passwordAttempts 1))
	 (cond ((> passwordAttempts 7) (call-the-cops))
	       (else (lambda (x) (begin (display "Incorrect password") (newline))))))))
    dispatch)
#+END_SRC

#+RESULTS: def:make-account-cops

#+BEGIN_SRC racket
  <<def:make-account-cops>>
  (define acc (make-account 100 'secret))
  ((acc 'secret 'withdraw) 20)
  ((acc 'secret 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
  ((acc 'secret 'withdraw) 20)
  ((acc 'SeCrEt 'withdraw) 20)
#+END_SRC

#+RESULTS:
#+begin_example
80
60
Incorrect password
Incorrect password
Incorrect password
Incorrect password
Incorrect password
Incorrect password
Incorrect password
Siren sounds
40
Incorrect password
#+end_example

** 3.5

To start, some provided procedures:

#+NAME: def:random-in-range
#+BEGIN_SRC racket
  (define (random-in-range low high)
    (let ((range (- high low)))
      (+ low (random range))))
#+END_SRC

#+NAME: def:monte-carlo
#+BEGIN_SRC racket
  (define (monte-carlo trials experiment)
    (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0) ; If no trails remaining, calculate the pass rate
	     (/ trials-passed trials))
	    ((experiment) ; If some trails remain, run the experiment. As it's a test, success triggers a new instance with pass + 1
	     (iter (- trials-remaining 1) (+ trials-passed 1)))
	    (else ; And failure trigger a new instance with pass the same.
	     (iter (- trials-remaining 1) trials-passed))))
    (iter trials 0))
#+END_SRC

#+NAME: def:estimate-integral
#+BEGIN_SRC racket
  (define (estimate-integral P xl xh yl yh trials)
    <<def:monte-carlo>>
    (let ((xRange (- xh xl))
	  (yRange (- yh yl)))
      (define (P-test)
	<<def:random-in-range>>
	<<def:square>>
	(P (random-in-range xl xh) (random-in-range yl yh)))
      (* xRange yRange (monte-carlo trials P-test))))
#+END_SRC

This task is a bit of a headache.
We want to estimate the area of a circle by a unit circle.
However, range only returns integers. (Later note: This isn't true. What I missed is that you need to pass in floats --- e.g 0.0 and 1.0.)

One option is to try to modify range.
Alterantively, we can scale a unit circle as desired.

However, scaling the unit circle means the test for whether a point is inside a circle needs to know about the scaling.
Hence, ~inside-circle?~ isn't just a straightforward test.
Rather, it takes the radius of the circle as an argumnet.
And, as we're already taking arguments we specify the origin of the circle too.
(Indeed, this could just take a circle object as an argument.)
Then, it returns the right test.

#+NAME: def:inside-circle?
#+BEGIN_SRC racket
  (define (inside-circle? r ox oy)
    <<def:square>>
    (lambda (x y)
      (>= (square r) (+ (square (- x ox)) (square (- y oy))))))
#+END_SRC

Our main function ~estimate-pi-circle~ then takes a scale for the unit circle and the number of trials to perform.

#+NAME: def:estimate-pi-circle
#+BEGIN_SRC racket
  (define (estimate-pi-circle scale trials)
    <<def:inside-circle?>>
    <<def:estimate-integral>>
    <<def:square>>
    (let ((center+Radius (/ scale 2)))
      (* 4.0
	 (/ (estimate-integral (inside-circle? center+Radius center+Radius center+Radius) 0 scale 0 scale trials)
	    (square scale)))))
#+END_SRC

Some instances, though even at the larger arguments the result is quite varaible:

#+BEGIN_SRC racket
  <<def:estimate-pi-circle>>
  (estimate-pi-circle 1 10)
  (estimate-pi-circle 10 1)
  (estimate-pi-circle 99 9999)
  (estimate-pi-circle 9999 99)
  (estimate-pi-circle 9999 9999)
#+END_SRC

#+RESULTS:
: 0
: 4.0
: 3.1487148714871487
: 3.111111111111111
: 3.1275127512751277

** 3.6

Ah, ~rand~.
For testing we use a model ~rand-update~ which just increments the arugment given.

#+BEGIN_SRC racket
  (define (rand-update x)
    (+ x 1))

  (define rand
    (let ((x 0))
      (lambda ()
	(set! x (rand-update x))
	x)))

  (rand)
  (rand)
#+END_SRC

Note, ~rand~ is defined like a term where the value for the term is a procedure.
So, initially, to evaluate ~rand~ we set up ~x~ and then call the lambda expression.
On subsequent calls, we evaluate the lambda expression.

But, this means rand must be treated like a function.
That is, ~rand~ is just a procedure, but ~(rand)~ evaluates the lambda expression, and the current value of ~x~ is returned.
Note, in particular, ~(- rand 1)~ is not okay, but ~(- (rand) 1)~ is!

With the above in mind, modifying ~rand~ is straightforward.

#+BEGIN_SRC racket
  (define (rand-update x) (+ x 1))

  (define rand-again
    (let ((base-val 0))
      (lambda (msg . arg)
	(cond ((eq? msg 'generate) (set! base-val (rand-update base-val)) base-val)
	      ((eq? msg 'reset) (set! base-val (car arg)))
	      ))))

  (rand-again 'generate)
  (rand-again 'reset 9)
  (rand-again 'generate)
#+END_SRC

First, we treat ~rand-again~ as something which takes no arguments so ~base-val~ is fixed.
Then, instead of returining a lambda expression which takes no values, we retrun a lambda expression which takes a message and some other args.
Messages determine what happens.
And, both cases are similar, ~base-val~ is ~set~ to something else.
In the case of ~'reset~ a new argument is needed, and hence we look to the first of any additional args beyond the message.

** 3.7

The general approach is for ~make-join~ to return ~peter-acc~ in some way.
Here, we have (at least) two options.

1. Add the password to the original account. Then, simply return the original account when called.
2. Make accessing the original account depend on the password being given.
   - If this is done, we now need some way of accessing the original account.
     We could use the password set, though going forward this might be a problem.
     For example, if the password changes.
     So, instead we might add an 'internal' password.
     Then, on set-up the original account password is used to get the interal password, and this is stored for further access.


#+NAME: def:make-account-joint
#+BEGIN_SRC racket
  (define (make-account balance password)
    (define backdoor-key 'backdoor-key)
    (define (withdraw amount)
      (if (>= balance amount)
	  (begin (set! balance (- balance amount))
		 balance)
	  "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch word m)
      (if (or (eq? word password) (eq? word backdoor-key))
	  (cond ((eq? m 'withdraw) withdraw)
		((eq? m 'deposit) deposit)
		((eq? m 'get-backdoor-key) backdoor-key)
		(else (error "Unknown request --- MAKE-ACCOUNT" m)))
	  (lambda (x) (display "Incorrect password") (newline))
	  ))
    dispatch)
#+END_SRC

#+RESULTS: def:make-account-joint

#+BEGIN_SRC racket
  <<def:make-account-joint>>
  (define acc (make-account 100 'secret))
  ((acc 'secret 'withdraw) 20)
  ((acc 'backdoor-key 'withdraw) 20)
#+END_SRC


#+BEGIN_SRC racket
  (define (make-joint base-acc base-pwd pwd)
    (let ((access (base-acc base-pwd 'get-backdoor-key)))
      (lambda (word . args)
	(if (eq? word pwd)
	    (base-acc access (car args))
	    (lambda (x) (display "Incorrect password") (newline))))))

  <<def:make-account-joint>>
  (define acc1 (make-account 100 'secret))
  (define acc2 (make-joint acc1 'secret 'my))
  ((acc1 'secret 'withdraw) 20)
  ((acc2 'my 'deposit) 20)
  ((acc1 'my 'deposit) 20)
  ((acc2 'secret 'deposit) 20)
#+END_SRC

#+RESULTS:
: 80
: 100
: Incorrect password
: Incorrect password

Though, in retrospect this wasn't really the right idea.
Instead, it would be best to modify accounts to access balance.
Then, share balance between accounts.
In this way, the second account would be a regular account.

Here, then, we distinguish an account from a headless account.
A headless account stores a balance and related procedures.
When an account is made, this invloves creating a headless account.
In the ~make-account~ case, a headless account is created with the balance specified.
In the ~make-joint~ case, the headless account from the base account is used.

#+NAME: def:make-account-balance-oops
#+BEGIN_SRC racket
  (define (make-headless-account balance)
    (define (withdraw amount)
      (if (>= balance amount)
	  (begin (set! balance (- balance amount))
		 balance)
	  "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
	    ((eq? m 'deposit) deposit)
	    (else (error "Unknown request --- MAKE-ACCOUNT" m))))
    dispatch)


  (define (make-account-by-headless password headless)
    (define (withdraw amount) ((headless 'withdraw) amount))
    (define (deposit amount) ((headless 'deposit) amount))
    (define (password-ok? word) (eq? word password))
    (define (get-headless) headless)
    (define (dispatch word m)
      (if (password-ok? word)
	  (cond ((eq? m 'withdraw) withdraw)
		((eq? m 'deposit) deposit)
		((eq? m 'password-ok?) password-ok?)
		((eq? m 'get-headless) (get-headless)) ; Eval get-headless so we get headless, not the procedure which returns headless.
		(else (error "Unknown request --- MAKE-ACCOUNT" m)))
	  (lambda (x) (display "Incorrect password") (newline))))
    dispatch)


  (define (make-account balance password)
    (make-account-by-headless password (make-headless-account balance)))

  (define (make-joint base-acc base-pwd pwd)
    (if (base-acc 'password-ok? base-pwd)
	(make-account-by-headless pwd (base-acc base-pwd 'get-headless))))
#+END_SRC

Here are a few tests.

#+BEGIN_SRC racket
  <<def:make-account-balance-oops>>

  (define test-acc (make-account 100 'test))
  ((test-acc 'test 'withdraw) 10)
  (((test-acc 'test 'get-headless)  'withdraw) 10)
  (define test-acc2 (make-joint test-acc 'test 'this))
  ((test-acc2 'this 'deposit) 100)
  ((test-acc 'test 'withdraw) 180)
#+END_SRC

#+RESULTS:
: 90
: 80
: 180
: 0

Phew! I think this works okay.

** 3.8

Here, ~f~ is very similar to everything that's come before.
We define an argument which creates some constants and then returns a new argument that is evaluated against those constants.
In this case, there is one constant ~var~ and this is updated just in case it's not a number.
I.e. ~var~ will fix on the first number argument given to (the procedure returned by the first eval of) ~f~.

#+NAME: def:f-order-matters
#+BEGIN_SRC racket
  (define f
    (let ((var 'a))
    (lambda (x)
      (if (not (number? var)) (set! var x))
      var)))
#+END_SRC

Two tests:

#+BEGIN_SRC racket
  <<def:f-order-matters>>
  (+ (f 0) (f 1))
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC racket
  <<def:f-order-matters>>
  (+ (f 1) (f 0))
#+END_SRC

#+RESULTS:
: 2

** Rules for evaluation

To evaluate a combination we:

1. Evaluate the subexpressions of the combination.
2. Apply the valuue of the operator subexpression to the values of the operand subexpressions.

The important thing to keep in mind is that this is all done with respect to an environment.
In short, an environment is a store of variables.

In long, and environment is a ordered graph of frames, where each frame contains variable assignments, where some frame is the (unique) main frame.

When defining a procedure, the procedure is stored as a variable on the main frame of the enviromnet the procedure is defined in.

When evaluating a procedure, a new enviroment is created, and a reference to the enviroment the something is evaluated in is kept.
So, we get a new main frame.

Important here is where the new enviroment is 'located'.
As things are, it's a sub-environment of the environment where defined.
I.e. it is not a sub-enviroment of the environment where it is evaluated.
In part, this ensures any variables used in the procedure have the values given with respect to the enviroment of definition.
And, we won't run into trouble by taking an argument with the name ~f~ and calling a procedure named ~f~.

But why not simply talk of frames?
Well, any given frame may be incomplete with respect to the variables which have been defined.
I.e. a sub-enviroment may contain all the super-frames of the super-enviroment.
Note, this suggestion is the inverse of Figure 3.1.
Though, thinking in terms of Figure 3.1 seems useful for considering a procedure applied to arguments which are themselves procedures.

** 3.9

Both versions of factorial are defined with respect to the global environment.
And, we don't yet have any detail about the way results are returned, combined, etc.
Further, the same procedure is repeatedly called.
So, the diagrams are very similar to Figure 3.5 on p. 242, with a fixed procedure.
What changes are the arguments.

For recursive ~factorial~, there is a single argument ~n~ which decreases from 6 to 1.
I.e. the digram will contain six enviroments, the first will have ~n: 6~, the second ~n: 5~ and so on.

For iterative ~factorial~ the procedure takes three arguments.
Here we'll have six enviroments, the first containg ~product: 1, counter: 1, max-count: 6~, the second ~product: 1, counter: 2, max-count: 6~, and the last ~product: 120, counter: 6, max-count: 6~.

** 3.10

Ah, I was wondering about this.

With the standard definition of a function we have an enviroment and a frame containing the arguments as variables.
When ~let~ is used, we obtain a lambda expression, and so a second enviroment is created, where any variables set-up by the ~let~ call are themselves arguments.

So, if we call a procedure and then form a call to ~let~ to explicitly fix the arguments, we create a sub-environment which mirrors the main environment.

One way to get a feel for the way this works is by overwriting variables.
The following procedure sets up an enviroment with variable ~n~.
Then, ~let~ is called, which expands to ~(lambda (n) … ) n~.
So, the lambda expression creates a new enviroment with variable ~n~ and the value of ~n~ is set to the vale of the outer ~n~.
Now, ~(set! n x)~ updates the value of ~n~ in the enviroment of the lambda expression.
However, as we're now an enviroment detached from the enviroment of the original value of ~n~ is left untouched.

#+BEGIN_SRC racket
  (define (test n)
    (display "Original: ") (display n) (newline)
    (let ((n n))
      (begin
	(set! n 20)
	(display "Overwritten: ") (display n) (newline)))
    (display "Original: ") (display n) (newline)
    )

  (test 5)
#+END_SRC

#+RESULTS:
: Original: 5
: Overwritten: 20
: Original: 5

This has some benefits.
For, this allows us to keep the arguments given having a default value.
For example, with ~make-withdraw~ the initial amount would always be available.

** 3.11


~(define acc (make-account 50))~ on first frame of global, acc.
~make-account~ is procedure, so enviroment E1.
But, as ~make-account~ is global, super-enviroment of this environment is global.
Each definition is defined relative to E1.
And, we call ~dispatch~.
So, we have associated ~acc~ with a procedure which is evaluated within enviroment E1.

Note, this means ~(define acc2 (make-account 100))~ will all follow with respect to a different enviroment.
And, in particular, the internal functions are all relative to the respect enviroments.

This is interesting if we have the option to update ~make-account~.
For, any use of ~make-account~ before the update will be fixed.
The enviroment will contain all the relevant procedures, and so on.
So, we don't need to worry about breaking the past.
However, this means that if the past is broken, we can't easily (if at all) update all the accounts to have a fixed version of deposit, etc.

** 3.12

#+NAME: def:last-pair
#+BEGIN_SRC racket
  (define (last-pair l)
    (if (null? (cdr l))
	l
	(last-pair (cdr l))))
#+END_SRC

#+NAME: def:append!
#+BEGIN_SRC racket
  (define (append! x y)
    <<def:last-pair>>
    (set-cdr! (last-pair x) y))
#+END_SRC

#+BEGIN_SRC racket
  <<def:append!>>
  (define x (list 'a 'b))
  (define y (list 'c 'd))
  (define z (append x y))
  (cdr x)
  (define w (append! x y))
  (cdr x)
#+END_SRC

#+RESULTS:
: (b)
: (b c d)

The first call to ~cdr~ has ~x~ as defined.
So, we get ~('b)~ (or ~('b . nil)~, if you like).
When we define w ~append!~ is evaluated in the global enviroment.
The last-pair of ~x~ is ~('b . nil)~, and now we have ~('b . y)~ (or ~('b 'c 'd')~).

** 3.13

So, ~(set-cdr! (last-pair x) x)~ is going to shift the pointer to ~nil~ (or really ~nil~) at the end of ~x~ to the start of ~x~.
Hence, I'd expect ~make-cycle~ fails to terminate, if the call to ~x~ amounts to working through ~x~ to display the elements using ~car~ and ~cdr~.

Let's test:

#+BEGIN_SRC racket
  (define (make-cycle x)
    <<def:last-pair>>
    (set-cdr! (last-pair x) x)
    x)

  (make-cycle (list 'a 'b))
#+END_SRC

#+RESULTS:
: #0=(a b . #0#)

This is cool!

A slightly trickier case:

#+NAME: def:make-cycle
#+BEGIN_SRC racket
  (define (make-cycle x)
    (define (second-to-last l)
      (if (null? (cddr l))
	  l
	  (second-to-last (cdr l))))
    (set-cdr! (second-to-last x) (cdr x))
    x)

  (make-cycle (list 'a 'b 'c 'd))
#+END_SRC

#+RESULTS:
: (a . #0=(b c . #0#))

Interesting!

Something is done when the list is displayed!
The folliwing doesn't terminate:

#+NAME: def:make-cycle
#+BEGIN_SRC racket
  (define (Sisyphus x)
    (define (second-to-last l)
      (if (null? (cddr l))
	  l
	  (second-to-last (cdr l))))
    (set-cdr! (second-to-last x) (cdr x))
    (define (until-nil x)
      (if (null? x)
	"Done"
	(until-nil (cdr x))
	  )

      )
    (until-nil x))

  (Sisyphus (list 'a 'b 'c 'd))
#+END_SRC

** 3.14

#+NAME: def:mystery-3.14
#+BEGIN_SRC racket
  (define (mystery x)
    (define (loop x y)
      (if (null? x)
      y
      (let ((temp (cdr x)))
	(set-cdr! x y)
	(loop temp x))))
    (loop x '()))
#+END_SRC

So, we're running ~loop~, mostly.
Given a list we store everything but the first element in ~temp~.
Then, we ~set-cdr!~ ~x~ to the other argument given.
And, now we repeat, this time we're looking at the ~cdr~ of ~x~, so the rest of the list.
Again, take first element, store rest of list, attach first element to other argument, which is now first element of ~x~ pointing to ~nil~.

Hence, something like:

#+BEGIN_SRC racket
  (1 2 3 nil) nil

  (2 3 nil) (1 nil)

  (3 nil) (2 1 nil)

  nil (3 2 1 nil)

  (3 2 1 nil)
#+END_SRC

So, reversing a list of length $n$ in $\Theta(n)$, as it's a constant operation for each element.

Let's test!

#+BEGIN_SRC racket
  <<def:mystery-3.14>>
  (mystery (list 1 2 3))
  (mystery (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (3 2 1)
: (5 4 3 2 1)

Neat!

Oh, there's more.
What happens when we define a variable to be the result of ~mystery~?
Well, we return ~y~, so a pointer to the last element of the list, which is the first element of the reversed list.
Does the last element point to ~nil~ or to the second-to-last element?

Hm, so on first run, dealing with the first element, we do ~set-cdr!~.
However, this is on ~x~ as an argumen to ~loop~, which is a frame removed from ~mystery~.
So, the original form of ~x~ is untouched?

#+BEGIN_SRC racket
  <<def:mystery-3.14>>
  (define v (list 'a 'b 'c 'd))
  v
  ;; (mystery v)
  (define w (mystery v))
  w
#+END_SRC

#+RESULTS:
: (a b c d)
: (d c b a)
: (a)

No, but this differs from ~set!~

#+BEGIN_SRC racket
  (define s 5)
  s
  (define (test x)
    (set! x 10)
    x)
  (test s)
  s
#+END_SRC

#+RESULTS:
: 5
: 10
: 5

To make the parrallel clearer:

#+BEGIN_SRC racket
  (define s (list 1 0))
  s
  (define (test x)
    (set-car! x (cadr x))
    x)
  (test s)
  s
#+END_SRC

#+RESULTS:
: (1 0)
: (0 0)
: (0 0)

So, it's clear ~set-car!~ mutates something, but /which/ something.
With ~set!~ we mutate the 'closest' instance of the variable.
But, the same is not true for ~set-car!~.

Well, I understand ~set!~ isn't a mutating operation, in the sense that a mutating operation mutates the referents of a term, while ~set!~ 'mutates' the referent of a term.
The thing is, that mutation crosses frame boundries still isn't obvious.

I think my understanding of frames is needs revising.

My initial thought was a frame stores a term and the value of the term.
When a new frame is generated, the value of the term is copied.

However, what I now think happens is that a frame associates a term with a pointer to an object.

The key idea here is that frames allow us to update the value of a term, but that's all.
What is associated with a term is frame independent.
And, for many operations this is no issue, because the procedures are non-mutating --- any arguments are used to obtain some result, but are not rewritten.

For sure, this sort of design makes sense.
It means frames are fairly easy to construct, and also that we don't end up with heavy copy operations.

I'm surprised, and a little disappointed, that none of this is made particularly clear.
A simple example with lists or some other mutable data type would have been very helpful.

Though, some of this is clear in retrospect.

A list is just a pointer to a pair, where the first element is some value and the second is a pointer or null.
So, in this respect, the 'value' of something like ~(list 1 2 3)~ is a pointer.

So, returning:

#+BEGIN_SRC racket
  (define v (list 'a 'b 'c 'd))
  v
  (mystery v)
#+END_SRC

~v~ points to the start of the list, which is ~(a . pointer)~
Here, we've run ~mystery~, and ~v~ still points to the same object, which is now ~(a . nil)~.

#+BEGIN_SRC racket
  (define w (mystery v))
  w
#+END_SRC

Here, we've already run ~mystery~, so expanded, the first line is:

#+BEGIN_SRC racket
  (define w (mystery (a . nil)))
  w
#+END_SRC

Which, returns ~(list a)~.

However, if things go as follows:

#+BEGIN_SRC racket
  (define v (list 'a 'b 'c 'd))
  (define w (mystery v))
  w
#+END_SRC

Then we've got a pointer to ~(d . pointer)~, as ~mystery~ returns a pointer to the new first element of the reversed list.

Phew!

** 3.15

#+NAME: def:set-to-wow!
#+BEGIN_SRC racket
  (define (set-to-wow! x)
    (set-car! (car x) 'wow)
    x)
#+END_SRC

~set-to-wow!~ takes a list and changes the first element of the first element of the list to be ~'wow~.

We have the folling terms:

#+NAME: consts:3.15
#+BEGIN_SRC racket
  (define x (list 'a 'b))
  (define z1 (cons x x))
  (define z2 (cons (list 'a 'b) (list 'a 'b)))
#+END_SRC

Consider:

#+BEGIN_SRC racket :tangle no
  (set-wow! z1)
#+END_SRC

This is equivalent to:

#+BEGIN_SRC racket :tangle no
  (set-car! (car (cons x x)) 'wow)
  (cons x x)
#+END_SRC

Simplifying the first evaluation:

#+BEGIN_SRC racket :tangle no
  (set-car! x 'wow)
#+END_SRC

I.e.

#+BEGIN_SRC racket :tangle no
  (set-car! (list 'a 'b) 'wow)
#+END_SRC

So, ~x~ now points to the folling list:

#+BEGIN_SRC racket :tangle no
  (list 'wow 'b)
#+END_SRC

And, ~z1~ is ~(cons x x)~.
I.e. ~z1~ is ~((list 'wow 'b) 'wow 'b)~

#+BEGIN_SRC racket
  <<def:set-to-wow!>>
  <<consts:3.15>>
  (set-to-wow! z1)
#+END_SRC

#+RESULTS:
: ((wow b) wow b)

With ~z2~ the reasoning is similar, but we have two distinct lists.
Hence, ~set-to-wow!~ only affects the first element of the first element of the list.

** 3.16

#+NAME: def:count-pairs-dodgy
#+BEGIN_SRC racket
  (define (count-pairs x)
    (if (not (pair? x))
	0
	(+ (count-pairs (car x))
	   (count-pairs (cdr x))
	   1)))
#+END_SRC

Here's a simple case:

#+BEGIN_SRC racket
  <<def:count-pairs-dodgy>>
  (define a (cons 'a1 'a2))
  (define b (cons 'b1 'b2))
  (define x (cons a b))
  (count-pairs x)
#+END_SRC

The result is as expected.
We have the two pairs ~a~ and ~b~ and the pair containing these for a total of three pairs.

#+RESULTS:
: 3

To get four pairs, we update one of the elements in ~a~ to be ~b~.

#+BEGIN_SRC racket
  <<def:count-pairs-dodgy>>
  (define a (cons 'a1 'a2))
  (define b (cons 'b1 'b2))
  (define x (cons a b))
  (set-cdr! b a)
  (count-pairs x)
#+END_SRC

#+RESULTS:
: 4

Here, we still have three pairs.
However, it's ~(a . b)~, ~(a1 . a2)~ and ~(b1 . a)~.

To get four pairs, the idea is to have ~b~ as above.
Then, ~a~ becomes ~(b . b)~, and ~x~ becomes ~(a . a)~
This gives a count of seven from three pairs.

#+BEGIN_SRC racket
  <<def:count-pairs-dodgy>>
  (define a (cons 'a1 'a2))
  (define b (cons 'b1 'b2))
  (define x (cons a b))
  (set-car! a b)
  (set-cdr! a b)
  (set-cdr! x a)
  (count-pairs x)
#+END_SRC

#+RESULTS:
: 7

A pair which never returns contains some self-reference.
I did this first with one set as follows:

#+BEGIN_SRC racket
  <<def:count-pairs-dodgy>>
  (define x (cons 'hi nil))
  (set-cdr! x x)
  (count-pairs x)
#+END_SRC

Here, ~(car x)~ is ~x~.
And, we never hit the base case of ~count-pairs~

And, in line with the three pairs above, we could set, e.g. ~a~ to pair itself with itself.

#+BEGIN_SRC racket
  <<def:count-pairs-dodgy>>
  (define a (cons 'a1 'a2))
  (define b (cons 'b1 'b2))
  (define x (cons a b))
  (set-car! a a)
  (set-cdr! a a)
  (count-pairs x)
#+END_SRC

** 3.17

A little messy and not particularly elegant, but this should work.

The idea is to store a list of pairs added.
(Here, of course, this list is really just pointers to pairs.)

We always check to see if a pair is on the list.
If a pair is not on the list, we add it but count the pair.
Else, we don't count the pair.
Then, look to sub-pairs.

Here's a quick search on a list:

#+NAME: def:has-element
#+BEGIN_SRC racket
  (define (has-element l e)
    (cond ((null? l)
	   #f)
	  ((eq? (car l) e) #t)
	  (else (has-element (cdr l) e))))
#+END_SRC

The main procedure sets up ~seen-pairs~ as a term, pointing to the empty list.
~recurse-add~ is defined as we want to recurse in the same way whether or not a pair was seen before, changing only whether we count the pair.
So, this handles the recursive call and takes an argument which specifies the amount to add to the result of recursion.
And, ~internal~ handles the ideas expressed above.

#+NAME: def:count-pairs
#+BEGIN_SRC racket
  (define (count-pairs x)
    (let ((seen-pairs (list )))
      (define (recurse-add x n)
	(cond ((not (pair? x)) 0)
	      (else (+ (internal (car x))
		       (internal (cdr x))
		       n))))
      (define (internal x)
	<<def:has-element>>
	(if (not (has-element seen-pairs x))
	    (begin
	      (set! seen-pairs (cons x seen-pairs))
	      (recurse-add x 1))
	    (recurse-add x 0)))
      (internal x)))
#+END_SRC


#+BEGIN_SRC racket
  <<def:count-pairs>>
  (define a (cons 'a1 'a2))
  (define b (cons 'b1 'b2))
  (define x (cons a b))
  (set-car! a b)
  (set-cdr! a b)
  (set-cdr! x a)
  (count-pairs x)
#+END_SRC

#+RESULTS:
: 3

Seems good!

** 3.18

Key insight here is that in contrast to the last exercise, we'd like the list of seen pairs to be local to each recursive call.
I.e. ~seen-pairs~ only keeps track of the pairs passed through to get to the current pair.

If we hit a base case (something not a pair), there are no cycles, and if we hit a pointer already seen, there is a cycle.
So, the return is just ~or~ on the recursive cases.

#+NAME: def:cycle?
#+BEGIN_SRC racket
  (define (cycle? x)
    (define (recurse x seen)
      (cond ((not (pair? x)) #f)
	    (else (or (internal (car x) seen)
		      (internal (cdr x) seen)))))
    (define (internal x seen-pairs)
      <<def:has-element>>
      (if (not (has-element seen-pairs x))
	  (recurse x (cons x seen-pairs))
	  #t))
    (internal x '()))
#+END_SRC

#+BEGIN_SRC racket
  <<def:cycle?-pair>>
  (define a (cons 'a1 'a2))
  (define b (cons 'b1 'b2))
  (define x (cons a b))
  (set-car! a b)
  (set-cdr! a b)
  x
  (cycle? x)
  (set-cdr! x a)
  x
  (cycle? x)
  (set-cdr! x x)
  x
  (cycle? x)
#+END_SRC

#+RESULTS:
: (((b1 . b2) b1 . b2) b1 . b2)
: #f
: (((b1 . b2) b1 . b2) (b1 . b2) b1 . b2)
: #f
: #1=((#0=(b1 . b2) . #0#) . #1#)
: #t


#+BEGIN_SRC racket
  <<def:cycle?-pair>>
  (define a (cons 'a1 'a2))
  (define b (cons 'b1 'b2))
  (define x (cons a b))
  (set-car! a a)
  (set-cdr! a a)
  x
  (cycle? x)
#+END_SRC

#+RESULTS:
: (#0=(#0# . #0#) b1 . b2)
: #t

Oops, this was meant to be on lists.
However, the procedure works fine on lists.
Here's some tests:

Tests:

#+BEGIN_SRC racket
  <<def:cycle?>>
  (define x (list 1 2 3 4))
  (define y (list 1 2))
  (cycle? x)
  y
  (set-cdr! (cdr y) y)
  y
  (cycle? y)
  (define z (list (list 1) 2 3))
  z
  (set-cdr! (car z) z)
  z
  (cycle? z)
#+END_SRC

#+RESULTS:
: #f
: (1 2)
: #0=(1 2 . #0#)
: #t
: ((1) 2 3)
: #0=((1 . #0#) 2 3)
: #t

** 3.19

*** Initial $\Theta(n)$ space idea.

Okay.
Idea is to follow a list.
If a loop has been entered, then it's possible to return to where we are.
So, if we set up a diversion for any future traffic, and the diversion is hit, then there's a loop.
If we've got a recursive function, we can then repair everything on the way back after hitting the base case or recognising we've been diverted.

Recognising a diversion is easy, as a non-diversion must either be a pair or nil.

#+NAME: def:cycle?-slim
#+BEGIN_SRC racket
  (define (cycle? x)
    (define dead-end (cons "dead-end" nil))
    (define (recurse x)
      (cond ((eq? x dead-end) #t)
	    ((not (pair? x)) #f)
	    (else
	     (let ((orig-cdr (cdr x))
		   (result 0))
	       (set-cdr! x (cons dead-end (cdr x)))
	       (set! result (or (recurse (car x))
				(recurse (cddr x))))
	       (begin
		 (set-cdr! x (cddr x))
		 result)))))
    (recurse x))
#+END_SRC

Test:

#+BEGIN_SRC racket
  <<def:cycle?-slim>>
  (define x (list 1 2 3 4))
  (define y (list 1 2))
  (cycle? x)
  y
  (set-cdr! (cdr y) y)
  y
  (cycle? y)
  y
  (define z (list (list 1) 2 3))
  z
  (set-cdr! (car z) z)
  z
  (cycle? z)
  z
#+END_SRC

#+RESULTS:
: #f
: (1 2)
: #0=(1 2 . #0#)
: #t
: #0=(1 2 . #0#)
: ((1) 2 3)
: #0=((1 . #0#) 2 3)
: #t
: #0=((1 . #0#) 2 3)

Well, this works.
Is it really constant space?
No.
We need to keep a record of the original route.
So, this takes up n additional space.

*** Revised idea

The idea is to insert a mark.
Everything to the left of the mark is something we've seen, and everything to the right is something to check.
We work through the list in sequence.
For each step we take, we note what comes next.
Then, test for equality up until the mark.
If something is equal, we're about to enter a loop.
Else, it's safe to move forward, along with the marker.

This takes constant space, as the only additional thing is the marker and a few other items to avoid frames with terms on recursive calls.

The only problem is the marker may accidentally be equal to something in the list.
But, this isn't something to worry about too much, I don't think.

We start with a procedure to test if a list has at least two elements.
This is important as we need at least two element to insert a crumb.
And, ~length~ is unavaialbe, given a list with a loop has undefined length.

#+NAME: def:at-least-two?
#+BEGIN_SRC racket
  (define (at-least-two? l)
	     (cond ((null? l) #f)
		   ((null? (cdr l)) #f)
		   (else #t)))
#+END_SRC


We now have ~insert-crumb~.
This adds a mark as the second element in a list.
(We can check the first two elements don't loop without using a marker, and indeed for any fixed n - the problem is lists may be of arbitrary length.)

#+NAME: def:insert-crumb
#+BEGIN_SRC racket
  (define (insert-crumb l c)
    <<def:at-least-two?>>
    (cond ((at-least-two? l)
	   (set-cdr! c (cdr l))
	   (set-cdr! l c))
	  (else #f) ; list is too short to insert
	  ))
#+END_SRC

Next, ~remove-crumb~, which removes a crumb so long as it's where it was inserted.

#+NAME: def:remove-crumb
#+BEGIN_SRC racket
  (define (remove-crumb l c)
    (cond ((eq? (cdr l) c)
	   (set-cdr! l (cdr c))
	   (set-cdr! c nil))
	  (else #f) ; crumb wasn't there
	  ))
#+END_SRC

With ~insert-crumb~ and ~remove-crumb~ we have a way of temporaily putting a crumb in a list.
Next up is pushing and pulling a crumb inside a list.

~push-crumb~ pushes the crumb one space forward in the list.

#+NAME: def:push-crumb
#+BEGIN_SRC racket
  (define (push-crumb l e)
    (cond ((null? l) (error "oops, went too far"))
	  ((and (eq? (cdr l) e) (not (null? (cddr l)))) ; next is e
	   (set-cdr! l (cddr l)) ; we've removed e
	   (set-cdr! e (cddr l))
	   (set-cdr! (cdr l) e))
	  ((and (eq? (cdr l) e) (null? (cddr l)))
	   #f)
	  (else
	   (push-crumb (cdr l) e))))
#+END_SRC

And, ~pull-crumb~ pulls the crumb one space backward in the list.

#+NAME: def:pull-crumb
#+BEGIN_SRC racket
  (define (pull-crumb l e)
    (cond ((null? l) (error "oops e not found"))
	  ((eq? (cdr l) e)
	   #f) ; e is too close.
	  ((eq? (cddr l) e) ; two next is e
	   (set-cdr! (cdr l) (cdr e))
	   (set-cdr! e (cdr l))
	   (set-cdr! l e))
	  ((and (eq? (cdr l) e) (null? (cddr l)))
	   #f)
	  (else
	   (pull-crumb (cdr l) e))))
#+END_SRC

Some tests:

#+BEGIN_SRC racket
  <<def:insert-crumb>>
  <<def:remove-crumb>>
  <<def:push-crumb>>
  <<def:pull-crumb>>
  (define x (list 1 2 3 4))
  (define crumb (list 'a))
  (insert-crumb x crumb)
  x
  (push-crumb x crumb)
  x
  (push-crumb x crumb)
  (push-crumb x crumb)
  (push-crumb x crumb)
  x
  (pull-crumb x crumb)
  (pull-crumb x crumb)
  x
  (pull-crumb x crumb)
  (pull-crumb x crumb)
  x
  (remove-crumb x crumb)
  x
#+END_SRC

#+RESULTS:
: (1 a 2 3 4)
: (1 2 a 3 4)
: #f
: (1 2 3 4 a)
: (1 2 a 3 4)
: #f
: (1 a 2 3 4)
: (1 2 3 4)


The final thing is a procedure which works through a list and checks to see if the current (element . pointer) cell is the same as one given as an argument up until the crumb cell is identified.

To ensure the overall procudure uses a constant about of space, we work through the list by a fixed pointer which is updated before and then used by a recursive call.

#+NAME: def:same-before-crumb
#+BEGIN_SRC racket
  (define (same-before-crumb l cell crumb)
    (define pointer l)
    (define (go)
      (cond ((null? pointer) #f) ; didn't even find crumb
	    ((eq? pointer crumb) #f) ; found crumb
	    ((eq? pointer cell) #t) ; found element
	    (else
	     (begin
	       (set! pointer (cdr pointer)) ; otherwise, continue to sub-list
	       (go)))))
    (go))
#+END_SRC

#+RESULTS: def:same-before-crumb

Here's a few quick tests:

#+BEGIN_SRC racket
  <<def:same-before-crumb>>
  <<def:insert-crumb>>
  <<def:push-crumb>>
  (define x (list 1 2 3 4))
  (define crumb (list 'a))
  (insert-crumb x crumb)
  (push-crumb x crumb)
  x
  (cdr x) ; (2 . pointer to crumb)
  (same-before-crumb x x crumb) ; a match
  (same-before-crumb x (cdr x) crumb) ; a match
  (same-before-crumb x (cddr x) crumb) ; the crumb
  (same-before-crumb x (cdddr x) crumb) ; something after.
#+END_SRC

#+RESULTS:
: (1 2 a 3 4)
: (2 a 3 4)
: #t
: #t
: #f
: #f

Now, the overall procedure.
In terms of the idea, this has been stated above.
Of note is the temp stores.
These are so we can store the return value of a procedure and then do some clean up.

#+NAME: def:cycle-0
#+BEGIN_SRC racket
  (define (cycle? l)
    <<def:at-least-two?>>
    <<def:insert-crumb>>
    <<def:remove-crumb>>
    (define temp-store-c #f)
    (define current-pair l)
    (define crumb (list 'crumb))
    (define (expedition)
      <<def:push-crumb>>
      <<def:pull-crumb>>
      <<def:same-before-crumb>>
      (define temp-store-e #f)
      (cond ((null? (cdr crumb)) #f) ; base case, where we won't be able to push crumb any further
	    ((eq? current-pair crumb) (set! current-pair l)) ; reset the current pair if we found the crumb.
	    ((same-before-crumb l (cdr crumb) crumb) #t) ; otherwise, check to see if we get the same as what's about to come
	    (else
	     (push-crumb l crumb)
	     (set! current-pair (cdr current-pair))
	     (set! temp-store-e (expedition)) ; and if nothing works, move the crumb forward.
	     (pull-crumb l crumb)
	     temp-store-e)
	    ))
    (cond ((null? l) #f) ; test empty
	  ((null? (cdr l)) #f) ; test single cell
	  ((and (at-least-two? l) (eq? l (cdr l))) #t) ; test first two cells cycle
	  (else
	   (begin
	     (insert-crumb l crumb)
	     (set! temp-store-c (expedition))
	     (remove-crumb l crumb)
	     temp-store-c))))
#+END_SRC

A couple of tests:

#+BEGIN_SRC racket
  <<def:cycle-0>>
  (define x (list 1 2 3 4 5))
  ;  (set-cdr! (cddr x) x)
  x
  (cycle? x)
  ;     (set-cdr! x 0)
  x
  (set-cdr! (cdddr x) x)
  x
  (cycle? x)
  (set-cdr!  x x)
  x
  (cycle? x)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5)
: #f
: (1 2 3 4 5)
: #0=(1 2 3 4 . #0#)
: #t
: #0=(1 . #0#)
: #t

*** Extendining to lists of lists…

At the moment, we only check whether a list cycles.

I.e., there's no way to check whether following the first element of the list cycles back to some element already seen.
However, the above procedures can be modified to move the crumb appropriately, so long as the relevant structure is present (i.e. a list of sufficient length).

Though, there is an issue of returning to where the crumb is.
For, we may need to search through the entire list.

However, this isn't a problem.
We know we haven't been caught in a loop yet, so, as long as the next search goes not further than where we are, it won't get stuck in a loop.

We can do this with a flag.
For each step, we check to see whether the flag allows the search to continue.
And, when we've found the crumb this flag is set to prevent further search.

When a new search starts, the flag resets.

For now, though, this is enough.

** 3.20

Key thing to keep in mind here is the result of ~cons~ is stored in an enviroment directly linked to the global enviroment.
And, ~set-car!~ updates the value of the left element of the pair stores in the ~cons~ environment.

** 3.21

The issue here is the implementation of queues.
A queue points to pair, where the left element points to a list and the right element points to the last element of the list.
The response of the interpreter is to present the pair.
So, we see a pair, the left element of which is the queue constructed and the right element is the last element of the queue.

The only surprising result here is the observation that after deleting ~'b~ as the last element in the queue, the right pointer still points to ~'b~ rather than ~nil~.

** 3.22

Things are very straightfoward.
Only notable point is extra check on delete to see if the end of the queue should be set to nil.
Whether this is useful depends.
As, there's external way to access the rear pointer.
However, internally one may assume this is set to nil when the queue is empty.

And, of course, the need to return no-argument procedures as evaluated.

#+NAME: def:make-queue-message
#+BEGIN_SRC racket
  (define (make-queue)
    (let ((front-ptr nil)
	  (rear-ptr nil))
      (define (empty-q?)
	(eq? front-ptr nil))
      (define (front-queue)
	(if (empty-q?)
	    (error "empty queue")
	    (car front-ptr)))
      (define (insert item)
	(let ((new-pair (cons item nil)))
	  (cond ((empty-q?)
		 (set! front-ptr new-pair)
		 (set! rear-ptr new-pair))
		(else
		 (set-cdr! rear-ptr new-pair)
		 (set! rear-ptr new-pair)))))
      (define (delete)
	(cond ((empty-q?) #f)
	      (else
	       (set! front-ptr (cdr front-ptr))
	       (if (eq? front-ptr nil) ; Check to see if rear pointer should also be updated
		   (set! rear-ptr nil)))))
      (define (dispatch m)
	(cond ((eq? m 'print) (display front-ptr) (newline))
	      ((eq? m 'rear) (display rear-ptr) (newline))
	      ((eq? m 'empty-queue?) (empty-q?))
	      ((eq? m 'front-queue) (front-queue))
	      ((eq? m 'insert-queue) insert)
	      ((eq? m 'delete-queue) (delete))))
      dispatch))
#+END_SRC

Some tests, which access ~make-queue~ via dispatch:

#+BEGIN_SRC racket
  <<def:make-queue-message>>
  (define q (make-queue))
  (q 'empty-queue?)
  ((q 'insert-queue) 5)
  ((q 'insert-queue) 10)
  (q 'front-queue)
  ((q 'insert-queue) 20)
  ((q 'insert-queue) 30)
  (q 'print)
  (q 'rear)
  (q 'delete-queue)
  (q 'print)
  (q 'front-queue)
#+END_SRC

#+RESULTS:
: #t
: 5
: (5 10 20 30)
: (30)
: (10 20 30)
: 10

** 3.23

For a deque, the only operations we need to consider are inserting to the front and deleting to the rear.

To insert to the front, we create a pair where the left is the element to be inserted, and the right is a pointer to the start of the current queue.
Then, we update the start of the queue to the pair just created.

To delete from the rear, requires a different structure.
For, given a list there is no way to discover what points to the object in the list.

So, instead we'll represent a queue as a pair, where to the left is the elemnent, and to the right is a pair where the left points earlier in the queue and the right points later in the queue.

#+NAME: def:deque
#+BEGIN_SRC racket
  (define (make-deque-cell elem) (cons elem (cons nil nil)))

  (define (deque-cell-fnt cell) (car (cdr cell)))

  (define (set-deque-cell-fnt! cell to) (set-car! (cdr cell) to))

  (define (set-deque-cell-rer! cell to) (set-cdr! (cdr cell) to))

  (define (deque-cell-rer cell) (cdr (cdr cell)))

  (define (make-deque) (cons nil nil))

  (define (front-ptr deque) (car deque))

  (define (rear-ptr deque) (cdr deque))

  (define (set-front-ptr! deque item) (set-car! deque item))

  (define (set-rear-ptr! deque item) (set-cdr! deque item))

  (define (empty-deque? deque) (null? (front-ptr deque)))

  (define (front-deque deque)
    (if (empty-deque? deque)
	(error "no elements in deque")
	(car (front-ptr deque))))

  (define (insert-deque-rer! deque item)
    (let ((new-cell (make-deque-cell item)))
      (cond ((empty-deque? deque)
	     (set-front-ptr! deque new-cell)
	     (set-rear-ptr! deque new-cell))
	    (else
	     (set-deque-cell-rer! (rear-ptr deque) new-cell)
	     (set-deque-cell-fnt! new-cell (rear-ptr deque))
	     (set-rear-ptr! deque new-cell)))))

  (define (insert-deque-fnt! deque item)
    (let ((new-cell (make-deque-cell item)))
      (cond ((empty-deque? deque)
	     (set-front-ptr! deque new-cell)
	     (set-rear-ptr! deque new-cell))
	    (else
	     (set-deque-cell-rer! new-cell (front-ptr deque))
	     (set-deque-cell-fnt! (front-ptr deque) new-cell)
	     (set-front-ptr! deque new-cell)))))

  (define (print-deque deque)
    (define (loop cell)
      (cond ((eq? cell nil))
	    ((not (eq? cell (rear-ptr deque)))
	     (display (car cell)) (display ", ")
	     (loop (deque-cell-rer cell)))
	    (else (display (car cell)))))
    (display "(") (loop (front-ptr deque)) (display ")") (newline))

  (define (delete-deque-fnt! deque)
    (cond ((empty-deque? deque) #f)
	  (else (set-front-ptr! deque (deque-cell-rer (front-ptr deque))))))

  (define (delete-deque-rer! deque)
    (cond ((empty-deque? deque) #f)
	  (else (set-rear-ptr! deque (deque-cell-fnt (rear-ptr deque))))))
#+END_SRC

Some tests:

#+BEGIN_SRC racket
  <<def:deque>>
  (define t (make-deque))
  (insert-deque-rer! t 'there)
  (insert-deque-rer! t 'sup)
  (insert-deque-fnt! t 'hi)
  (print-deque t)
  (delete-deque-fnt! t)
  (print-deque t)
  (delete-deque-rer! t)
  (print-deque t)
#+END_SRC

#+RESULTS:
: (hi, there, sup)
: (there, sup)
: (there)

** 3.24

For a table implementation dispatch-style which allows specifying a method to test the equality of keys we create a term which refers to the ~same-key?~ process.
Paired with this is a procedure to update the test.
The only other change is to ~assoc~, where we change the ~equal?~ test to the ~same-key?~ test, and throw and error if no procedure has been specified.

#+BEGIN_SRC racket :tangle no
  (define (make-table)
    (let ((local-table (list '*table*))
	  (same-key? #f))
      (define (update-same-key-test-to! proc)
	(set! same-key? proc))
      (define (assoc key records)
	(cond ((null? records) #f)
	      ((not same-key?)
	       (error "No method for comparing keys"))
	      ((same-key? key (caar records)) (car records))
	      (else (assoc key (cdr records)))))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    #f))
	      #f)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 subtable)))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (list key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      ((eq? m 'update-same-key-to-proc!) update-same-key-test-to!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))
#+END_SRC

** 3.25

#+NAME: def:assoc
#+BEGIN_SRC racket
  (define (assoc key records)
    (cond ((null? records) false)
	  ((equal? key (caar records)) (car records))
	  (else (assoc key (cdr records)))))
#+END_SRC

Insert either finds the key in the table and changes the value.
Or, puts the key as the first thing in the table together with the value.
It doesn't really matter where the key goes, but we have easy access to this position.

#+NAME: def:insert!
#+BEGIN_SRC racket
  (define (insert! key value table)
    (let ((record (assoc key (cdr table))))
      (if record
	  (set-cdr! record value)
	  (set-cdr! table
		    (cons (cons key value) (cdr table))))))
#+END_SRC

To generalise ~insert!~ we form a recursive procedure which works through the list of keys.
When the list is length 1, we have the base case, which is a straightforward instance of ~insert!~ on the current table.
On a recurse case, we check to see if an entry for the current key is present.
If so, the we move to the table associated with the entry and continue with the remaining keys.
Otherwise, we use ~insert~ to create an empty table and then move to this table.

To speed things up slightly, we shortcut to what would be assigned to the term result if the procedure were run again on the same input with the update table.
We could also take advantange of the way ~insert!~ works to jump directly to the new table.
Though, I think it's preferable to key ~insert!~ separate and perform a search.

One way to make this more space efficient is to instantiate a general instance of ~result~.
Then, rather than each frame holding on to a specific instance of ~result~, each frame overwrites the general instance as required.
And, same with the arguments passed.


#+NAME: def:g-insert!
#+BEGIN_SRC racket
  (define (g-insert! keys value table)
    <<def:insert!>>
    (cond ((null? keys) #f)
	  ((= 1 (length keys)) (insert! (car keys) value table))
	  (else
	   (let ((result (assoc (car keys) (cdr table))))
	     (cond (result
		    (g-insert! (cdr keys) value result))
		   (else (insert! (car keys) '() table)
			 (g-insert! (cdr keys) value (assoc (car keys) (cdr table)))))))))
#+END_SRC

Some tests for general insert:

#+NAME: consts:3.24-insert
#+BEGIN_SRC racket
  <<def:insert!>>
  <<def:g-insert!>>
  (define (make-table)
	(cons '*table* nil))

  (define table (make-table))
  (g-insert! (list 'a) 2 table)
  (g-insert! (list 'b) 3 table)
  (g-insert! (list 'c 'd 'e) 4 table)
  (g-insert! (list 'c 'd 'f) 5 table)
  table
#+END_SRC

#+RESULTS:
: (*table* (c (d (f . 5) (e . 4))) (b . 3) (a . 2))

For lookup, we change things up a little.
So long as we have a key and a table, we can request the value of the key via ~assoc~.
Hence, we do so recursively working through the list of keys.
~#f~ is returned whenever a call to ~assoc~ fails.
When a single key remains, we return the value.
Else, we apply the next key to the tabe given by the current key.

#+NAME: def:g-lookup
#+BEGIN_SRC racket
  (define (g-lookup keys table)

    (cond ((null? keys) #f)
	  (else
	   (let ((result (assoc (car keys) (cdr table))))
	     (cond (result
		    (if (= 1 (length keys))
			(cdr result)
			(g-lookup (cdr keys) result)))
		   (else #f))))))
#+END_SRC

Some tests:

#+BEGIN_SRC racket
  <<consts:3.24-insert>>
  <<def:g-lookup>>
  (g-lookup (list 'c 'd 'f) table)
  (g-lookup (list 'a) table)
  (g-lookup (list 'f) table)
#+END_SRC

#+RESULTS:
: (*table* (c (d (f . 5) (e . 4))) (b . 3) (a . 2))
: 5
: 2
: #f

** 3.26

This is a binary tree.
In this case, the idea of a table is as before.
What matters isn't the representation of the data, but the way data is accessed using keys.

** 3.27

~memoise~ takes a procedure ~f~ and creates a table, and returns a procedure.
The return procedure takes an argument and checks to see if it is present in the table.

The puzzle here is about the use of ~or~.

Intuitively, we either return what is stored in the table.
Or, apply ~f~ to the argument, store the result with the key being the argumnet, and return the value.

My guess is ~or~ returns the first non-false value.
This is the case:

#+BEGIN_SRC racket
  (or 3 4)
  (or #f 5)
#+END_SRC

#+RESULTS:
: 3
: 5

~memo-fib~ computes the $n$th Fibonacci number in a number of steps proportional to $n$ as on the $i$th call we check the table for the arguments $i - 1$ and $i - 2$.
So, this is less than $2i$ operations, and the work performed to get the $i$th Fibonnaci number is rouhgly constant.
Assuming, that is, the table has been filled up to $i$ (and if the table has been filled beyond $i$ then it's at most $i$ lookups to find the result in the table).

In particular, recursive calls are made but immediately terminate as the result of these calls is stored in the table.

Memoisation would not have workd if we had defined ~memo-fib~ to be ~(memoise fib)~.
For, ~fib~ makes a recursive call to ~fib~, and these calls to ~fib~ would not themselves detour through ~(memoise fib)~ to see if the results are in the table.

** 3.28

~or-gate~ parallels ~and-gate~.
We've got a two-place function which should be run if either input changes.
The only difference is what is obtained.

#+BEGIN_SRC racket :tangle no
  (define (or-gate a1 a2 output)
    (define (or-action-procedure)
      (let ((new-value
	     (logical-or (get-signal a1) (get-signal a2))))
	(after-delay or-gate-delay
		     (lambda ()
		       (set-signal! output new-value)))))
    (add-action! a1 or-action-procedure)
    (add-action! a2 or-action-procedure)
    'ok)
#+END_SRC

We can define ~logical-or~ as follows:

#+BEGIN_SRC racket :tangle no
  (define (logical-or a b)
    (cond ((or (= a 1) (= b 1)) 1)
	  ((and (= a 0) (= b 0)) 0)
	  (else (error "Invalid signal" s))))
#+END_SRC

Or, we could go through all the cases in disjunctive normal form to be very explicit about things.

** 3.29

The basic observation here is that A or B = (not ((not A) and (not B))).

So, to make this we need a few wires and the right combination of inverters and and-gates.

#+BEGIN_SRC racket :tangle no
  (define (or-gate a1 a2 output)
    (let ((not-a1-wire (make-wire))
	  (not-a2-wire (make-wire))
	  (and-wire (make-wire)))
      (inverter a1 not-a1-wire)
      (inverter a2 not-a2-wire)
      (and-gate not-a1-wire not-a2-wire and-wire)
      (inverter and-wire output))
#+END_SRC

** 3.30

A full adder looks like this:

#+BEGIN_SRC racket
  (define (full-adder a b c-in sum c-out)
    (let ((s (make-wire))
	  (c1 (make-wire))
	  (c2 (make-wire)))
      (half-adder b c-in s c1)
      (half-addera s sum c2)
      (or-gate c1 c2 c-out)
      'ok))
#+END_SRC

~ripple-carry-adder~ works through the lists of A, B, and S wires until it's not possible to add another.
At each step we create a C wire as needed.
And, rather than leave a term for the current wire in frames created by a recursive call, we keep pointers to the remaining types of wires.

#+BEGIN_SRC racket
  (define (ripple-carry-adder A B S C)
    (let ((C-wires (list C))
	  (A-wires A)
	  (B-wires B)
	  (S-wires A))
      (define (add-another)
	(cond ((or (null? A-wires) (null? B-wires) (null? S-wires)) 'ok)
	      (else
	       (set! C-wires (cons (make-wire) C-wires)) ; Add a new c-wire to the list of C-wires
	       (full-adder (car A-wires) (car B-wires) (cadr C-wires) (car S-wires) (car C-wires))
	       (set! A-wires (cdr A-wires))
	       (set! B-wires (cdr B-wires))
	       (set! S-wires (cdr S-wires)))))
      add-another))
#+END_SRC

In terms of delay, we have $k$ full-adders.
So, we'll have $k$ times the delay of each full-adder.
In turn, this is the delay of two half-adders and and the delay of an or.
In total:

$k \times (2 \times (\text{inverter} + 2 \times \text{and} + \text{or}) + \text{or})$.

** Wires

#+NAME: def:call-each
#+BEGIN_SRC racket
  (define (call-each procedures)
    (if (null? procedures)
	'done
	(begin
	  (car procedures)
	  (call-each (cdr procedures)))))
#+END_SRC

#+NAME: def:make-wire
#+BEGIN_SRC racket
  (define (make-wire)
    (let ((signal-value 0)
	  (action-prcoedures '()))

      (define (set-my-signal! new-value)
	<<def:call-each>>
	(if (not (= signal-value new-value))
	    (begin (set! signal-value new-value)
		   (call-each action-procedures))
	    'done))

      (define (accept-action-procedure! proc)
	(set! action-procedures (cons proc action-procedures))
	(proc))

      (define (dispatch m)
	(cond
	  ((eq? m 'get-signal) signal-value)
	  ((eq? m 'set-signal!) set-my-signal!)
	  ((eq? m 'add-action!) accept-action-procedure!)
	  (else (error "unkown operation -- WIRE" m))))
      dispatch))
#+END_SRC

~make-wire~ is interesting.
In particular, the call ~(proc)~ in ~accept-action-procedure!~.
In short, this expands all the ~let~ instances, so on next call (e.g.) ~or-action-procedure~ 'happens'.
Important to keep in mind here is the procedure is only executed relative to the current wire.

Important to keep in mind, huh.
When evaluating a procedure, nothing about the procedure changes.
Instead, the pointer to the procedure not points to the output of the procedure.

#+BEGIN_SRC racket
  (define (get-signal wire) (wire 'get-signal))

  (define (set-signal! wire new-value) ((wire 'set-signal!) new-value))

  (define (add-action! wire action-procedure) ((wire 'add-action!) action-procedure))
#+END_SRC

** 3.31

This question asks about the observation made above regarding ~(proc)~.
If we don't immedately run the procedure, then the next run of the procedure 'just' initialises the ~let~ terms and returns the procedure of interest.

** 3.32

If the procedures to be rin during each time segement of the agenda were kept in a list, procedures would be called first-in first-out.

Okay, to see the problem, suppose we have:


#+BEGIN_SRC racket
    (set-signal! input-1 0)
    (set-signal! input-2 1)
#+END_SRC

And, consider the following sequence:

#+BEGIN_SRC racket :tangle no
  (set-signal! input-1 1)
  (logical-and input-1 input-2)
  (set-signal! input-2 0)
#+END_SRC

The ~logical-and~ operation returns ~#t~ and ~input-1~ is set to ~1~ before ~logical-and~.
However, if read first-in first-out, then ~input-2~ is set to ~0~ before ~logical-and~.

So, we get a different result.
But, how viable is this?
In principle both signals could change at the same time, and in this case it seems and should remain ~#f~ throughout the segment.
Which, suggests signal changes should be processed first.
And, we should have some checks to ensure the physically impossible does not happen.
But, all this might be a bit much for now…

** Constraint system

#+NAME: def:adder
#+BEGIN_SRC racket
  (define (adder a1 a2 sum)
    <<def:connect>>
    (define (process-new-value)
      <<def:has-value?>>
      <<def:get-value>>
      <<def:set-value!>>
      (cond ((and (has-value? a1) (has-value? a2))
	     (set-value! sum
			 (+ (get-value a1) (get-value a2))
			 me))
	    ((and (has-value? a1) (has-value? sum))
	     (set-value! a2
			 (- (get-value sum) (get-value a1))
			 me))
	    ((and (has-value? a2) (has-value? sum))
	     (set-value! a1
			 (- (get-value sum) (get-value a2))
			 me))))
    (define (process-forget-value)
      <<def:forget-value!>>
      (forget-value! sum me)
      (forget-value! a1 me)
      (forget-value! a2 me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
	     (process-new-value))
	    ((eq? request 'I-lost-my-value)
	     (process-forget-value))
	    (else
	     (error "Unknown request -- ADDER" request))))
    (connect a1 me)
    (connect a2 me)
    (connect sum me)
    me)
#+END_SRC

#+RESULTS:

~adder~ is a message passing procedure.
When a message is recieved.
There are two options.

1. ~process-new-value~, where the third value is attempted to be filled given two other values.
   No ~else~ is specified here.
2. ~process-forget-value~, which fogets the values for each of the related connectors.
   I'm not sure what the call to ~process-new-value~ does here.
   Ah, it depends on ~has-value?~ and ~forget-value!~.
   For, it may be the case that ~forget-value!~ doesn't ensure there's no way to determine the value, and ~has-value?~ may check for any way to fix the value.

#+NAME: def:inform-about-value
#+BEGIN_SRC racket
  (define (inform-about-value constraint)
    (constraint 'I-have-a-value))
#+END_SRC

#+NAME: def:inform-about-no-value
#+BEGIN_SRC racket
  (define (inform-about-no-value constraint)
    (constraint 'I-lost-my-value))
#+END_SRC

~adder~ is a particular constraint, but all constraints will have this form.
Indeed, it's possible to generalise things by creating a process which takes a list of terms and two processes.
The two process should then return a argument-less process which works on the given processes.
Anyway…

#+NAME: def:multiplier
#+BEGIN_SRC racket
  (define (multiplier m1 m2 product)
    <<def:connect>>
    (define (process-new-value)
      <<def:has-value?>>
      <<def:get-value>>
      <<def:set-value!>>
      (cond ((or
	      (and (has-value? m1) (= (get-value m1) 0))
	      (and (has-value? m1) (= (get-value m1) 0)))
	     (set-value! product 0 me))
	    ((and (has-value? m1) (has-value? m2))
	     (set-value! product
			 (* (get-value m1) (get-value m2))
			 me))
	    ((and (has-value? m1) (has-value? product))
	     (set-value! m2
			 (/ (get-value product) (get-value m1))
			 me))
	    ((and (has-value? m2) (has-value? product))
	     (set-value! m1
			 (/ (get-value product) (get-value m2))
			 me))))
    (define (process-forget-value)
      <<def:forget-value!>>
      (forget-value! product me)
      (forget-value! m1 me)
      (forget-value! m2 me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
	     (process-new-value))
	    ((eq? request 'I-lost-my-value)
	     (process-forget-value))
	    (else
	     (error "Unknown request -- ADDER" request))))
    (connect m1 me)
    (connect m2 me)
    (connect product me)
    me)
#+END_SRC

~multiplier~ works the same as ~adder~.
Note, we're never going to attempt to divide by anything unknown, nor divide by zero.

#+NAME: def:constant
#+BEGIN_SRC racket
  (define (constant value connector)
    <<def:connect>>
    <<def:set-value!>>
    (define (me request)
      (error "Unknown request -- CONSTANT" request))
    (connect connector me)
    (set-value! connector value me)
    me)
#+END_SRC

Okay, this sets the value with an identifier.
I'm not sure why this needds to conform to the message passing protocol though.
On the other hand, it does mean the error is a custom error, and not a generic wrong arguments type thing.

#+NAME: def:probe
#+BEGIN_SRC racket
  (define (probe name connector)
    <<def:connect>>
    (define (print-probe value)
      (display "Probe: ")
      (display name)
      (display " = ")
      (display value)
      (newline))
    (define (process-new-value)
      <<def:get-value>>
      (print-probe (get-value connector)))
    (define (process-forget-value)
      (print-probe "?"))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
	     (process-new-value))
	    ((eq? request 'I-lost-my-value)
	     (process-forget-value))
	    (else
	     (error "Unknown request -- PROBE" request))))
    (connect connector me)
    me)
#+END_SRC

#+NAME: def:make-connector
#+BEGIN_SRC racket
    (define (make-connector)
      (let ((value false)
	    (informant false)
	    (constraints '()))
	(define (set-my-value newval setter)
	  <<def:for-each-except>>
	  <<def:has-value?>>
	  <<def:inform-about-value>>
	  (cond ((not (has-value? me))
		 (set! value newval)
		 (set! informant setter)
		 (for-each-except setter
				  inform-about-value
				  constraints))
		((not (= value newval))
		 (error "Contradiction" (list value newval)))
		(else 'ignored)))
	(define (forget-my-value retractor)
	  <<def:for-each-except>>
	  <<def:inform-about-no-value>>
	  (if (eq? retractor informant)
	      (begin (set! informant false)
		     (for-each-except retractor
				      inform-about-no-value
				      constraints))
	      'ignored))
	(define (connect new-constraint)
	  <<def:inform-about-value>>
	  <<def:has-value?>>
	  (if (not (memq new-constraint constraints))
	      (set! constraints
		    (cons new-constraint constraints)))
	  (if (has-value? me)
	      (inform-about-value new-constraint))
	  'done)
	    (define (me request)
	      (cond ((eq? request 'has-value?)
		     (if informant true false))
		    ((eq? request 'value) value)
		    ((eq? request 'set-value!) set-my-value)
		    ((eq? request 'forget) forget-my-value)
		    ((eq? request 'connect) connect)
		    (else
		     (error "Unknown operation -- CONNECTOR" request))))
	    me))
#+END_SRC



#+NAME: def:for-each-except
#+BEGIN_SRC racket
  (define (for-each-except exception procedure l)
    (define (loop items)
      (cond ((null? items) 'done)
	    ((eq? (car items) exception) (loop (cdr items)))
	    (else (procedure (car items))
		  (loop (cdr items)))))
    (loop l))
#+END_SRC

#+NAME: def:has-value?
#+BEGIN_SRC racket
  (define (has-value? connector)
    (connector 'has-value?))
#+END_SRC

#+NAME: def:get-value
#+BEGIN_SRC racket
  (define (get-value connector)
    (connector 'value))
#+END_SRC

#+NAME: def:set-value!
#+BEGIN_SRC racket
  (define (set-value! connector new-value informant)
    ((connector 'set-value!) new-value informant))
#+END_SRC

#+NAME: def:forget-value!
#+BEGIN_SRC racket
  (define (forget-value! connector retractor)
    ((connector 'forget) retractor))
#+END_SRC

#+NAME: def:connect
#+BEGIN_SRC racket
  (define (connect connector new-constraint)
    ((connector 'connect) new-constraint))
#+END_SRC

*** Converter

And, the C-F-contraint to test.
(Here, probes have been added to the definition of the converter to supress the ~me~ return from making the probe.)

#+NAME: def:c-to-f-converter
#+BEGIN_SRC racket
  (define (c-to-f-converter c f probe?)
    <<def:make-connector>>
    <<def:multiplier>>
    <<def:adder>>
    <<def:constant>>
    <<def:probe>>
    (let ((u (make-connector))
	  (v (make-connector))
	  (w (make-connector))
	  (x (make-connector))
	  (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    (cond (probe? (probe "Celsius temp" c)
		  (probe "Fahrenheit temp" f)))
    'ok
    ))
#+END_SRC


#+BEGIN_SRC racket
  <<def:make-connector>>
  <<def:c-to-f-converter>>
  <<def:set-value!>>
  <<def:probe>>
  <<def:make-probe>>

  (define C (make-connector))
  (define F (make-connector))

  (c-to-f-converter C F #t)

  (set-value! C 25 'user)
#+END_SRC

#+RESULTS:
: ok
: Probe: Celsius temp = 25
: Probe: Fahrenheit temp = 77
: done

** 3.34

~squarer~ is no use.

#+BEGIN_SRC racket :tangle no
  (define (squarer a b)
    (multiplier a a b))
#+END_SRC

For, ~multiplier~ only has the capacity to determine one term given the other two terms.
Hence, as ~a~ is given as an argument twice, it is not possible to use ~squarer~ to determine an unkown value (i.e. both values must be known in advance).

** 3.35

To define ~squarer~ we make use of ~square~ and ~sqrt~, just as, e.g., ~adder~ makes use of ~+~ and ~-~.

#+NAME: def:multiplier
#+BEGIN_SRC racket
  (define (squarer a b)
    <<def:connect>>
    (define (process-new-value)
      <<def:has-value?>>
      <<def:get-value>>
      <<def:set-value!>>
      <<def:square>>
      (cond ((has-value? a) (set-value! b (square (get-value a)) me))
	    ((has-value? b)
	     (if (< (get-value b) 0)
		 (error "square less than 0 -- SQUARER" (get-value b))
		 (set-value! a (sqrt (get-value b)) me)))))
    (define (process-forget-value)
      <<def:forget-value!>>
      (forget-value! a me)
      (forget-value! b me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
	     (process-new-value))
	    ((eq? request 'I-lost-my-value)
	     (process-forget-else))
	    (value
	     (error "Unknown request -- SQUARER" request))))
    (connect a me)
    (connect b me)
    me)
#+END_SRC

** 3.36

Still don't have a good way to represent enviroment diagramns here.

The important thing about these networks is that the transmission of any given piece of information creates a directed acyclic graph.
Directed, as messages are passed from connected components via connectors to other connected components.
And, acyclic as otherwise ~set-value!~, etc., would have no guarantee of terminating.

~for-each-except~ is important for ensuring the message graph is acyclic.
For, it allows us to message every connected component /other than/ the current component.

** 3.37

The basic point here is that the constraint system requires connectors for all the parts of a term.
E.g., for addition we need the two numbers to be added and the sum of the two numbers.
And, the standard arguments-plus-operator-leaving-result-implicit does not lend itself to specifying a connected for the result.

Further, by returning the connector for the result, it is easy to chain together operators.

However, there's a slight issue.
If we inspect the original C/F coverter, we'll see ~v~ is used as an argument to both an ~adder~ and a ~multiplier~.
It's not possible to express this constraint using the binary operators, without doing something kind of unnatural.

As a graph, the system of constraints looks like this:

#+BEGIN_SRC racket
  y (32)    v         x (5)  w (9)    c
  |--(+)---| |--(*)---|      |---(*)--|
     |           |                |
     |           |                |
     |-> f       |--->   u  <-----|
#+END_SRC

~v~ is the link between ~c~ and ~f~.
I guess there's some analysis that can be done here.
Some way of identifying a common variable between two expressions.

When building with the more standard operations, we're going to end up with a more natural relationship between ~f~ and ~c~.
As, there's no option to insert ~v~ type varaibles of the kind above.

So, this means we also need a divider.
We work this out in full:

#+NAME: def:divider
#+BEGIN_SRC racket
  (define (divider numer denomer division)
    <<def:connect>>
    (define (process-new-value)
      <<def:has-value?>>
      <<def:get-value>>
      <<def:set-value!>>
      (cond ((and (has-value? denomer) (has-value? division))
	     (set-value! numer (* (get-value denomer) (get-value division)) me))
	    ((and (has-value? numer) (has-value? denomer) (not (= (get-value denomer) 0)))
	     (set-value! division (/ (get-value numer) (get-value denomer)) me))
	    ((and (has-value? numer) (has-value? division) (not (= (get-value numer) 0)))
	     (set-value! denomer (/ (get-value division) (get-value numer)) me))))
    (define (process-forget-value)
      <<def:forget-value!>>
      (forget-value! division me)
      (forget-value! numer me)
      (forget-value! denomer me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
	     (process-new-value))
	    ((eq? request 'I-lost-my-value)
	     (process-forget-value))
	    (else
	     (error "Unknown request -- DIVIDER" request))))
    (connect numer me)
    (connect denomer me)
    (connect division me)
    me)
#+END_SRC

The definitions for the constraint-operations are all very similar:

#+NAME: defs:3.37
#+BEGIN_SRC racket
  <<def:make-connector>>
  <<def:set-value!>>
  (define (c+ x y)
    <<def:adder>>
    (let ((z (make-connector)))
      (adder x y z)
      z))

  (define (c* x y)
      <<def:multiplier>>
    (let ((z (make-connector)))
      (multiplier x y z)
      z))

  (define (c/ x y)
    <<def:divider>>
    (let ((z (make-connector)))
      (divider x y z)
      z))

  (define (cv x)
    <<def:constant>>
    (let ((z (make-connector)))
      (constant x z)
      z))
#+END_SRC

And, the test:

#+BEGIN_SRC racket
  <<defs:3.37>>
  <<def:probe>>
  (define (celsius-farenheit-converter c)
    (c+ (c* (c/ (cv 9) (cv 5))
	    c)
	(cv 32)))

  (define C (make-connector))
  (define F (celsius-farenheit-converter C))
  (probe "Celsius temp" C)
  (probe "Fahrenheit temp" F)

  (set-value! C 25 'user)
  ;(set-value! F 225 'user)
#+END_SRC

#+RESULTS:
: #<procedure:...rg-babel-qJF37c.rkt:229:2>
: #<procedure:...rg-babel-qJF37c.rkt:229:2>
: Probe: Celsius temp = 25
: Probe: Fahrenheit temp = 77
: done

** 3.38

*** a.

The important operation is Mary, as this is a relative operation (taking half).

| Peter | Paul  | Mary  | 45 |
| Peter | Mary  | Paul  | 35 |
| Paul  | Peter | Mary  | 45 |
| Paul  | Mary  | Peter | 50 |
| Mary  | Peter | Paul  | 40 |
| Mary  | Paul  | Peter | 40 |

*** b.

No easy way to draw a timiing diagram here (and I think it's a little underspecified in the book).
Still, to see all the different values that may be procudes we can write things out algenraically:

| Peter | Paul  | Mary  | Base + (Pe + Pa) / Ma   |
| Peter | Mary  | Paul  | Base + (Pe / Ma) + Pa   |
| Paul  | Peter | Mary  | Base + (Pa + Pe) / Ma   |
| Paul  | Mary  | Peter | Base + (Pa / Ma) + Pe   |
| Mary  | Peter | Paul  | (Base / Mary) + Pe + Pa |
| Mary  | Paul  | Peter | (Base / Mary) + Pe + Pa |

One thing to note is that the possibilities here are more general than those obtained by ignoring paretheses and then exploring all possible ways to re-add parentheses (assing plus, etc., are binary operations).
For, e.g., the first row doesn't allow an operation to be performed on ~Base~ and ~Ma~, while the last row does.

** 3.39

The five options interleavings listed are:

| 101 | P1 multiplies x, then P2 increments x.                                                               |
| 121 | P2 incremenets x, then P1 multiplies x.                                                              |
| 110 | P1 takes the first instance of x, P2 increments x, P1 takes the second instance of x and multiplies. |
|  11 | P2 takes the instance of x, P1 mutliplies x, P2 sets x.                                              |
| 100 | P1 takes both instances of x, P2 increments x, P1 sets x.                                            |

If we have:

#+BEGIN_SRC racket :tangle no
  (define x 10)

  (define s (make-serializer))

  (parallel-execute (s (lambda (x) (set! x (* x x))))
		    (s (lambda (x) (set! x (+ x 1)))))
#+END_SRC

Then, it is not possible for both P1 and P2 to execute at the same time.
Hence, only the first two options (results 101 and 121) are possible.
(I.e. P1 executes then P2 executes or P2 executes then P1 executes.)

** 3.40

If we have:

#+BEGIN_SRC racket :tangle no
  (define x 10)

  (parallel-execute (lambda (x) (set! x (* x x)))
		    (lambda (x) (set! x (* x x x))))
#+END_SRC

Then we have the following options, where execution patterns have not been collected under equivalent outputs.

| (* 100  100 100) | P1 then P2                                                           |
| (* 1000 1000)    | P2 then P1                                                           |
| (* 10 1000)      | P1 takes first instance of x, P2 sets x, P1 takes second instance    |
| (* 10 10)        | P1 takes both instances, P2 sets x, P1 sets x.                       |
| (* 10 10 10)     | P2 takes instance of x, P1 sets x, P2 sets x                         |
| (* 10 100 100)   | P2 takes first instance of x, P1 sets x, P2 takes second and third.  |
| (* 10 10 100)    | P2 takes first and second instances of x, P1 sets x, P2 takes third. |

Note, in particular, ~(* 10 100 10)~ is not a possible output.
So long, that is, arguments are evaluated left to right.
For, P2 must have set x to 100 in order for the second argument to be 100.
Hence, the third argument must also be 100.

Though, with evaluate by call, we can't be sure without looking into ~*~ further.
Given a list ~*~ reverses the list, and the calls from left to right, etc.

If we have:

#+BEGIN_SRC racket :tangle no
  (define x 10)

  (define s (make-serializer))

  (parallel-execute (lambda (x) (set! x (* x x)))
		    (lambda (x) (set! x (* x x x))))
#+END_SRC

Then, as with 3.39, only the first two interleavings are possible.

** 3.41

A procedure for making and maintaing a bank account is serialised to it is not possible to withdraw and deposit concurrently.

It is suggested reading the balance should be serialised to the same set.

However, it is not clear why this should be done.
There is clear motivation for serialising withdraw and deposit as these change the balance of the account.
However, viewing the balance does not lead to any change.

One concern is the user getting the wrong idea of the balance by viewing the balance just before or during a withdraw or deposit.
However, serialisation doesn't help to prevent this, as seralisation only enforces order, and view balance may stil occur before withdraw or deposit if all three are serialisated and concurrently called.

** 3.42

This seems dangerous.

If the calls to ~protected~ are done outside the ~dispatch~ procedure then only the calls are serialised.

So, withdraw must be called before deposit, or vice-versa, but nothing prevents deposit being executed while withdraw is being exceuted.

For example, we may have:

1. Call to withdraw is made.
2. Withdraw beings executing (but does not complete).
3. As the call to withdraw has been made, a call to deposit is made.
4. Deposit beings executing (while withdraw is exeucting).
5. Deposit sets the balance.
6. Withdraw sets the balance (ignoring the updated balance by deposit).

** 3.43

The revised deposit is:

#+BEGIN_SRC racket :tangle no
  (define (deposit account amount)
    (let ((s (account 'serializer))
	  (d (account 'deposit)))
      ((s d) amount)))
#+END_SRC

So, we get the seraliser, and the deposit function, and defer the call to despoist after everything present in the serialised collection has been completed (though, really, this depends on the way the collection is managed --- deposit could be given priority).

Now, the serialised exchange program is written:

#+BEGIN_SRC racket :tangle no
  (define (serialized-exchange account1 account2)
    (let ((serializer1 (account1 'serializer))
	  (serializer2 (account2 'serializer)))
      ((serializer1 (serializer2 exchange))
       account1
       account2)))
#+END_SRC

Here, then, ~exchange~ is wrapped in two serialisers.

There are four cases to consider:

1. Something under ~serializer1~ is running, and a call to ~serialized-exchange~ is made.

   - As ~serialized-exchange~ first checks ~serializer1~, an immediate call to ~exhange~ is blocked.

2. Something under ~serializer2~ is running, and a call to ~serialized-exchange~ is made.

   - As ~serialized-exchange~ checks ~serializer2~ before calling ~exchange~, an immediate call to ~exhange~ is blocked.

3. ~serialized-exchange~ is running, and a call to something under ~serializer1~ is made.

   - ~serialized-exchange~ is running, so a processed under ~serializer1~ is running.
     This blocks any other procedure under ~serializer1~ running immediately.

4. ~serialized-exchange~ is running, and a call to something under ~serializer2~ is made.

    - ~serialized-exchange~ is running, so a processed under ~serializer2~ (also under ~serializer1~) is running.
	This blocks any other procedure under ~serializer1~ running immediately.


This covers everyhing.
Note, also, the reasoning does not depend on the order of the serialisers enclosing ~exchange~.
What matter is ~excahnge~ being guarded in both respects.

And, we need both serialisers, as the purpose is to allow any procedures that do not cross accounts to run concurrently.

** 3.44

Transferring money from one account to another.

Proposed is:

#+BEGIN_SRC racket :tangle no
  (define (transfer from-account to-account amount)
    ((from-account 'withdraw) amount)
    ((to-account) 'deposit) amount))
#+END_SRC

First up is the messages.
These should both make calls to seralised procedures.
For example:

#+BEGIN_SRC racket :tangle no
  (define (transfer from-account to-account amount)
    (let ((from-s (account 'serializer))
	  (from-p (from-account 'withdraw)))
      ((s d) amount))
    (let ((to-s (account 'serializer))
	  (to-p (from-account 'deposit)))
      ((s d) amount)))
#+END_SRC

Though, it may be the case that these are handled internally.

Though, after this, no additional work is required, one would expect.

One question is whether it is possible for the arguments to change in unexpected ways.
Yet, there is plausibly no modification to ~transfer~ which would help here.
For example, it would seem bad if amount changed mid transfer, but it's not clear ~transfer~ should make a copy of the arguments given.

On the other hand, if transfer made use of some intermediate store and there were other ways to access the store, serliasation should be put in place to prevent any other access during the transfer.

** 3.45

Ah, this is cool.

The key observation here is something like ~(serializer1 (serializer2 (serializer1 proc)))~ will fail to execute properly.
For, when the call to this is made, a process under ~serializer1~ is running.
Now, suppose ~serializer2~ is free.
Then, another call to ~serializer1~ is made.
But, the call to the nested serialisers made ensures no other task beloning to ~serializer1~ can start.

So, this emphasises the need to expose procedures without serialisation when one may wish to combine serialisers.

** Serialisers

#+BEGIN_SRC racket :tangle no
  (define (make-serializer)
    <<def:make-mutex>>
    (let ((mutex (make-mutex)))
      (lambda (p)
	(define (serialized-p . args)
	  (mutex 'aquire)
	  (let ((val (apply p args)))
	    (mutex 'release)
	    val))
	serealized-p)))
#+END_SRC

Note, here, the mutex is aquired until the process reutrns a value.

Take in a procedure.
Then, return something which returns a procedure sandwidched by aquiring and releasing the mutex at the base of the serialiser.

At least going by style, it seems this should ensure the procedure is eventually run when called.
It's just that it could take a while for ~(mutex 'acquire)~ to complete.

I.e. this is not of the form:
/If/ mutex is open to being immediately aquired /then/ go!

We could, instead, aquire the mutex, evaluate all the arguments, and then release the mutex…

#+NAME: def:make-mutex
#+BEGIN_SRC racket
  (define (make-mutex)
    (let ((cell (list false)))
      (define (the-mutex m)
	<<def:test-and-set!>>
	<<def:mutex-clear>>
	(cond ((eq? m 'acquire)
	       (if (test-and-set! cell)
		   (the-mutex 'acquire)))
	      ((eq? m 'release) (clear! cell))))
      the-mutex))
#+END_SRC

~cell~ stores whether the mutex has been acquired, or is realeased.
And a mutex takes two messages.
What happens on ~'release~ seems clear: set ~cell~ to ~#f~.
What happens on ~'acquire~ is less clear.
So long as ~test-and-set!~ returns true, we'll enter a loop.
In some respects, this is fine.
~(mutex 'acquire)~ loops until some condition is satisfied.
But, you can't 'just' create a loop, right?
Don't we need some guarantee the process on other procedures happens while the loop runs?

~clear~ just clears.

#+NAME: def:mutex-clear
#+BEGIN_SRC racket
  (define (clear! cell)
    (set-car! cell false))
#+END_SRC

~test-and-set!~ tests and sets! (This name isn't descriptive enough!)
The procedure tests to seee if the mutex has been acquired.
Otherwise, it sets the mutex as aquired and returns false.

#+NAME: def:mutex-clear
#+BEGIN_SRC racket
  (define (test-and-set! cell)
    (if (car cell)
	true
	(begin (set-car! cell true)
	       false)))
#+END_SRC

Though, this should be a single instruction, in practice.

I kind of feel as though time is the wrong way to think about concurrency.
For, what matters is that we have the ability to execute procedures in parallel.
And, the 'base units' of time are really just atomic processes.
These can take as much 'time' as they like, the time of the overall system is relative to these.

** 3.46

If ~test-and-set!~ is implemented as an ordinary procedure, two distinct processes may both call ~test-and~set!~.
In this case, concurrent execution of ~set-car!~ may raise and issue, but regardless of this two processes have aquired the mutex, and will run in parallel.

** 3.47

*** First implementation: cells

For the first implementation of semaphores, we have a helper procedure to create a list of some value ~x~ ~n~ times.
We'll use this to create a list of 'mutexs'.

#+NAME: def:list-x-n-times
#+BEGIN_SRC racket
  (define (list-x-n-times x n)
    (let ((l '()))
      (define (add-times n)
	(cond ((> n 0)
	       (set! l (cons x l))
	       (add-times (- n 1)))))
      (add-times n)
      l))
#+END_SRC

Now, ~make-semaphore~ starts by creating a list of unaquired mutexes.
Key to this implementation is a procedure which finds the first occurence of ~#f~ in the list.

In contrast to mutexes, a pointer to this first occurence is going to function as a ticket.
This pointer is returned when ~'acquire~ completes, and is given when ~'release~ is called.

Like ~make-mutex~, ~'acquire~ repeatedly calls ~get-free-cell~ until a ticket is acquired.

#+BEGIN_SRC racket :tangle no
  (define (make-semaphore n)
    <<def:list-x-n-times>>
    (let ((cells (list-x-n-times #f n)))
      (define (get-free-cell)
	(let ((free-cell cells))
	  (cond ((eq? (car free-cell) #f) free-cell)
		((eq? (free-cell) nil) #f)
		((eq? (free-cell) #t)
		 (set! free-cell (cdr free-cell))))))
      (define (the-semaphore m)
	(cond ((eq? m 'acquire)
	      (if free-cell
		  (begin
		    (set-car! free-cell #t)
		    free-cell)
		  (get-free-cell)))
	      ((eq? m 'release)
	       (lambda (cell) (set-car! #f)))))
      the-semaphore))
#+END_SRC

This procedure could be improved on by optimising the ~get-free-cell~ procedure.
We don't really need to start the search from the start each time, we just need to loop around to where we started.
But, this is for some other time!

*** Second implementation: cells as mutexes

Note, the first implementation could easily be reworked to use a list of mutexes.

Rather than searching for a free cell as implemented, we could apply ~test-and-set!~ (as defined on mutexes) to each cell in the list.

And, rather than giving a pointer to the cell as a ticket, we could simply search for the first ~#t~ cell and call ~clear!~ on that cell.
(Note, nothing depends on any /particular/ mutex.)



*** Third implementation: a count

Though, I think even the above is excessive.
The point of a semaphore is to allow $n$ procedures to run concurrently, so instead of storing a boolean, just store an integer.
The count starts at 0.
When a call to ~'acquire~ is made, the count increases if it's less than n, else another attempt is made.
And, when a call to ~clear!~ is made, the count is decrimented.

#+BEGIN_SRC racket :tangle no
  (define (make-semaphore n)
    (let ((cell (list 0)))
      (define (the-mutex m)
	(cond ((eq? m 'acquire)
	       (if (test-and-set! cell)
		   (the-mutex 'acquire)))
	      ((eq? m 'release) (clear! cell))))
      the-mutex))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (define (clear! cell)
    (set-car! cell (- cell 1)))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (define (test-and-set! cell)
    (if (car (< cell n))
	true
	(begin (set-car! cell (+ cell 1))
	       false)))
#+END_SRC

I guess the list approach may save some space, at the cost of additional work to check whether a cell is free.

** 3.48

The dead-lock problem introcued relies on introducing serialisation cycles.
Procedure A under serialisation A calls procedure B uder serialisation B, which in turns calls for procedure A' under serialisation A.
But, procedure A is already in process, so it is not possible for procedure A' to start.

Put differently, if it is only possible to take on a procedure under some distinct serialisation then it is possible for the process to conitnue.

Proof by induction works here, if you want all the details.

Base case of 1 serialisation is straightforward.

If it is possible to call the serialised procedure, the procedure will complete.
For, call the procedure and you have something unserialised.

Now, inductive hypothesis is that every serialisation is unique, and the (n -1)th procedure will terminate.

We want to show: If you can call the nth procedure, you can all the (n-1)th procedure.

Well, it's clear it's possible to call the nth, and then the (n - 1)th, as these are two distinct serialisations.

Well, that's a little lax, but I take the idea to be sufficiently clear.
Again: So long as you know each serialisation is unique, you can always reduce the layer of serialisation.

** 3.49

*** Keeping busy while waiting for you

Procedure A is busy.

Procedure B requires the result of procedure A which will be set to a term.
However, while procedure B waits for procedure A to complete, procedure B can do other things.
Procedure B may be interrupted, but wishes to only work on the result of procedure A.
And, procedure B does not have information about procedure A's serialisation.
So, procedure B sets any task they begin to work on to have the highest priority (i.e. simply ignores any other requests) and check in to see the status of A reguarly.

When procedure A completes their result, they wish to ensure procedure B picks up on the value of the term immediately.
But, to avoid waiting around, if procedure B is busy, they'll do their own thing.
As with procedure B, procedure A wishes to avoid interruptions, so checks back on the status of procedure B periodically.

Now, it's not possible for this to go anywhere.

When checking on each other's status, both procedures are busy.
And, when not checking on each others status, each procedure is busy.

At some point, at least one of the procedures must be idle.

However, even if each proccess is idle for some time it may be the case that:

1. Both procecess are idle at exactly the same time.
2. Each procedure is only idle when the other procedure is busy doing it's own thing.

While typing this up I began thinking about the two generals problem, or alterantively common knowledge, etc…

** 3.50

The following instance of ~stream-map~ takes a procedure of $n$ arguments together with $n$ streams, and applies the procedure to all the $i$th elements of respective streams, resulting in a stream of streams.

#+NAME: def:stream-map
#+BEGIN_SRC racket
  (define (stream-map proc . argstreams)
    <<def:sc-list-stream>>
    (if (stream-null? (car argstreams))
	the-empty-stream
	(cons-stream
	 (apply proc (map stream-car argstreams))
	 (apply stream-map (cons proc (map stream-cdr argstreams))))))
#+END_SRC

If there are no argument streams, it is not possible to apply the procedure, and so the empty stream is returned.
(We assume argstreams contains streams equal to the arity of the procedure.)
This isn't a base case.
Rather, we're procuding a stream of elements, and this case accounts for the apperance of the stream when the argument streams have been exhausted --- it's empty.

Else, we:

1. Use ~map~ to apply ~stream-car~ to the list of streams, giving a list of the (relative-)first element of each of the streams, and apply the procedure.
2. Use ~map~ to apply ~stream-cdr~ to the list of streams, giving a list of the streams (relative-)second element onwards.
   Ideally, we'd like to defer further applications of ~stream-map~.
   To do this, we need to combine the procedure with the list of streams, which is done via ~cons~ as the inputs to ~stream-map~ are a list.
3. ~cons-stream~ (1) and (2).
   So, we have the result of applying the procedure to the (relative-)first elements in the streams, and delayed evaluation of the remaining elements of the stream.

** List-steam background

Following the note at the bottom of page 320 / top of page 321, ~cons-stream~ and ~delay~ are special forms.
Else, the arguments given to either are evaluated.
(Uncomment the definition of ~cons-stream~ and see what happens!)

#+NAME: def:sc-list-stream
#+BEGIN_SRC racket
  ;; (define (cons-stream a b)
    ;; (define (delay x)
      ;; (lambda () x))
    ;; (cons a (delay b)))

  (define (stream-car strm) (car strm))

  (define (stream-cdr strm)
      ;; (define (force elem)
	;; (elem))
    (force (cdr strm)))
#+END_SRC

#+NAME: def:stream-ref
#+BEGIN_SRC racket
  (define (stream-ref s n)
    <<def:sc-list-stream>>
    (if (= n 0)
	(stream-car s)
	(stream-ref (stream-cdr s) (- n 1))))
#+END_SRC

#+NAME: def:stream-enumerate-interval
#+BEGIN_SRC racket
  (define (stream-enumerate-interval l h)
    <<def:sc-list-stream>>
    (if (> l h)
	the-empty-stream
	(cons-stream
	 l
	 (stream-enumerate-interval (+ l 1) h))))
#+END_SRC


#+NAME: def:display-line
#+BEGIN_SRC racket
  (define (display-line x)
    (display x)
    (newline))
#+END_SRC

** 3.51

#+NAME: def:stream-show
#+BEGIN_SRC racket
  (define (show x)
    <<def:display-line>>
    (display-line x)
    x)
#+END_SRC

#+RESULTS: def:stream-show

#+BEGIN_SRC racket
  <<def:sc-list-stream>>
  <<def:stream-show>>
  <<def:stream-enumerate-interval>>
  <<def:stream-map>>

  (define x (stream-map show (stream-enumerate-interval 0 10)))

  <<def:stream-ref>>

  (display "(stream-ref x 5)")
  (newline)

  (stream-ref x 5)

  (display "(stream-ref x 7)")
  (newline)

  (stream-ref x 7)
#+END_SRC

#+RESULTS:
#+begin_example
0
(stream-ref x 5)
1
2
3
4
5
5
(stream-ref x 7)
6
7
7
#+end_example

The basic observation here is that ~map~ is a one-time operation.
So, when ~(stream-ref x 7)~ is called, ~map~ has already worked on the first five elements of x.
Hence, only 6 and 7 are displayed.


Here's ~memo-proc~ and the particular ~steam-map~.
No use is made of these here.

#+BEGIN_SRC racket
  <<def:sc-list-stream>>
  <<def:stream-show>>
  <<def:stream-enumerate-interval>>
  <<def:stream-ref>>

  (define (memo-proc proc)
      (let ((already-run? false)
	    (result false))
	(lambda ()
	  (if (not already-run?)
	      (begin (set! result (proc))
		     (set! already-run? true)
		     result)
	      result))))

  (define (stream-map proc s)
      (if (stream-null? s)
	  the-empty-stream
	  (cons-stream (proc (stream-car s))
		       (stream-map proc (stream-cdr s)))))

  (define x (stream-map show (stream-enumerate-interval 5 10)))

  (stream-ref x 5)
#+END_SRC

#+RESULTS:
: 5
: 6
: 7
: 8
: 9
: 10
: 10

** 3.52

#+BEGIN_SRC racket :tangle no
  (define sum 0)
#+END_SRC

~sum~ is 0, and as the following are definitions ~sum~ remains 0 throughout.

#+BEGIN_SRC racket :tangle no
  (define (accum x)
    (set! sum (+ x sum))
    sum)
  (define seq (stream-map accum (stream-enumerate-interval 1 20)))
  (define y (stream-filter even? seq))
  (define z (stream-filter (lambda (x) (= (remainder x 5) 0))
			   seq))
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (stream-ref y 7)
#+END_SRC

~y~ is constructed up to it's seventh element.
So, as this requires seven even numbers, ~seq~ is constructed up to it's fourteenth element.
In particular, this involves setting the current element to the accumulation of all previous elements.

|  0 |   1 |
|  1 |   3 |
|  2 |   6 |
|  3 |  10 |
|  4 |  15 |
|  5 |  21 |
|  6 |  28 |
|  7 |  36 |
|  8 |  45 |
|  9 |  55 |
| 10 |  66 |
| 11 |  78 |
| 12 |  91 |
| 13 | 105 |
| 14 | 136 |

#+BEGIN_SRC racket :tangle no
  (display-stream z)
#+END_SRC

This requires displaying the value for every element in ~z~.
The elements of ~z~ are derived from ~seq~, so we'd need to complete the above table.

#+NAME: def:stream-filter
#+BEGIN_SRC racket
  (define (stream-filter pred stream)
    (cond ((stream-null? stream) the-empty-stream)
	  ((pred (stream-car stream))
	   (cons-stream (stream-car stream)
			(stream-filter pred (stream-cdr stream))))
	  (else (stream-filter pred (stream-cdr stream)))))
#+END_SRC

Here's a test for ~y~.

#+BEGIN_SRC racket :tangle no
  <<def:sc-list-stream>>
  <<def:stream-map>>
  <<def:stream-enumerate-interval>>
  <<def:stream-filter>>
  <<def:stream-ref>>

  (define sum 0)

  (define (accum x)
      (set! sum (+ x sum))
      sum)

  (define seq (stream-map accum (stream-enumerate-interval 1 20)))
  (define y (stream-filter even? seq))
  ;  (define z (stream-filter (lambda (x) (= (remainder x 5) 0))
  ;			   seq))
  (stream-ref y 7)
  y
  ;  (display-stream z)
#+END_SRC

#+RESULTS:
: 136

(This question would have been far less tedious if ~accum~ was just a counter for the number of times it was called.)

The results would change without memoisation.
For, ~z~ requires starting from the top of ~seq~.
Hence, ~accum~ would be applied a second time.

Uh, yeah, it's clear mixing assignment and sums is kind of delicate.

** 3.53

#+BEGIN_SRC racket :tangle no
  (define s (cons-stream 1 (add-streams s s)))
#+END_SRC

~s~ is a stream which beings with 1.
Then, we have ~add-streams~.
So, the second element evaluates to:

#+BEGIN_SRC racket :tangle no
  (cons-stream
   (apply + (map stream-car s s))
   (apply stream-map (cons + (map stream-cdr s s))))
#+END_SRC

Currently, ~s~ is just 1, as the ~car~ element is 2.
The second apply is deferred.
By the time it's called, ~s~ has been updated to ~(1 2 #promise)~.
Hence, ~stream-cdr~ takes in ~(2 #promise)~.
This means the third element is 4.

As we're doubling by two each time, it should be the case the value of the $n$th element is $2^{n}$.

#+NAME: def:add-streams
#+BEGIN_SRC racket :tangle no
  (define (add-streams s1 s2)
    <<def:stream-map>>
    (stream-map + s1 s2))
#+END_SRC

Quick test:

#+BEGIN_SRC racket :tangle no
  <<def:add-streams>>
  <<def:sc-list-stream>>
  (define s (cons-stream 1 (add-streams s s)))

  (car s)
  (car (stream-cdr s))
  (car (stream-cdr (stream-cdr s)))
  (car (stream-cdr (stream-cdr (stream-cdr s))))
  (car (stream-cdr (stream-cdr (stream-cdr (stream-cdr s)))))
#+END_SRC

#+RESULTS:
: 1
: 2
: 4
: 8
: 16

** 3.54

#+NAME: def:integers-starting-from
#+BEGIN_SRC racket
  (define (integers-starting-from n)
    (cons-stream n (integers-starting-from (+ n 1))))
#+END_SRC


#+NAME: def:integers-stream
#+BEGIN_SRC racket
  <<def:integers-starting-from>>

  (define integers (integers-starting-from 1))
#+END_SRC

#+NAME: def:mul-streams
#+BEGIN_SRC racket :tangle no
    (define (mul-streams s1 s2)
      <<def:stream-map>>
      (stream-map * s1 s2))
#+END_SRC

Pick up the next $n$ from the integers and $(n - 1)!$ as the previous element of ~factorials~.
Multiply these to get $n!$

#+NAME: def:factorials-stream
#+BEGIN_SRC racket
  <<def:mul-streams>>
  <<def:integers-stream>>
  (define factorials (cons-stream 1 (mul-streams (stream-cdr integers) factorials)))
#+END_SRC

Quick test:

#+BEGIN_SRC racket
  <<def:factorials-stream>>
  <<def:sc-list-stream>>

  (car factorials)
  (car (stream-cdr factorials))
  (car (stream-cdr (stream-cdr factorials)))
  (car (stream-cdr (stream-cdr (stream-cdr factorials))))
  (car (stream-cdr (stream-cdr (stream-cdr (stream-cdr factorials)))))
#+END_SRC

#+RESULTS:
: 1
: 2
: 6
: 24
: 120

** 3.55

Uh, partial sums are obtained exactly the same way as factorials, but with addition and a variable for the stream:

#+NAME: def:partial-sums
#+BEGIN_SRC racket
  <<def:add-streams>>

  (define (partial-sums s)
    (cons-stream 1 (add-streams (stream-cdr s) (partial-sums s))))
#+END_SRC

This works, but is surely not ideal.
For, the recursive call to ~partial-sums~ leads to a distinct stream.
Instead, we could do:

#+NAME: def:partial-sums-stream
#+BEGIN_SRC racket
  <<def:add-streams>>

  (define (partial-sums s)
    (define v (cons-stream 1 (add-streams (stream-cdr s) v)))
    v)
#+END_SRC

Which ensures we only have two streams in play (~s~ and ~v~).

Some tests:

#+BEGIN_SRC racket
  <<def:partial-sums-stream>>
  <<def:sc-list-stream>>
  <<def:integers-stream>>

  (define partial-sum-int (partial-sums integers))

  (car partial-sum-int)
  (car (stream-cdr partial-sum-int))
  (car (stream-cdr (stream-cdr partial-sum-int)))
  (car (stream-cdr (stream-cdr (stream-cdr partial-sum-int))))
  (car (stream-cdr (stream-cdr (stream-cdr (stream-cdr partial-sum-int)))))
#+END_SRC

#+RESULTS:
: 1
: 3
: 6
: 10
: 15

** 3.56

Hm, so I guess playing around with $2^i \times 3^j \times 5^k$ isn't going to help, as the order to increment $i$, $j$, and $k$ is unpredictable?
Right, as you may need to example all lower exponents.

Huh.

#+NAME: def:scale-stream
#+BEGIN_SRC racket
  (define (scale-stream stream factor)
    <<def:stream-map>>
    (stream-map (lambda (x) (* x factor)) stream))
#+END_SRC

#+NAME: def:merge-stream
#+BEGIN_SRC racket
  (define (merge s1 s2)
    (cond
      ((stream-null? s1) s2)
      ((stream-null? s2) s1)
      (else
       (let ((s1car (stream-car s1))
	     (s2car (stream-car s2)))
	 (cond ((< s1car s2car)
		(cons-stream s1car (merge (stream-cdr s1 ) s2)))
	       ((> s1car s2car)
		(cons-stream s2car (merge s1 (stream-cdr s2))))
	       (else
		(cons-stream s1car (merge (stream-cdr s1) (stream-cdr s2)))))))))
#+END_SRC

We merge the streams:

#+NAME: def:Hamming-stream
#+BEGIN_SRC racket
  <<def:scale-stream>>
  <<def:sc-list-stream>>
  <<def:merge-stream>>
  (define Hamming-Stream (cons-stream 1 (merge (scale-stream Hamming-Stream 2) (merge (scale-stream Hamming-Stream 3) (scale-stream Hamming-Stream 5)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:Hamming-stream>>
  <<def:stream-ref>>
  (stream-ref Hamming-Stream 49)
  (stream-ref Hamming-Stream 50)
  (stream-ref Hamming-Stream 51)
#+END_SRC

#+RESULTS:
: 243
: 250
: 256

Compare here: https://oeis.org/A051037

We can't use ~map~ to simplify this (i.e. map merge to the three streams) for ~map~ would always take the first elements of each of the streams, and the interesting thing here is that the speed each of the three streams is worked through is variable.

** 3.57

The Fibonacci stream of interset is:

#+BEGIN_SRC racket
  (define fibs
    (cons-stream 0
		 (cons-stream 1
			      (add-streams (stream-cdr fibs)
					   fibs))))
#+END_SRC

~add-streams~ performs a single addition.
So, to get the $n$th fib number, we do $n - 2$ additions (the first two numbers are addition free).

Without the memo optimisation, the $i$th element ($i > 2$) would be ~add-streams~.
That is, each element of the stream would effectively mirror the tree generated by a naive recursive implementation of fib.

But this is a lot worse than an expontential increase.

So, am I missing something?

If so, I don't see it.

On my understanding, the promised procedure is continuously being built, and so if we don't memo elements, this promised procedure must be evaluated each time.

** 3.58

radix is the base.

#+NAME: def:expand-stream
#+BEGIN_SRC racket
  (define (expand num den radix)
    (cons-stream
     (quotient (* num radix) den)
     (expand (remainder (* num radix) den) den radix)))
#+END_SRC

| quotient 10 7 | 1 |
| quotient 30 7 | 4 |
| quotient 20 7 | 2 |

etc.

Here, we're providing the decimal expansion of ~(/ num den)~ in base ~radix~.

#+BEGIN_SRC racket
  <<def:stream-ref>>
  <<def:expand-stream>>
  (define expand1710 (expand 1 7 10))
  (stream-ref expand1710 0)
  (stream-ref expand1710 1)
  (stream-ref expand1710 2)
  (stream-ref expand1710 3)
#+END_SRC

#+RESULTS:
: 1
: 4
: 2
: 8

$\frac{1}{7} \approx_{10} 0.14285$

#+BEGIN_SRC racket
  <<def:stream-ref>>
  <<def:expand-stream>>
  (define expand1710 (expand 1 17 16))

  (stream-ref expand1710 0)
  (stream-ref expand1710 1)
  (stream-ref expand1710 2)
  (stream-ref expand1710 3)
#+END_SRC

#+RESULTS:
: 0
: 15
: 0
: 15

$\frac{1}{17} \approx_{12} 0.0F0F0F$

** 3.59

To help solve this problem in an easily generalisable way, we make use of ~div-streams~, the partner of ~mul-streams~.

#+NAME: def:div-streams
#+BEGIN_SRC racket
  (define (div-streams s1 s2)
    <<def:stream-map>>
    (stream-map / s1 s2))
#+END_SRC

*** a.

#+NAME: def:integrate-series
#+BEGIN_SRC racket
  (define (integrate-series s)
    (define ones (cons-stream 1 ones))
    <<def:integers-starting-from>>
    <<def:mul-streams>>
    <<def:div-streams>>
    (mul-streams s (div-streams ones (integers-starting-from 1))))
#+END_SRC


*** b.

#+NAME: def:co~sine-streams
#+BEGIN_SRC racket
  <<def:integrate-series>>
  <<def:stream-map>>
  (define cosine-series (cons-stream 1 (integrate-series (stream-map - sine-series))))
  (define sine-series (cons-stream 0 (integrate-series cosine-series)))
#+END_SRC

Tests for sine:

#+BEGIN_SRC racket
  <<def:co~sine-streams>>
  <<def:stream-ref>>
  (stream-ref sine-series 1)
  (stream-ref sine-series 3)
  (stream-ref sine-series 5)
#+END_SRC

#+RESULTS:
: 1
: -1/6
: 1/120

And tests for cosine:

#+BEGIN_SRC racket
  <<def:co~sine-streams>>
  <<def:stream-ref>>
  (stream-ref cosine-series 2)
  (stream-ref cosine-series 4)
  (stream-ref cosine-series 6)
#+END_SRC

#+RESULTS:
: -1/2
: 1/24
: -1/720

** 3.60

Some background is required (I think, at least).

Searching around, the Cauchy product is often used when multiplying two series.

$$

\left(\sum_{i = 0}^{\inf} a_{i}\right) \times \left(\sum_{j = 0}^{\inf} b_{j}\right) = \left(\sum_{k = 0}^{\inf} c_{k}\right)

$$

where!

$$

c_{k} = \sum_{l = 0}^{k} (a_{l} \times b_{k - 1})

$$

For example, we have:

| c_0 | a_0 b_0                               |
| c_1 | a_0 b_1 + a_1 b_0                     |
| c_2 | a_0 b_2 + a_1 b_1 + a_2 b_0           |
| c_3 | a_0 b_3 + a_1 b_2 + a_2 b_1 + a_3 b_0 |

So, to multiply two streams, we can work in terms of the Cauchy product.

After starting at this table for a while, you might start to look down.

In particular, the first column is an infite sequence, where a_0 is fixed, and we're collecting elements from the b series.
The second is a sequence where a_0 is fixed, and a_0 doesn't appear again.

With this in hand, all we need to do for the next Cauchy product is to add a new stream.

This is how ~mul-series~ has been set up.
As we've already obtained the product of the first two elements, we add the remainder of the b series, scaled by the current a instance, and on the next call we'll add to this the b scaled by the next a instance, and so on.

#+NAME: def:mul-series
#+BEGIN_SRC racket
  (define (mul-series s1 s2)
    <<def:sc-list-stream>>
    <<def:add-streams>>
    <<def:scale-stream>>
    (cons-stream (* (stream-car s1) (stream-car s2))
		 (add-streams
		  (scale-stream (stream-cdr s2) (stream-car s1))
		  (mul-series (stream-cdr s1) s2))))
#+END_SRC


#+RESULTS: def:mul-series

Okay, to test:

#+BEGIN_SRC racket
  <<def:mul-series>>
  <<def:co~sine-streams>>
  <<def:add-streams>>

  (define mul-sine-cosine
    (add-streams (mul-series cosine-series
			     cosine-series)
		 (mul-series sine-series
			     sine-series)))

  <<def:stream-ref>>

  (stream-ref mul-sine-cosine 0)
  (stream-ref mul-sine-cosine 1)
  (stream-ref mul-sine-cosine 2)
  (stream-ref mul-sine-cosine 3)
  (stream-ref mul-sine-cosine 4)
  (stream-ref mul-sine-cosine 5)
#+END_SRC

#+RESULTS:
: 1
: 0
: 0
: 0
: 0
: 0

This seems to work.

I would have liked a hint toward Cauchy sequences, though!

** 3.61

This follows the suggestion in the book.


#+NAME: def:invert-unit-series
#+BEGIN_SRC racket
  (define (invert-unit-series s)
    <<def:stream-map>>
    <<def:mul-series>>
    <<def:sc-list-stream>>

    (define X (cons-stream 1 (stream-map - (mul-series (stream-cdr s) X))))
    X)
#+END_SRC

We use ~eat~ to test.
In short, ~eat~ is the result of evaluating the first ~n~ terms of a series.
This is very similar to ~partial-sums~ above, but instead of creating a stream and going to the nth element, we directly build the desired value.

#+NAME: def:eat-series
#+BEGIN_SRC racket
  (define (eat l n)
  <<def:sc-list-stream>>
    (if (or (null? l) (= n 0))
	0.0
	(+ (stream-car l) (eat (stream-cdr l) (- n 1)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:sc-list-stream>>
  <<def:integrate-series>>
  <<def:invert-unit-series>>

  (define exp-series
    (cons-stream 1 (integrate-series exp-series)))

  <<def:stream-ref>>
  <<def:mul-series>>
  <<def:eat-series>>

  (eat exp-series 10)
  (eat (invert-unit-series exp-series) 10)
  (eat (mul-series exp-series (invert-unit-series exp-series)) 10)
#+END_SRC

#+RESULTS:
: 2.7182815255731922
: 0.3678791887125221
: 1.0

** 3.62

Two divide two series, we'll multiply the first by the inverse of the second.

To do this, we need a general ~invert-series~ procedure.

Luckily, it's easy to build such a procedure from ~invert-unit-series~ by scaling the stream to have unit constant and then scaling the stream back away from having unit constant.

#+NAME: def:invert-series
#+BEGIN_SRC racket
  (define (invert-series s)
    <<def:scale-stream>>
    <<def:invert-unit-series>>
    (scale-stream (invert-unit-series (scale-stream s (/ 1 (car s)))) (car s)))
#+END_SRC

And, with ~invert-series~, ~div-series~ is quick!

#+NAME: def:div-series
#+BEGIN_SRC racket
  (define (div-series s1 s2)
    <<def:mul-series>>
    <<def:invert-series>>
    (mul-series s1 (invert-series s2)))
#+END_SRC

And, a test with tangent:

#+BEGIN_SRC racket
  <<def:co~sine-streams>>
  <<def:eat-series>>
  <<def:div-series>>

  (define tangent-series (div-series sine-series cosine-series))

  (eat tangent-series 100)
#+END_SRC

#+RESULTS:
: 1.5574077246549023

These exercises were interesting, but the majority of the work was figuring out series (again).
3.60 was a proper headache, but the insight was worth it!

** 3.63

#+NAME: def:sqrt-stream
#+BEGIN_SRC racket :tangle no
  (define (sqrt-stream x)
  <<def:average>>
  <<def:stream-map>>
    (define (sqrt-improve guess x)
    (average guess (/ x guess)))
    (define guesses (cons-stream 1.0 (stream-map (lambda (guess) (sqrt-improve guess x)) guesses)))
      guesses)
#+END_SRC

#+BEGIN_SRC racket :tangle no
  (define (sqrt-stream x)
    (cons-stream 1.0 (stream-map (lambda (guess) (sqrt-improve guess x)) (sqrt-stream x))))
#+END_SRC

We have two versions of ~sqrt-stream~.

The first looks something like this, when expanded:

#+BEGIN_SRC racket
  (1.0 (sqrt-improve 1.0) (sqrt-improve (sqrt-improve 1.0)) (sqrt-improve (sqrt-improve (sqrt-improve 1.0))))
#+END_SRC

And, with memoisation, any 'inner-call' to ~sqrt-improve~ is found in a lookup table.
So, really, the first looks something like this:

#+BEGIN_SRC racket
  (1.0 (sqrt-improve 1.0) (sqrt-improve m1) (sqrt-improve m2))
#+END_SRC

The second looks similar, but there is a subtle difference.
For, rather than building on the current stream, the second (recursively) makes calls to ~sqrt-stream~.
And, as this is a procedure, each evaluation of ~sqrt-stream~ is unique.
Hence, while the calls to ~sqrt-stream~ are memoised, no call is accessed a second time in order for this memoisation to be of any use.

To see the way the result of a procedure is unique, consider:

#+BEGIN_SRC racket
  (define (make a)
    (cons a nil))

  (define a1 (make 'a))
  (define a2 (make 'a))
  a1
  a2
  (set-car! a1 'b)
  a1
  a2
#+END_SRC

#+RESULTS:
: (a)
: (a)
: (b)
: (a)

The two versions would still likely differ in efficiency to some degree without memoisation.
For, the first version of ~sqrt-stream~ returns a pointer to a stream.
So, a frame for the definition is made only once.
However, the second requires further evaluation of ~sqrt-stream~, and so additional frames.

** 3.64

We begin by defining ~stream-outside-tolerance~.
This procedure takes a stream and tolerance, and returns a stream formed of:

1. The elements of the input stream where the ith and (i + 1)th elements are outside the tolerance until some pair of elements fall within the tolerance.
2. The empty stream otherwise.

(Note, this turns an infinite stream into a finite stream, if some pair of elements falls within the tolerance.)

#+NAME: def:stream-outside-tolerance
#+BEGIN_SRC racket
  (define (stream-outside-tolerance s t)
    (define (tolerance a b t)
      <<def:sc-list-stream>>
      (cond ((> t (abs (- (stream-car a) (stream-car b)))) the-empty-stream)
	    (else (cons-stream (stream-car a) (tolerance (stream-cdr a) (stream-cdr b) t)))))
    (define t-stream (cons-stream (stream-car s) (tolerance (stream-cdr s) t-stream t)))
    t-stream)
#+END_SRC

With ~stream-outside-tolerance~ in hand, we can easily work through a stream until we find the last element before the stream becomes the empty stream.

#+NAME: def:until-empty
#+BEGIN_SRC racket
  (define (until-empty s)
    <<def:sc-list-stream>>
    (if (stream-null? (stream-cdr s))
	s
	(until-empty (stream-cdr s))))
#+END_SRC

Applying ~until-empty~ to ~stream-outside-tolerance~ offers a way to figure out the limit of some process within some tolerance:

#+NAME: def:stream-limit
#+BEGIN_SRC racket
  (define (stream-limit s t)
    <<def:sc-list-stream>>
    <<def:until-empty>>
    <<def:stream-outside-tolerance>>
    (stream-car (until-empty (stream-outside-tolerance s t))))
#+END_SRC

A test with ~sqrt-stream~:

#+BEGIN_SRC racket
  <<def:sqrt-stream>>
  <<def:stream-limit>>

  (stream-limit (sqrt-stream 2) 0.001)
  (stream-limit (sqrt-stream 9) 0.01)
  (stream-limit (sqrt-stream 28) 0.1)
#+END_SRC

#+RESULTS:
: 1.4142156862745097
: 3.00009155413138
: 5.3147966118798795

My guess is there's a more elegant way to do this using something along the lines of the euler-transformation.
Though, I liked the idea of diverting streams.

** 3.65

To define the series, we make use of ~integrate-series~ and a sequence which alterates signs.

#+NAME: consts:ln2
#+BEGIN_SRC racket
  <<def:integrate-series>>
  <<def:stream-map>>
  ;  <<def:sc-list-stream>>
  (define altSign (cons-stream 1 (stream-map - altSign)))
  (define ln2 (integrate-series altSign))
#+END_SRC

Here we can check the first few elements of the definition:

#+BEGIN_SRC racket
  <<consts:ln2>>
  <<def:stream-ref>>
  (stream-ref ln2 0)
  (stream-ref ln2 1)
  (stream-ref ln2 2)
  (stream-ref ln2 3)
  (stream-ref ln2 4)
  (stream-ref ln2 5)
#+END_SRC

#+RESULTS:
: 1
: -1/2
: 1/3
: -1/4
: 1/5
: -1/6

The rest of this exercise amounts to typing out some procedures from the book and applying ~ln2~ to these.
This, then, is for some other time.

** 3.66

#+NAME: def:interleave
#+BEGIN_SRC racket
  (define (interleave s1 s2)
    <<def:sc-list-stream>>
    (if (stream-null? s1)
	s2
	(cons-stream (stream-car s1)
		     (interleave s2 (stream-cdr s1)))))
#+END_SRC

#+NAME: def:pairs-stream
#+BEGIN_SRC racket
  (define (pairs s t)
    <<def:sc-list-stream>>
    <<def:stream-map>>
    <<def:interleave>>
    (cons-stream
     (list (stream-car s) (stream-car t))
     (interleave
      (stream-map (lambda (x) (list (stream-car s) x)) (stream-cdr t))
      (pairs (stream-cdr s) (stream-cdr t)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:sc-list-stream>>
  <<def:pairs-stream>>
  <<def:integers-starting-from>>
  <<def:stream-ref>>

  (define integers (integers-starting-from 1))
  (define X (pairs integers integers))

  (stream-ref X 0)
  (stream-ref X 1)
  (stream-ref X 2)
  (stream-ref X 3)
  (stream-ref X 4)
  (stream-ref X 5)
  (stream-ref X 6)
  (stream-ref X 7)
  (stream-ref X 8)
  (stream-ref X 9)
  (stream-ref X 10)
#+END_SRC

#+RESULTS:
#+begin_example
(1 1)
(1 2)
(2 2)
(1 3)
(2 3)
(1 4)
(3 3)
(1 5)
(2 4)
(1 6)
(3 4)
#+end_example

Hm, not much from test values.

The main observation, I think, is the way ~interleave~ is applied.
We'll start with alternating between elements from the first sequence.
At the alteranate points, we have items from the remaining sequences.
Ignoring the first sequence, these will be in the same pattern.
So, elements from the second sequence and between elements from the remaining sequences.

Though, all the additional sequences are offset by one, as they're interleaved as we work through the first list.

| 1 | X | 1 | X | 1 | X |
|   | 2 |   | 2 |   | 2 |

| 1 | X | 1 | X | - | 1 | X | - |
| 1 | 2 | 1 | 2 | - | 1 | 2 | - |
| 1 | 2 | 1 | 2 | 3 | 1 | 2 | 3 |

So, with this in mind, we can see any pair (i j), ((i - 1) j) occurs in the list before (i j).
For, the sequence of ((i - 1) k) are added to the list twice as often as (i l).

Now, consider (i (j - 1)).
To obtain the j stream, we need to have interleaved the (j - 1) stream.
Hence, ((j - 1) (j - 1)) is already present in the stream.
And, by the previous observation, it follows that so long as i < j, (i (j - 1)) must be present in the stream before (i j).

Working this up into a full proof is something for a different day.

** 3.67

~pairs~ about lists (i j) such that i ≤ j.
This means, ~pairs~ does not list pairs (i j) where i > j.
For example, (3 1).

Still, it's straightforward to add (j i) rather than (i j).

#+NAME: def:more-pairs-stream
#+BEGIN_SRC racket
  (define (more-pairs s t)
    <<def:sc-list-stream>>
    <<def:stream-map>>
    <<def:interleave>>
    (cons-stream
     (list (stream-car s) (stream-car t))
     (interleave
      (interleave (stream-map (lambda (x) (list (stream-car s) x)) (stream-cdr t))
		  (more-pairs (stream-cdr s) (stream-cdr t)))
      (stream-map (lambda (x) (list x (stream-car s))) (stream-cdr t)))))
#+END_SRC

#+BEGIN_SRC racket
  <<def:sc-list-stream>>
  <<def:more-pairs-stream>>
  <<def:integers-starting-from>>
  <<def:stream-ref>>

  (define integers (integers-starting-from 1))
  (define X (more-pairs integers integers))

  (stream-ref X 0)
  (stream-ref X 1)
  (stream-ref X 2)
  (stream-ref X 3)
  (stream-ref X 4)
  (stream-ref X 5)
  (stream-ref X 7)
  (stream-ref X 11)
  (stream-ref X 15)
#+END_SRC

#+RESULTS:
: (1 1)
: (1 2)
: (2 1)
: (2 2)
: (3 1)
: (1 3)
: (2 3)
: (3 2)
: (3 3)

Further, I think it should be the case we have (i j) and (j i) before (j j), for all i < j.

** 3.68

The suggestion is:

#+NAME: def:l-pairs-stream
#+BEGIN_SRC racket
  (define (l-pairs s t)
    <<def:sc-list-stream>>
    <<def:stream-map>>
    <<def:interleave>>
    (interleave (stream-map (lambda (x) (list (stream-car s) x)) (stream-cdr t))
		  (l-pairs (stream-cdr s) (stream-cdr t))))
#+END_SRC

The problem is, we start with a call to ~interleave~.
And, the second in the desired sequence is interwoven.

But, a call to interleave requires elements of the two sequences to be accessible.
This is not possible.

** 3.69

(Si Tj Uk) such that i ≤ j ≤ k:

#+NAME: def:triples-stream
#+BEGIN_SRC racket
  (define (triples s t u)
    <<def:sc-list-stream>>
    <<def:stream-map>>
    <<def:interleave>>
    <<def:pairs-stream>>
    (cons-stream
     (list (stream-car s) (stream-car t) (stream-car u))
     (interleave
      (stream-map (lambda (x) (list (stream-car s) (car x) (cadr x))) (pairs t u))
      (triples (stream-cdr s) (stream-cdr t) (stream-cdr u)))))
#+END_SRC

Not sure if order is nice as with ~pairs~, but this works.
In short, we repeat the exact process as with ~pairs~.

In longer, the process with ~pairs~ is to take each element of s and create a stream where that element is paired with each element of j.
Then, interleave these streams.

With triples, we take an element from s and and create a stream where that element is paired with elements from t and u such that t ≤ u.
So, we've now reduced the problem one step.
To create triples, we just need to pair elements of s with the sequence obtained by pairing t and u (and then flatten the result).

In hindsight, this is intuitive.
Admittedly, it took me some headaches to figure things out.

Anyway, some quick tests:

#+BEGIN_SRC racket
  <<def:sc-list-stream>>
  <<def:triples-stream>>
  <<def:integers-starting-from>>
  <<def:stream-ref>>

  (define integers (integers-starting-from 1))
  (define X (triples integers integers integers))

  <<def:square>>
  <<def:stream-filter>>
  (define pythag-triples (stream-filter (lambda (x) (= (+ (square (car x)) (square (cadr x))) (square (caddr x)))) X))
  (stream-ref pythag-triples 0)
  (stream-ref pythag-triples 1)
  (stream-ref pythag-triples 2)
  (stream-ref pythag-triples 3)
  (stream-ref pythag-triples 4)
  (stream-ref pythag-triples 5)
  (stream-ref pythag-triples 6)
#+END_SRC

#+RESULTS:
: (3 4 5)
: (6 8 10)
: (5 12 13)
: (9 12 15)
: (8 15 17)
: (12 16 20)
: (15 20 25)

** 3.70

~merge-weighted~ is like ~merge~.

There are only three significant differences.

1. The use of weight to determine which stream to take an element from.
2. The else condition being changed to include the elements from both streams if weights are equal, so long as the elements are distinct.
3. And additional test condition for when both weights and elements are the same, to avoid the else condition adding duplicates.

#+NAME: def:merge-weighted
#+BEGIN_SRC racket
  (define (merge-weighted s1 s2 weight)
    <<def:sc-list-stream>>
    (cond
      ((stream-null? s1) s2)
      ((stream-null? s2) s1)
      (else
       (let ((s1car (stream-car s1))
	     (s2car (stream-car s2)))
	 (let ((s1carW (apply weight s1car))
	       (s2carW (apply weight s2car)))
	   (cond ((< s1carW s2carW)
		  (cons-stream s1car (merge-weighted (stream-cdr s1) s2 weight)))
		 ((> s1carW s2carW)
		  (cons-stream s2car (merge-weighted s1 (stream-cdr s2) weight)))
		 ((and (= s1carW s2carW) (eq? s1car s2car)
		       (cons-stream s1car (merge-weighted (stream-cdr s1) (stream-cdr s2) weight))))
		 (else
		  (cons-stream s1car (cons-stream s2car (merge-weighted (stream-cdr s1) (stream-cdr s2) weight))))))))))
#+END_SRC

*** a.

With ~merge-weighted~ in hand, the steam of all positive integers (i j) with i ≤ j ordered by (i + j) amounts to using ~lambda (x y) (+ x y)~ as our weight function.
However, this can be simplified (and generalised a little) by simply using ~+~.

#+NAME: def:ordered-by-sum-pairs
#+BEGIN_SRC racket
  (define (ordered-by-sum-pairs s t)
    <<def:sc-list-stream>>
    <<def:stream-map>>
    <<def:merge-weighted>>
    (cons-stream
     (list (stream-car s) (stream-car t))
     (merge-weighted
      (ordered-by-sum-pairs (stream-cdr s) (stream-cdr t))
      (stream-map (lambda (x) (list (stream-car s) x)) (stream-cdr t))
      +)))
#+END_SRC

Here's a quick test:

#+BEGIN_SRC racket
  <<def:ordered-by-sum-pairs>>
  <<def:sc-list-stream>>
  <<def:integers-starting-from>>
  <<def:stream-ref>>

  (define integers (integers-starting-from 1))
  (define X (ordered-by-sum-pairs integers integers))
  (stream-ref X 0)
  (stream-ref X 1)
  (stream-ref X 2)
  (stream-ref X 3)
  (stream-ref X 4)
  (stream-ref X 5)
  (stream-ref X 6)
  (stream-ref X 7)
  (stream-ref X 8)
  (stream-ref X 9)
#+END_SRC

#+RESULTS:
#+begin_example
(1 1)
(1 2)
(2 2)
(1 3)
(2 3)
(1 4)
(3 3)
(1 5)
(2 4)
(3 4)
#+end_example

*** b.

Our initial gol is to obtain the stream of all pairs of positive integers (i j) with i ≤ j such that neither i nor j is dividisible by 2, 3, or 5.

Earlier, we considered the Hamming numbers.
And, we created the stream of all positive integers which were divisible by exactly 2, 3, or 5.
So, to obtain the desired stream, we need only find every positive integer which does not appear in the Hamming sequence.

The relative complement of two lists is easy to determine, so long as the lists are ordered.
For, we take from the base list until to elements are the same, and ignore these elements, and repeat.

#+NAME: def:ordered-relative-complement
#+BEGIN_SRC racket
  (define (ordered-relative-complement s1 s2)
    <<def:sc-list-stream>>
    (cond
      ((stream-null? s2) s1)
      ((stream-null? s2) (error "need relative list"))
      (else
       (let ((s1car (stream-car s1))
	     (s2car (stream-car s2)))
	 (cond ((< s1car s2car)
		(cons-stream s1car (ordered-relative-complement (stream-cdr s1) s2)))
	       (else
		(ordered-relative-complement (stream-cdr s1) (stream-cdr s2))))))))
#+END_SRC

To test, we define the odds in terms of the intgers and the evens:

#+BEGIN_SRC racket
  <<def:ordered-by-sum-pairs>>
  <<def:sc-list-stream>>
  <<def:integers-starting-from>>
  <<def:stream-ref>>
  <<def:scale-stream>>
  <<def:ordered-relative-complement>>

  (define integers (integers-starting-from 1))
  (define evens (scale-stream integers 2))
  (define odds (ordered-relative-complement integers evens))
  (stream-ref odds 0)
  (stream-ref odds 1)
  (stream-ref odds 2)
  (stream-ref odds 3)
  (stream-ref odds 4)
  (stream-ref odds 5)
  (stream-ref odds 6)
  (stream-ref odds 7)
  (stream-ref odds 8)
  (stream-ref odds 9)
#+END_SRC

#+RESULTS:
#+begin_example
1
3
5
7
9
11
13
15
17
19
#+end_example

Second, we generalise ~ordered-by-sum-pairs~ to take arbitrary weights:

#+NAME: def:ordered-by-w-pairs
#+BEGIN_SRC racket
  (define (ordered-by-w-pairs s t w)
    <<def:sc-list-stream>>
    <<def:stream-map>>
    <<def:merge-weighted>>
    (cons-stream
     (list (stream-car s) (stream-car t))
     (merge-weighted
      (ordered-by-w-pairs (stream-cdr s) (stream-cdr t) w)
      (stream-map (lambda (x) (list (stream-car s) x)) (stream-cdr t))
      w)))
#+END_SRC

With the above in hand, we can define the not-Hamming stream, and order the results as requested:

#+BEGIN_SRC racket
  <<def:Hamming-stream>>
  <<def:integers-starting-from>>
  <<def:ordered-relative-complement>>
  <<def:ordered-by-w-pairs>>
  <<def:stream-ref>>

  (define integers (integers-starting-from 1))

  (define not-Hamming (ordered-relative-complement integers Hamming-Stream))

  (define X (ordered-by-w-pairs not-Hamming not-Hamming (lambda (i j) (+ (* 2 i) (* 3 j) (* 5 i j)))))

  (stream-ref X 0)
  (stream-ref X 1)
  (stream-ref X 2)
  (stream-ref X 3)
  (stream-ref X 4)
  (stream-ref X 5)
  (stream-ref X 6)
  (stream-ref X 7)
  (stream-ref X 8)
  (stream-ref X 9)
#+END_SRC

#+RESULTS:
#+begin_example
(7 7)
(7 11)
(7 13)
(7 14)
(11 11)
(7 17)
(7 19)
(11 13)
(7 21)
(11 14)
#+end_example

** 3.71

To begin, we define a general procedure which finds consecutive elements of a sequence according to some transformation:

#+NAME: def:consecutive-by
#+BEGIN_SRC racket
  (define (consecutive-by s transform)
    <<def:sc-list-stream>>
    (if (eq? (apply transform (stream-car s)) (apply transform (stream-car (stream-cdr s))))
	(cons-stream (list (stream-car s) (stream-car (stream-cdr s))) (consecutive-by (stream-cdr s) transform))
	(consecutive-by (stream-cdr s) transform)))
#+END_SRC

(Looking back after reaching  3.5.5 where a similar procedure is defined in the book, I shuffle forward by ~(stream-cdr s)~ rather than ~(stream-cdr (stream-cdr s))~.
My reasoning is moving one element at a time still creates unique pairs.)

With ~consecutive-by~ in hand, we create a procedure for the desired transformation:

#+NAME: def:cubeSum
#+BEGIN_SRC racket
  (define (cubeSum i j)
    (+ (* i i i) (* j j j)))
#+END_SRC

Now, we create the sequences.
First, all the pairs ordered by the transformation.
Then, all the consectuive pairs which have the same transformation.
And, finally, we create a sequence of the result of the transformation:

#+NAME: consts:3.71
#+BEGIN_SRC racket
  <<def:ordered-by-w-pairs>>
  <<def:integers-starting-from>>
  <<def:stream-ref>>
  <<def:cubeSum>>
  <<def:consecutive-by>>

  (define integers (integers-starting-from 1))

  (define pairsByCubesum (ordered-by-w-pairs integers integers cubeSum))

  (define consecutivePairsByCubesum (consecutive-by pairsByCubesum cubeSum))

  <<def:stream-map>>

  (define Ramanujan-stream (stream-map (lambda (x) (apply cubeSum (car x))) consecutivePairsByCubesum))
#+END_SRC

Finally, some tests:

#+BEGIN_SRC racket
  <<consts:3.71>>
  (stream-ref Ramanujan-stream 0)
  (stream-ref Ramanujan-stream 1)
  (stream-ref Ramanujan-stream 2)
  (stream-ref Ramanujan-stream 3)
  (stream-ref Ramanujan-stream 4)
  (stream-ref Ramanujan-stream 5)

  (stream-ref consecutivePairsByCubesum 2)
  (stream-ref consecutivePairsByCubesum 3)
#+END_SRC

#+RESULTS:
: 1729
: 4104
: 13832
: 20683
: 32832
: 39312
: ((18 20) (2 24))
: ((19 24) (10 27))

** 3.72

We generalise ~consecutive-by~ to look two ahead (which also means no using ~eq?~).
Otherwise, everything is the same as with Ex. 3.71.

#+BEGIN_SRC racket
  (define (consecutive-three-by s transform)
    <<def:sc-list-stream>>
    (if (=
	 (apply transform (stream-car s))
	 (apply transform (stream-car (stream-cdr s)))
	 (apply transform (stream-car (stream-cdr (stream-cdr s)))))
	(cons-stream (list (stream-car s) (stream-car (stream-cdr s)) (stream-car (stream-cdr (stream-cdr s))))
		     (consecutive-three-by (stream-cdr s) transform))
	(consecutive-three-by (stream-cdr s) transform)))

  (define (squareSum i j)
    (+ (* i i) (* j j)))

  <<def:ordered-by-w-pairs>>
  <<def:integers-starting-from>>
  <<def:stream-ref>>
  <<def:consecutive-by>>

  (define integers (integers-starting-from 1))

  (define pairsBySqauresum (ordered-by-w-pairs integers integers squareSum))


  (define consecutivePairsByCubesum (consecutive-three-by pairsBySqauresum squareSum))

  (stream-ref consecutivePairsByCubesum 0)
  (stream-ref consecutivePairsByCubesum 1)
  (stream-ref consecutivePairsByCubesum 2)
  (stream-ref consecutivePairsByCubesum 3)
  (stream-ref consecutivePairsByCubesum 4)
  (stream-ref consecutivePairsByCubesum 5)
#+END_SRC

#+RESULTS:
: ((10 15) (1 18) (6 17))
: ((13 16) (5 20) (8 19))
: ((17 19) (5 25) (11 23))
: ((14 23) (7 26) (10 25))
: ((19 22) (2 29) (13 26))
: ((15 25) (3 29) (11 27))

** 3.73

#+BEGIN_SRC racket
  (define (RC R C dt)
    <<def:add-streams>>
    <<def:scale-stream>>
    (lambda (i v0)
      (define v
	(cons-stream v0
		     (add-streams (scale-stream i R)
				  (scale-stream (scale-stream v dt) C))))
      v))

  (define RC1 (RC 5 1 0.5))
#+END_SRC

Maybe?

** 3.74

I think the suggestion is:

#+BEGIN_SRC racket
  (define zero-crossings
    (stream-map sign-change-detector sense-data (stream-cdr sense-data)))
#+END_SRC

For, the original procedure compares the current value of sense-data to the previous value of sense-data.
In this respect, we're just comparing the same stream shifted by a ~stream-cdr~.
And, we need to wait for at least two elements for this to be of interest anyway.

** 3.75

#+BEGIN_SRC racket :tangle no
    (define (make-zero-crossings input-stream last-value)
      (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
	(cons-stream (sign-change-detector avpt last-value)
		     (make-zero-crossings (stream-cdr input-stream) avpt))))
#+END_SRC

At the very leaast, ~sign-change-detector~ requires ~last-value~, so this should be preserved.
However, this is a simply edit from ~avpt~ to ~(stream-car input-stream)~, and the suggestion is an increase to the number of arguments to ~make-zero-crossings~ is required.

I read the plan is to average the last value with the current value.
However, as ~avpt~ is passed as an argument above, the averages accumulate.

Here, then, we do need an additional argumnet, as ~avpt~ cannot be calculated from ~last-valued~ alone.

Both edits:

#+BEGIN_SRC racket :tangle no
  (define (make-zero-crossings input-stream average last-value)
    (let ((avpt (/ (+ (stream-car input-stream) average) 2)))
      (cons-stream (sign-change-detector avpt last-value)
		   (make-zero-crossings (stream-cdr input-stream) avpt (stream-car input-stream)))))
#+END_SRC

** 3.76

For a general method, we start with ~consecutive-transform~, which applies some transformation to consecutive elements in a stream:

#+NAME: def:consecutive-transform
#+BEGIN_SRC racket
  (define (consecutive-transform s transform)
    <<def:sc-list-stream>>
    (cons-stream (apply transform (list (stream-car s) (stream-car (stream-cdr s))))
		 (consecutive-transform (stream-cdr s) transform)))
#+END_SRC

To see this in action:

#+BEGIN_SRC racket
  <<def:consecutive-transform>>
  <<def:integers-starting-from>>
  <<def:stream-ref>>
  <<def:scale-stream>>
  (define integers (integers-starting-from 1))
  (define X (consecutive-transform (scale-stream integers 2) +))

  (stream-ref X 0)
  (stream-ref X 1)
  (stream-ref X 2)
  (stream-ref X 3)
#+END_SRC

#+RESULTS:
: 6
: 10
: 14
: 18

With ~consecutive-transform~, the smoothed stream as described amounts to specifying taking the average as the transformation:

#+BEGIN_SRC racket :tangle no
  (define (smoothed s)
    (consecutive-transform s (lambda (x y) (/ (+ x y) 2))))
#+END_SRC

Now, it seems to me the following should work.
We compare the input-stream to whatever the current smoothed stream is.

#+BEGIN_SRC racket :tangle no
  (define (make-zero-crossings input-stream smoothed)
    (cons-stream (sign-change-detector (stream-car input-stream) (stream-car smoothed))
		 (make-zero-crossings (stream-cdr input-stream) (stream-cdr smoothed))))
#+END_SRC

** 3.77

The modified ~integral~:

#+NAME: def:integral-delay
#+BEGIN_SRC racket
  (define (integral delayed-integrand initial-value dt)
    <<def:sc-list-stream>>
    (cons-stream initial-value
		 (let ((integrand (force delayed-integrand)))
		   (if (stream-null? integrand) the-empty-stream
		       (integral (delay (stream-cdr integrand))
				 (+ (* dt
				       (stream-car integrand))
				    initial-value)
				 dt)))))
#+END_SRC

To test this, we modify ~solve~ from the book with the suggestion of how to construct simultanous definitions from section 4.16:

#+NAME: def:solve-integral
#+BEGIN_SRC racket
  (define (solve f y0 dt)
  <<def:integral-delay>>
  <<def:sc-list-stream>>
  <<def:stream-map>>
  (let ((y 'x)
	(dy 'x))
    (set! y (integral (delay dy) y0 dt))
    (set! dy (stream-map f y))
  y))
#+END_SRC

And, the test with $e$:

#+BEGIN_SRC racket
  <<def:solve-integral>>
  <<def:stream-ref>>

  (stream-ref (solve (lambda (x) x) 1 0.001) 1000)
#+END_SRC

#+RESULTS:
: 2.716923932235896

** 3.78

#+BEGIN_SRC racket
  (define (solve a b dy0 y0 dt)
    <<def:integral-delay>>
    <<def:add-streams>>
    <<def:scale-stream>>
    (let ((y nil)
	  (dy nil)
	  (ddy nil))
      (set! y (integral (delay dy) y0 dt))
      (set! dy (integral (delay ddy) dy0 dt))
      (set! ddy (add-streams (scale-stream dy a) (scale-stream y b)))
      y))

  <<def:stream-ref>>

  (stream-ref (solve 1 1 1 1 0.001) 1000)
#+END_SRC

#+RESULTS:
: 3.793448578735687


#+BEGIN_SRC racket
  (define (solve a b dy0 y0 dt)
    (define y integral (delay dy) y0 dt)
    (define dy integral (delay ddy) dy0 dt)
    (define ddy (stream-add (stream-scale dy a) (stream-scale y b))))
#+END_SRC

** 3.79

Going by vague intuition as to what a natural answer should be:

#+BEGIN_SRC racket
  (define (solve f dy0 y0 dt)
    <<def:integral-delay>>
    <<def:stream-map>>
    (define dt-stream (cons-stream dt dt-stream))
    (let ((y nil)
	  (dy nil)
	  (ddy nil))
      (set! y (integral (delay dy) y0 dt))
      (set! dy (integral (delay ddy) dy0 dt))
      (set! ddy (stream-map f dy y))
      y))
#+END_SRC

I'm not sure how to test this.

** TODO 3.80

This seems really cool, but I have no idea how to self evaluate.

Hopefully, I'll have the time to learn the appropriate background material and will return to this.

For the moment, I don't think taking a guess and seeing if it worked out is the right call.

** 3.81

This one I might come back to.

As before, we have a placeholder ~rand-update~ (~random~ isn't deterministic).

The following works fine:

#+NAME: def:rand-requests-stream
#+BEGIN_SRC racket
  (define (rand-requests this-rand requests)
    <<def:sc-list-stream>>
    (define (rand-update x) (+ x 1))
    (if (stream-null? requests)
	the-empty-stream
	(let ((new-rand (cond
			  ((eq? (car requests) 'generate) (rand-update this-rand))
			  ((eq? (car requests) 'reset) 0))))
	  (cons-stream this-rand (rand-requests new-rand (stream-cdr requests))))))
#+END_SRC

In short, we generate the random sequence in the same way we generate numbers from n.
The roll of the requests screen is to determine how the next number is generated.

And, in parallel to the solution I gave to Ex. 3.6, requests could be expanded so each element is a list, and in the case of a reset a new base value could be provided.

And, of course, this procedure can be wrapped in a procedure which just takes the requests sequence and supplies an initial number.
(Note, this would also set the reset value, if it's hardcoded.)

Here's a quick test:

#+BEGIN_SRC racket
  <<def:rand-requests-stream>>
  <<def:sc-list-stream>>
  <<def:stream-ref>>
  (define testSeq (cons-stream 'generate
			       (cons-stream 'generate
					    (cons-stream 'reset
							 (cons-stream 'generate testSeq)))))

  (stream-ref (rand-requests 0 testSeq) 0)
  (stream-ref (rand-requests 0 testSeq) 1)
  (stream-ref (rand-requests 0 testSeq) 2)
  (stream-ref (rand-requests 0 testSeq) 3)
  (stream-ref (rand-requests 0 testSeq) 4)
  (stream-ref (rand-requests 0 testSeq) 5)
  (stream-ref (rand-requests 0 testSeq) 6)
  (stream-ref (rand-requests 0 testSeq) 7)
  (stream-ref (rand-requests 0 testSeq) 8)
#+END_SRC

#+RESULTS:
: 0
: 1
: 2
: 0
: 1
: 2
: 3
: 0
: 1

** 3.82

The key idea here is a stream which records the outcomes of an experiment:

#+BEGIN_SRC racket
  (define (experiment-outcomes experiment)
    (cons-stream (experiment) (experiment-outcomes experiment)))
#+END_SRC

With a little work, we can extend ~experiment-outcomes~ to a culminative count of passed experiments:

#+NAME: def:experiment-outcomes-count
#+BEGIN_SRC racket
  (define (experiment-outcomes-count experiment count)
    (cons-stream count (experiment-outcomes-count experiment (+ count (if (experiment) 1 0)))))
#+END_SRC

Some example tests:

#+BEGIN_SRC racket
  <<def:experiment-outcomes-count>>
  <<def:random-in-range>>
  <<def:stream-ref>>
  (define (positive) (> 0 (random-in-range -1.0 1.0)))

  (define positive-stream (experiment-outcomes-count positive 0))

  (stream-ref positive-stream 0)
  (stream-ref positive-stream 1)
  (stream-ref positive-stream 2)
  (stream-ref positive-stream 3)
  (stream-ref positive-stream 4)
#+END_SRC

#+RESULTS:
: 0
: 1
: 1
: 2
: 3

Now, the monte carlo stream for an experiment is just a matter of taking the stream of culminative passed experiments and a stream recording the number of trials, and dividing each element of the former by the latter.

(Note, the ~def-fix~ is used to ensure the referenced definitions are executed before the additional definitions.)

#+NAME: def:monte-carlo-stream
#+BEGIN_SRC racket

  (define (monte-carlo-stream experiment)
    <<def:integers-starting-from>>
    <<def:stream-map>>
    <<def:experiment-outcomes-count>>
    (let ((def-fix nil))
      (define outcome-stream (experiment-outcomes-count experiment (if (experiment) 1 0)))
      (define trial-count (integers-starting-from 1))
      (stream-map / outcome-stream trial-count)
      ))
#+END_SRC


#+BEGIN_SRC racket
  <<def:random-in-range>>
  <<def:stream-ref>>
  <<def:monte-carlo-stream>>
  (define (positive) (> 0 (random-in-range -1.0 1.0)))

  (define monte-carlo-stream-a (monte-carlo-stream positive))

  (stream-ref monte-carlo-stream-a 0)
  (stream-ref monte-carlo-stream-a 1)
  (stream-ref monte-carlo-stream-a 2)
  (stream-ref monte-carlo-stream-a 3)
  (stream-ref monte-carlo-stream-a 4)
#+END_SRC

#+RESULTS:
: 0
: 1/2
: 2/3
: 1/2
: 3/5

With the above in hand, we move on to estimating $\pi$

*** estimating $\pi$

The changes to the procedures are minor, though everything is a little more streamlined as I learnt ~random-in-range~ returns rationals given the right arguments, so there's no need to scale the unit circle.

First, ~estimate-integral-stream~ amounts to modifying the experiment with random arguments and passing the now null-ary experiment to ~monte-carlo-stream~:

#+NAME: def:estimate-integral-stream
#+BEGIN_SRC racket
    (define (estimate-integral-stream P xl xh yl yh)
      <<def:monte-carlo-stream>>
      (define (P-test)
	<<def:random-in-range>>
	<<def:square>>
	(P (random-in-range xl xh) (random-in-range yl yh)))
      (monte-carlo-stream P-test))
#+END_SRC

Our experiment tests whether an (x y) is within the unit circle (very streamlined):

#+NAME: def:inside-unit-circle?
#+BEGIN_SRC racket
  (define (inside-unit-circle? x y)
    <<def:square>>
      (>= 1 (sqrt (+ (square x) (square y)))))
#+END_SRC

To obtain the stream of estimates, we apply ~estimate-integral-stream~ with appropriate ranges, and then scale the elements of the resulting stream by 4 (see 3.5 for why this is necessary).

To keep things clean, we collect procedures the stream depends on within a ~make-stream~ procedure, which is then called to get the desired stream.
I.e., focus on the ~let~ statement!

#+NAME: def:estimate-pi-circle-stream
#+BEGIN_SRC racket
  (define (make-estimate-pi-circle-stream)
    <<def:scale-stream>>
    <<def:inside-unit-circle?>>
    <<def:estimate-integral-stream>>
    (let ((stream (scale-stream (estimate-integral-stream inside-unit-circle? -1.0 1.0 -1.0 1.0) 4.0)))
      stream))

  (define estimate-pi-circle-stream (make-estimate-pi-circle-stream))
#+END_SRC

And, some tests:

#+BEGIN_SRC racket
  <<def:estimate-pi-circle-stream>>
  <<def:stream-ref>>
  (stream-ref estimate-pi-circle-stream 1)
  (stream-ref estimate-pi-circle-stream 10)
  (stream-ref estimate-pi-circle-stream 100)
  (stream-ref estimate-pi-circle-stream 1000)
  (stream-ref estimate-pi-circle-stream 10000)
  (stream-ref estimate-pi-circle-stream 100000)
#+END_SRC

#+RESULTS:
: 4.0
: 3.6363636363636362
: 3.485148514851485
: 3.132867132867133
: 3.156084391560844
: 3.1459285407145927



* Chapter 4

** 4.1

One approach, which doesn't seem quite right is to make use of ~let~.

#+BEGIN_SRC racket :tangle no
  (define (list-of-values exps env)
    (if (no-operands? exps)
	nil
	(let ((currentEval (eval (first-operand exps) env)))
	  (cons currentEval (list-of-values (rest-operands exps) env)))))
#+END_SRC

Then, right to left evaluation is acheived by:

#+BEGIN_SRC racket :tangle no
  (define (list-of-values exps env)
    (if (no-operands? exps)
	nil
	(let ((currentEval nil))
	  (begin
	  (cons currentEval (list-of-values (rest-operands exps) env))
	  (set! currentEval (eval (first-operand exps) env))))))
#+END_SRC

Though, I'm not sure this is intended.
In particular, this is relying on different aspects of the underlying lisp evaluation.
Of course, it's easier to argue ~currentEval~ must be evaluated before the main part of the ~let~ construction is complete.
Still, the same likely holds for ~cons~.
In general, as the underlying lisp is all we have, there's no way to write something that's independent of the underlying lisp.
(Unless we're focusing on specific implementation details, where ~let~ is fixed by the specification while ~cons~ is left open by the spec.)

** 4.2

*** a.

Each clause of eval applies a test to an expression.
The ~application?~ test simply checks to see whether the expression is a pair.
And, any list which contains at least one elemenet is a pair.
See:

#+BEGIN_SRC racket
  (pair? (list 1))
  (pair? (list 1 2))
#+END_SRC

#+RESULTS:
: #t
: #t

Further, many of the other expressions are implemented as tagged lists.
I.e., a list which begins with a tag and then contains the rest of the expression.

From the previous observation, we can see any tagged list will be recognised as a pair.
So, e.g., if the application is moved before ~definition?~ or ~begin?~, these tagged lists will be interpreted as applications.

*** b.

The suggestion is to make applications tagged lists, where the tag used is 'call'.
The relevant ~operator~ and ~operands~ prcoedures would then search one further down the expression.

** 4.3

The original ~eval~ looks like this:

#+BEGIN_SRC racket
  (define (eval exp env)
  (cond ((self-evaluating? exp) exp)
	((variable? exp) (lookup-variable-value exp env))
	((quoted? exp) (text-of-quotation exp))
	((assignment? exp) (eval-assignment exp env))
	((definition? exp) (eval-definition exp env))
	((if? exp) (eval-if exp env))
	((lambda? exp) (make-procedure (lambda-parameters exp) (lambda-body exp) env))
	((begin? exp) (eval-sequence (begin-actions exp) env))
	((cond? exp) (eval (cond->if exp) env))
	((application? exp) (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
	(else (error "Unknown expression type -- EVAL" exp))))
#+END_SRC

Most of the tests check to see whether the expression is a tagged-list (this includes as an argument the relevant tag).

| self-evaluating | number? or string? |
| variable        | symbol?            |
| quoted          | tagged-list        |
| assignment      | tagged-list        |
| definition      | tagged-list        |
| if              | tagged-list        |
| begin           | tagged-list        |
| cond            | tagged-list        |
| application     | pair?              |

We can reduce all the tagged-list queries to a single query for a known tag and a get to the appropriate procedure from a table which specifies how to evaluate the tagged object:

#+BEGIN_SRC racket
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
	  ((variable? exp) (lookup-variable-value exp env))
	  ((known-procedure? exp) (apply (get 'tag-eval-procs (car exp)) (cdr exp)))
	  ((application? exp) (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
	  (else (error "Unknown expression type -- EVAL" exp))))
#+END_SRC

Known tag searches a table of known procedures indexed by tag:

#+BEGIN_SRC racket
  (define (known-procedure? exp)
    (if (pair? exp)
	(if (get 'tag-eval-procs (car exp))
	    #t)))
#+END_SRC

Note, ~get~ returns the proc or ~#f~ if no entry is found in the table, and ~if~ returns the true value so long as the predicate is not evaluated to be false.
See here:

#+BEGIN_SRC racket
      (if 0
	  2
	  1)
#+END_SRC

#+RESULTS:
: 2

And to add a tag we have a the procedure:

#+BEGIN_SRC racket
  (define (add-tagged-list-eval tag proc)
    (put 'tag-eval-procs tag proc))
#+END_SRC

So, for example, we would add the condition for quotation by:

#+BEGIN_SRC racket
  (add-tagged-list-eval 'quotation text-of-quotation)
#+END_SRC

Of course, given these abstractions we could separate a table of known tags from the table of procedures.
And, as ~cond~ is really just nested ~if~ statments there's no need to convert a found procedure to ~#t~.
Though, neither change is particularly substantial.

** 4.4

binary and and or are easy to define with a pair of if conditions.

or returns true when a evals to true (really, not false) and otherwise checks to see whether b evals to true.

#+BEGIN_SRC racket
  (define (binary-or a b)
    (if a
	#t
	(if b
	    #t
	    #f)))
#+END_SRC

and return true just in case a evaled to true and b also evals to true.

#+BEGIN_SRC racket
  (define (binary-and a b)
    (if a
	(if b
	    #t
	    #f)
	#f))
#+END_SRC

These operators are generalised to lists as follows:

#+BEGIN_SRC racket
  (define (general-or list)
    (cond ((null? list) #f)
	  ((null? (cdr list)) (binary-or (car list) #f))
	  (else (binary-or (car list) (general-or (cdr list))))))
#+END_SRC

#+BEGIN_SRC racket
  (define (general-and list)
    (cond ((null? list) #f)
	  ((null? (cdr list)) (binary-and (car list) #t))
	  (else (binary-and (car list) (general-and (cdr list))))))
#+END_SRC

Though, to be honest, the recursive approach isn't particularly efficient.
Instead, we can do:

#+BEGIN_SRC racket
  (define (general-or list)
    (cond ((null? list) #f)
	  ((car list) #t)
	  (else (general-or (cdr list)))))
#+END_SRC

And:

#+BEGIN_SRC racket
  (define (general-and list)
    (cond ((null? list) #f)
	  ((null? (cdr list)) (car list))
	  ((car list) (general-and (cdr list)))
	  (else #f)))
#+END_SRC

For or, we work through the elements of a list and stop with ~#t~ just in case one of the elements is true (not false).
If the list is exhausted, we return false.

For and, we work through a list as with and.
If the list is empty, we return false.
But on a non-empty initial list, the base case is last element.
For, the (n + 1)th element is reached only if the previous n elements all evaluated to true, and hence so long as this is true, all the elements were true.

Oh, this is exactly what the question describes.

These definitions work for derived definitions.
And, they also work, I guess, for direct installation, where, e.g., ~(and a b c)~ is the list ~(a b c)~ tagged with ~'and~.
